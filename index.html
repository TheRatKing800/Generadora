<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Atenea — prototipo</title>
  <style>
    :root { --pad:16px; --radius:16px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#0f172a; color:#e5e7eb;}
    header { padding:24px var(--pad); background:#111827; border-bottom:1px solid #1f2937;}
    h1 { margin:0 0 6px; font-size:24px; font-weight:500;}
    .sub { color:#9ca3af; font-size:18px;}
    main { max-width:900px; margin: 0 auto; padding: 24px var(--pad) 80px;}
    .card { background:#111827; border:1px solid #1f2937; border-radius:var(--radius); padding: 18px; box-shadow:0 10px 25px rgba(0,0,0,.25);}
    .row { display:grid; gap:12px; }
    @media (min-width: 720px){ .row-3 { grid-template-columns: repeat(3, 1fr);} .row-2 { grid-template-columns: repeat(2, 1fr);} }
    label { font-size:18px; color:#cbd5e1; }
    select, input[type="number"], button, .pill {
      width:100%; background:#0b1220; color:#e5e7eb; border:1px solid #1f2937;
      padding:10px 12px; border-radius:12px; outline:none;
    }
    button { cursor:pointer; font-weight:400; }
    button.primary { background:#2563eb; border-color:#2563eb; }
    button.ghost { background:#0b1220; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .prompt { font-size:24px; line-height:1.5; margin: 8px 0 14px; color:#f3f4f6;}
    .opts { display:grid; gap:10px; }
    .opt { font-size:22px;  text-align:left; padding:12px; border-radius:12px; border:1px solid #1f2937; background:#0b1220; cursor:pointer; }
    .opt.correct { border-color:#16a34a; background:#0b1f14; }
    .opt.wrong   { border-color:#dc2626; background:#1a0b0b; }
    .muted { color:#9ca3af; font-size:15px; }
    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#0b1220; border:1px solid #1f2937; color:#cbd5e1; font-size:14px; }
    .spacer { height:8px; }
    .footer { position:fixed; left:0; right:0; bottom:0; padding:10px var(--pad); background:#0b1220; border-top:1px solid #1f2937; display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .score { font-weight:500; }
    .explain { margin-top:10px; color:#d1d5db; font-size:18px; }
    .hide { display:none; }
    .selected {
      border-color:#2563eb;
      background:#1e3a8a;
    }
  </style>
</head>
<body>

<main>
  <section id="panel-config" class="card">
    

  
  <!-- 🔹 PASO 1: CURSO ACADÉMICO -->
  <div class="row row-2">
    <div>
      <label for="curso">Curso académico</label>
      <select id="curso">
        <option value="">-- Selecciona curso --</option>
        <option value="Promocion_XXXIV_STP">Promoción XXXIV STP</option>
        <option value="Promocion_XXXV_STP">Promoción XXXV STP</option>
        <option value="Promocion_XXXVI_STP">Promoción XXXVI STP</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
<!-- 🔹 NUEVO BLOQUE DE SELECCIÓN EN CASCADA -->
  <div class="row row-3" id="fila-eat">
  <div id="bloque-esp" class="hide">
    <label for="especialidad">Especialidad</label>
    <select id="especialidad">
      <option value="">-- Selecciona especialidad --</option>
      <option value="GENERAL">GENERAL</option>
      <option value="CAE">CAE</option>
      <option value="CYB">CYB</option>
      <option value="MER">MER</option>
      <option value="ELC">ELC</option>
      <option value="AYF">AYF</option>
      <option value="PAO">PAO</option>
    </select>
  </div>
  <div id="bloque-asig" class="hide">
    <label for="asignatura">Asignatura</label>
    <select id="asignatura" disabled>
      <option value="">-- Selecciona asignatura --</option>
    </select>
  </div>
  <div id="bloque-tema" class="hide">
    <label for="tema">Tema</label>
    <select id="tema" disabled>
      <option value="">-- Selecciona tema --</option>
    </select>
  </div>
</div>

  <div class="spacer"></div>
  <!-- 🔹 FIN DEL BLOQUE NUEVO -->
    <div class="row row-1 hide">
  <div>
    <label for="modo">Modo de juego</label>
    <select id="modo">
  <option value="">-- Selecciona modo de juego --</option>
  <option value="estandar">Estándar (30 preguntas, revisión final)</option>
  <option value="contrarreloj">Contrarreloj (vidas + tiempo)</option>
  <option value="vidas">Por vidas (explicaciones + vidas)</option>
</select>

  </div>
</div>

  <div class="spacer"></div>
  <!-- 🔹 PASO FINAL: MODELO -->
  <div class="spacer"></div>
  <div class="row row-1 hide">
    <div>
      <label for="modelo">Modelo</label>
      <select id="modelo">
        <option value="">-- Selecciona --</option>
        <option value="A">Modelo A — Daypo</option>
        <option value="B">Modelo B — Libro</option>
        <option value="C">Modelo C — Diario de la gente</option>
        <option value="D">Modelo D — Todo</option>
        <option value="E">Modelo E — Selección por grupos</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
  <div id="opcionesModelo" class="card hide"></div>
  <div class="spacer"></div>

  <div class="row row-2">
    <button id="start" class="primary" disabled>Empezar</button>
  </div>

  </section> <!-- 🔸 CIERRE correcto de #panel-config -->

<section id="panel-test" class="card hide">
  <div class="muted" id="meta"></div>
  <div class="prompt" id="prompt"></div>
  <div id="options" class="opts"></div>
  <div id="explain" class="explain hide"></div>
</section>

<section id="panel-result" class="card hide">
  <h3>Resumen</h3>
  <p class="muted" id="summary"></p>
  <div class="spacer"></div>
  <div class="row row-2">
    <button id="retry" class="primary">Repetir con mismos ajustes</button>
    <button id="home" class="ghost">Volver al inicio</button>
  </div>
</section>

</main>

<footer class="footer">
  <div style="display:flex; gap:12px; align-items:center;">
    <span class="badge" id="modeBadge">—</span>
    <span id="lives" class="muted"></span>
    <span id="timer" class="muted"></span>
  </div>
  <div class="score" id="score">0 / 0</div>
  <div style="display:flex; gap:8px;">
    <button id="check" class="ghost">Comprobar</button>
    <button id="next" class="primary" disabled>Siguiente</button>
  </div>
</footer>


<script>
/* ==========================================================
   SUPERTEST — MOTOR BÁSICO LIMPIO
========================================================== */

const rndInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

const REGISTRY = { types: {} };

/* ========== TIPO: CONSTITUCIÓN (ejemplo) ========== */
// constitucion.js - TODAS LAS PLANTILLAS TRADUCIDAS DESDE Constitucion_prime.py

(function registerAritmetica() {

  function suma_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a + b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} + ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function multiplicacion_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    const correct = parseFloat((a * b).toFixed(2)); // hasta 2 decimales

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        let valor = correct + delta;
        // Mantener formato si el correcto tiene decimales
        if (String(correct).includes(".")) {
          valor = parseFloat(valor.toFixed(2));
        }
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} × ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function resta_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a - b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} - ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function division_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    if (b === 0) b = 1; // salvaguarda (no debería ocurrir con los rangos)

    const correct = parseFloat((a / b).toFixed(2));

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 3); // ± hasta 3
        } else {
          delta = (Math.random() < 0.5 ? -1 : 1) * 5; // saltos grandes
        }
        let valor = correct + delta;
        valor = parseFloat(valor.toFixed(2));
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} ÷ ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  REGISTRY.types["matematicas_aritmetica"] = {
    name: "Aritmética",
    templates: [suma_basica, resta_basica, multiplicacion_basica, division_basica]
  };

})();






REGISTRY.types['teoria_electrones'] = { name: 'Teoría de los electrones', templates: [configuracion_electronica,pregunta_teoria_de_los_electrones_1,pregunta_teoria_de_los_electrones_2,pregunta_teoria_de_los_electrones_3,pregunta_teoria_de_los_electrones_4,pregunta_teoria_de_los_electrones_5,pregunta_teoria_de_los_electrones_6,pregunta_teoria_de_los_electrones_7,pregunta_teoria_de_los_electrones_8,pregunta_teoria_de_los_electrones_9,pregunta_teoria_de_los_electrones_10,pregunta_teoria_de_los_electrones_11,pregunta_teoria_de_los_electrones_12,pregunta_teoria_de_los_electrones_13,pregunta_teoria_de_los_electrones_14,pregunta_teoria_de_los_electrones_15,pregunta_teoria_de_los_electrones_16,pregunta_teoria_de_los_electrones_17,pregunta_teoria_de_los_electrones_18,pregunta_teoria_de_los_electrones_19,pregunta_teoria_de_los_electrones_20,pregunta_teoria_de_los_electrones_21,pregunta_teoria_de_los_electrones_22,pregunta_teoria_de_los_electrones_23,pregunta_teoria_de_los_electrones_24,pregunta_teoria_de_los_electrones_25,pregunta_teoria_de_los_electrones_26,pregunta_teoria_de_los_electrones_27,pregunta_teoria_de_los_electrones_28,pregunta_teoria_de_los_electrones_29,pregunta_teoria_de_los_electrones_30,pregunta_teoria_de_los_electrones_31,pregunta_teoria_de_los_electrones_32,pregunta_teoria_de_los_electrones_34,pregunta_teoria_de_los_electrones_33]};
REGISTRY.types['electricidad_estatica'] = { name: 'Electricidad estática y conducción', templates: [pregunta_fuerza_electrica_generica,pregunta_campo_electrico_generica,pregunta_potencial_electrico_generica,pregunta_energia_potencial_generica,pregunta_electricidad_estatica_1,pregunta_electricidad_estatica_2,pregunta_electricidad_estatica_3,pregunta_electricidad_estatica_4,pregunta_electricidad_estatica_5,pregunta_electricidad_estatica_6,pregunta_electricidad_estatica_7,pregunta_electricidad_estatica_8,pregunta_electricidad_estatica_10,pregunta_electricidad_estatica_11,pregunta_electricidad_estatica_9,pregunta_electricidad_estatica_12,pregunta_electricidad_estatica_13,pregunta_electricidad_estatica_14,pregunta_electricidad_estatica_15,pregunta_electricidad_estatica_16,pregunta_electricidad_estatica_17,pregunta_electricidad_estatica_18,pregunta_electricidad_estatica_19,pregunta_electricidad_estatica_20,pregunta_electricidad_estatica_21,pregunta_electricidad_estatica_22,pregunta_electricidad_estatica_23,pregunta_electricidad_estatica_24,pregunta_electricidad_estatica_25,pregunta_electricidad_estatica_26]};

(function registerEOFAS(){
  function eofas_1(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la Dirección General de Política de Defensa le corresponde:",
    options: [
      "Elaborar las lineas generales de las directrices generales de política de defensa para la participación de otros Departamentos Ministeriales en la Defensa nacional",
      "Ejercer la notaría militar",
      "Establecer la aplicación de los planes de calidad de vida del personal militar.",
      "Gestionar la ordenación farmacéutica"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_2(){
  const base = [
    "El CIFAS está integrado en el EMACOM",
    "El MOPS está integrado en el Cuartel General del EMAD",
    "El EMACON es el órgano auxiliar de mando del JEMAD",
    "__META__" // se convertirá en "A y C son correctas."
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar índices de las opciones que la meta debe referenciar
  const idxCIFAS = barajadas.indexOf("El CIFAS está integrado en el EMACOM");
  const idxEMACON = barajadas.indexOf("El EMACON es el órgano auxiliar de mando del JEMAD");

  // Reescribir la opción meta con las letras reales
  barajadas[idxMeta] = `${letra(idxCIFAS)}) y ${letra(idxEMACON)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta correcta",
    options: barajadas,
    correct: [2] // ⚠️ cámbialo según cuál/es la correcta
  };
}



function eofas_3(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Como órgano de asesoramiento y asistencia inmediata, el Ministro de Defensa cuenta con:",
    options: [
      "La Dirección General de Política de Defensa",
      "La Oficina de Comunicación de la Defensa",
      "El Consejo Superior de los Ejércitos.",
      "Un Gabinete Técnico"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_4(){
  const base = [
    "Dirigir el Plan de Diplomacia de Defensa",
    "Elaborar y proponer disposiciones en materia de retribuciones militares",
    "__META__", // se convertirá en "a) y b) son correctas."
    "El asesoramiento sobre los aspectos relacionados con el estudio, planeamiento y desarrollo de las actividades de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los índices de las dos opciones que la meta debe referenciar
  const idxDiplomacia = barajadas.indexOf("Dirigir el Plan de Diplomacia de Defensa");
  const idxRetribuciones = barajadas.indexOf("Elaborar y proponer disposiciones en materia de retribuciones militares");

  // Reescribir la opción meta con las letras reales
  barajadas[idxMeta] = `${letra(idxDiplomacia)}) y ${letra(idxRetribuciones)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la Secretaría General de Política de Defensa le corresponde:",
    options: barajadas,
    correct: [0] // ⚠️ cámbialo según cuál/es la correcta
  };
}



function eofas_5(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de dirigir la elaboración de los tratados internacionales que afecten a la Defensa es:",
    options: [
      "La SEDEF",
      "La DIGENPER",
      "La SUBDEF.",
      "La Secretaría General de Política de Defensa"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_6(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: [
      "Garantizar la seguridad criptográfica",
      "La función de asesoramiento militar al Presidente del Gobierno",
      "Coordinar el Plan General de la Defensa Nacional.",
      "Asesorar al Secretario de Estado de Defensa en el desarrollo de la política económica de sus ejércitos"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_7(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano auxiliar de mando del JEMAD que apoya y asesora en la definición de la estrategia militares:",
    options: [
      "El EMACON",
      "La SUBDEF",
      "La SEDEF.",
      "El EMACOM"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_8(){
  const base = [
    "Dirigir la política de armamento, en relación con organismos internacionales",
    "Asegurar la eficacia operativa de las Fuerzas Armadas",
    "__META__", // se convertirá en "a) y c) son correctas."
    "Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar las dos opciones que debe referenciar la meta
  const idxArmamento = barajadas.indexOf("Dirigir la política de armamento, en relación con organismos internacionales");
  const idxEjercer = barajadas.indexOf("Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas");

  // Reescribir el texto meta con las letras reales
  barajadas[idxMeta] = `${letra(idxArmamento)}) y ${letra(idxEjercer)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: barajadas,
    correct: [1] // ⚠️ cambia este índice según cuál/es sean correctas
  };
}



function eofas_9(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de realizar las expropiaciones de bienes y derechos así como los arrendamientos pertinentes es:",
    options: [
      "La DIGENIN",
      "La DGAM",
      "La DIGENPER.",
      "La DIGENECO"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_10(){
  const base = [
    "Es un mando conjunto de la estructura operativa constituido de forma permanente",
    "Tiene como misión la intervención en cualquier lugar del territorio nacional exclusivamente",
    "__META__", // se convertirá en "b) y c) son correctas."
    "El JEMAD dictará las normas que regulen su organización"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los índices de las dos opciones que la meta debe señalar
  const idxMision = barajadas.indexOf("Tiene como misión la intervención en cualquier lugar del territorio nacional exclusivamente");
  const idxJEMAD = barajadas.indexOf("El JEMAD dictará las normas que regulen su organización");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMision)}) y ${letra(idxJEMAD)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "La UME:",
    options: barajadas,
    correct: [0] // ⚠️ cámbialo según cuál/es sean las correctas
  };
}



function eofas_11(){
  const base = [
    "Desarrollar la política medioambiental del Departamento",
    "Administrar los recursos financieros destinados a las operaciones de paz",
    "__META__", // se convertirá en "a) y c) son correctas."
    "Dirigir la gestión de los bienes afectos al Ministerio de Defensa"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los índices de las dos opciones que debe señalar la meta
  const idxMedioambiente = barajadas.indexOf("Desarrollar la política medioambiental del Departamento");
  const idxBienes = barajadas.indexOf("Dirigir la gestión de los bienes afectos al Ministerio de Defensa");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMedioambiente)}) y ${letra(idxBienes)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENECO le corresponde:",
    options: barajadas,
    correct: [1] // ⚠️ cámbialo según cuál/es sean correctas
  };
}



function eofas_12(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de llevar el inventario de los bienes del Ministerio de Defensa es:",
    options: [
      "La Secretaría de Estado de Defensa",
      "La Dirección General de Infraestructura",
      "La Subdirección General de Régimen Interior.",
      "La Dirección General de Patrimonio e Inventario"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_13(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de gestionar los sistemas informáticos integrales de dirección y administración económica del Departamento es:",
    options: [
      "La Subdirección General de Servicios Económicos y Pagadurías",
      "La SEGENTE",
      "DIGENECO.",
      "DIGENIN"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_14(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de la dirección de las tecnologías y seguridad de la información en el ámbito de la defensa es:",
    options: [
      "El Presidente del Gobierno",
      "La Junta de Defensa Nacional",
      "La SEDEF.",
      "El JEMAD"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_15(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de proponer la política industrial de la defensa es:",
    options: [
      "La SUBDEF",
      "La DIGENECO",
      "La DGAM",
      "La DGAN"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_16(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de la gestión de los servicios generales del órgano central es:",
    options: [
      "La Secretaría General Técnica",
      "La Subdirección General de Régimen Interior",
      "La Subdirección General de Seguridad y Servicios.",
      "La Subdirección General de Servicios"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_17(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de elaborar estudios e informes sobre cuántos asuntos sean sometidos a la deliberación del Consejo de Ministros es:",
    options: [
      "La SEGENTE",
      "La Dirección General de Sanidad",
      "La Asesoría Jurídica General.",
      "La DIGENPER"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_18(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado del registro general en el órgano central en el Ministerio de Defensa es:",
    options: [
      "La Subdirección General de Régimen Interior",
      "La SEGENTE",
      "La Subdirección General de Registro y Archivos.",
      "La SUBDEF"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_19(){
  const base = [
    "Elaborar el BOD",
    "Coordinar la política de igualdad",
    "__META__", // se convertirá en "a) y c) son correctas."
    "Proponer y elaborar normas sobre reformas de métodos de trabajo"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar índices de las opciones que la meta debe referenciar
  const idxBOD = barajadas.indexOf("Elaborar el BOD");
  const idxNormas = barajadas.indexOf("Proponer y elaborar normas sobre reformas de métodos de trabajo");

  // Reescribir la opción meta con las letras reales
  barajadas[idxMeta] = `${letra(idxBOD)}) y ${letra(idxNormas)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENPER le corresponde:",
    options: barajadas,
    correct: [1] // ⚠️ cámbialo según cuál/es la correcta
  };
}


function eofas_20(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la SEGENTE le corresponde:",
    options: [
      "Gestionar el personal militar de los Cuerpos Comunes",
      "Coordinar la política social para el personal militar",
      "Atender al gobierno de los órganos centrales del Ministerio.",
      "Coordinar, gestionar e inspeccionar las Delegaciones de Defensa"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_21(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta incorrecta:",
    options: [
      "El Ejército de Tierra está constituido por el Cuartel General, la Fuerza y el Apoyo a la Fuerza",
      "A la DIGENPER le corresponde elaborar el régimen general de los centros docentes militares, del alumnado y del profesorado",
      "A la DIGENPER le corresponde reconocer los derechos pasivos y conceder las prestaciones de clases pasivas del personal militar.",
      "A la DIGENPER le corresponde planificar los efectivos y el reclutamiento del personal militar"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_22(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de gestionar la formación para el personal civil es:",
    options: [
      "La DIGENPER",
      "La DIGEREM",
      "La Subdirección General de Régimen Interior.",
      "La SEGENTE"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_23(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de elaborar los planes de salidas profesionales del personal de las FAS es:",
    options: [
      "La DIGENPER",
      "La Dirección General de Política de Defensa",
      "La DIGEREN.",
      "La DIGEREM"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_24(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Inspector General de Sanidad será desempeñado por:",
    options: [
      "Un General de Brigada del Cuerpo Militar de Sanidad",
      "Un Oficial General de los Cuerpos Comunes",
      "Un General de División del Cuerpo Militar de Sanidad, en situación de servicio activo.",
      "Un General de División de cualquiera de los Ejércitos"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_25(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ejército de Tierra, la Armada y el Ejército del Aire están constituidos por:",
    options: [
      "El Cuartel General, la Logística y el Apoyo a la Fuerza",
      "La Fuerza, el Apoyo a la Fuerza y el Cuartel General",
      "El Apoyo a la Fuerza, el Cuartel General y las Fuerzas Operativas.",
      "La Fuerza, la Logística y el Mando Supremo"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_26(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Consejo Superior del Ejército del Aire es el órgano colegiado asesor y consultivo de:",
    options: [
      "El Presidente del Gobierno",
      "El Subsecretario de Defensa",
      "La Junta de Defensa Nacional.",
      "El Ministro de Defensa"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_27(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Secretario del CSEA será ejercido por:",
    options: [
      "El Vocal Accidental que se designe",
      "No existe el cargo de Secretario en el Consejo",
      "El Oficial General titular de la Secretaría Permanente del CSEA.",
      "El Vocal de mayor antigüedad"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_28(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al General Jefe del MACOM en el Consejo le corresponderá ser:",
    options: [
      "Vocal Accidental",
      "Vocal asesor",
      "Depende del tipo de reunión a realizar.",
      "Vocal Nato"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_29(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Consejo Superior del Ejército del Aire le corresponde:",
    options: [
      "Emitir informe sobre aquellos asuntos que someta a su consideración el JEMA",
      "Ser oído por el Ministro de Defensa en relación con su propuesta de designación del Jefe de Estado Mayor del Aire",
      "Todas las anteriores son correctas.",
      "Asesorar al Ministro de Defensa en materias relativas a la estructuración del E.A"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_30(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Las reuniones del Consejo Superior del Ejército del Aire serán convocadas por:",
    options: [
      "El Ministro de Defensa",
      "El Presidente del Gobierno",
      "El Director de Política de Defensa.",
      "El Jefe de Estado Mayor de la Defensa"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_31(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Es función del CSEA:",
    options: [
      "Informar las evaluaciones para el ascenso al empleo de Teniente de los Militares de Complemento",
      "Ser oído por el Ministro de Defensa en relación con su propuesta de designación del JEMAD",
      "Todas las anteriores son ciertas.",
      "Emitir informe en aquellos asuntos que someta a su consideración expresa el JEMA"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_32(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "¿A que órgano le corresponde impartir los Altos Estudios de la Defensa Nacional?",
    options: [
      "Centro Superior de Altos Estudios de la Defensa(CESADEF)",
      "Centro Superior de Estudios de la Defensa Institucional(CESEDIN)",
      "Centro Superior de Estudios de la Defensa Nacional(CEDEDEN)",
      "Centro Universitario de la Defensa (CUD)."
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_33(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El organismo público dependiente directamente del titular del Departamento, y responsable de facilitar las informaciones, análisis, estudios o propuestas que permitan prevenir y evitar cualquier peligro, amenaza o agresión contra la independencia o integridad territorial de España, los intereses nacionales y la estabilidad del Estado de derecho y sus instituciones es:",
    options: [
      "Dirección Institucional de Contrainteligencia de la Defensa",
      "Asesoría de Información y Riesgos del Ministerio de Defensa",
      "Subdirección de Análisis e Información de la Defensa.",
      "Centro Nacional de Inteligencia"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}

REGISTRY.types["eofas"] = {
    name: "EOFAS",
    templates: [
eofas_1,
eofas_2,
eofas_3,
eofas_4,
eofas_5,
eofas_6,
eofas_7,
eofas_8,
eofas_9,
eofas_10,
eofas_11,
eofas_12,
eofas_13,
eofas_14,
eofas_15,
eofas_16,
eofas_17,
eofas_18,
eofas_19,
eofas_20,
eofas_21,
eofas_22,
eofas_23,
eofas_24,
eofas_25,
eofas_26,
eofas_27,
eofas_28,
eofas_29,
eofas_30,
eofas_31,
eofas_32,
eofas_33

    ]
  };
})();

(function registerConstitucion(){

  function t_constitucion(){
    const anios = [1808,1837,1845,1869,1876];
    const personas = ["Napoleón","María Cristina de Borbón","Isabel II","General Francisco Serrano","Alfonso XII"];
    const idx = Math.floor(Math.random()*anios.length);
    const anio = anios[idx], persona = personas[idx];
    const distractores = personas.filter(p=>p!==persona).sort(()=>Math.random()-0.5).slice(0,3);
    const options = [persona,...distractores].sort(()=>Math.random()-0.5);
    return { modelos:["A","B","C","D","E"], mode:"single", prompt:`La Constitución de ${anio} fue entregada por:`, options, correct:[options.indexOf(persona)] };
  }

  

  REGISTRY.types["constitucion"] = {
    name: "Constitución",
    templates: [
      t_constitucion
    ]
  };
})();


/* ---------- Estado ---------- */
let state = {
  typeKey: null,
  templateName: "__random__",
  mode: "estandar",   // nuevo
  total: 30,          // por defecto
  asked: 0,
  correct: 0,
  lives: 3,           // para contrarreloj/vidas
  timeLeft: 40,       // tiempo actual por pregunta
  level: 1,
  current: null,
  selection: new Set(),
  curso: null,
  modelo: null,
  modeloConfig: {}
};


/* ---------- Referencias UI ---------- */
const elStart = document.getElementById('start');
const panelConfig = document.getElementById('panel-config');
const panelTest = document.getElementById('panel-test');
const panelResult = document.getElementById('panel-result');
const elPrompt = document.getElementById('prompt');
const elOptions = document.getElementById('options');
const elExplain = document.getElementById('explain');
const elMeta = document.getElementById('meta');
const elScore = document.getElementById('score');
const elNext = document.getElementById('next');
const elCheck = document.getElementById('check');
const elModeBadge = document.getElementById('modeBadge');
const elSummary = document.getElementById('summary');
const elRetry = document.getElementById('retry');
const elHome = document.getElementById('home');
const selEsp = document.getElementById("especialidad");
const selAsig = document.getElementById("asignatura");
const selTema = document.getElementById("tema");

const selCurso = document.getElementById("curso");
const selModelo = document.getElementById("modelo");
const divOpcModelo = document.getElementById("opcionesModelo");

// Compatibilidad: ejecutar cuando el DOM esté listo (sin syntaxes modernas)
function onReady(cb){
  if (document.readyState !== 'loading') cb();
  else document.addEventListener('DOMContentLoaded', cb);
}

// Buscar el contenedor .row de un elemento sin usar ?.closest
function getRow(el){
  var p = el;
  while (p && p !== document.body){
    if (p && p.classList && p.classList.contains('row')) return p;
    p = p.parentNode;
  }
  return null;
}

// Mostrar/ocultar nodos usando una clase CSS (más robusto que style.display)
function show(node, on){
  if (!node) return;
  if (on) node.classList.remove('hide');
  else node.classList.add('hide');
}


/* ---------- Lógica ---------- */
function makeQuestion(){
  const def = REGISTRY.types[state.typeKey];
  let fn;
  if (state.templateName === "__random__"){
    fn = def.templates[rndInt(0, def.templates.length-1)];
  } else {
    fn = def.templates[parseInt(state.templateName,10)];
  }
  return fn();
}

function renderQuestion() {
  if (!state.typeKey || !REGISTRY.types[state.typeKey]) {
    elPrompt.textContent = "❌ Error: no hay ejercicios cargados para este tema.";
    return;
  }

  // Usar directamente el pool ya preparado en startTest()
  if (!state.pool || state.pool.length === 0) {
    if (state.repeatables && state.repeatables.length > 0) {
      state.pool = state.repeatables.slice();
    } else {
      showResult();
      return;
    }
  }

  // Elegir al azar una plantilla del pool
  let q = null;
  let f = null;
  let idx = -1;
  let attempts = 0;
  const maxAttempts = Math.max(3, state.pool.length);

  while (!q && state.pool.length > 0 && attempts < maxAttempts) {
    attempts++;
    idx = rndInt(0, state.pool.length - 1);
    f = state.pool[idx];
    try {
      const candidate = f();
      if (!candidate || typeof candidate !== 'object') {
        throw new Error('Plantilla devolvió un resultado no válido');
      }
      if (!Array.isArray(candidate.options) || candidate.options.length < 2) {
        throw new Error('Pregunta sin opciones suficientes');
      }
      q = candidate;
      if (!q.repeatable) {
        state.pool.splice(idx, 1);
      }
    } catch (err) {
      console.error('[render] Plantilla fallida', f && f.name, err);
      state.pool.splice(idx, 1);
      state.repeatables = state.repeatables.filter(fn => fn !== f);
    }
  }

  if (!q) {
    showResult();
    return;
  }

  // Guardar la pregunta actual
  state.current = q;
  console.log('[render] Pregunta:', state.current.prompt);
  console.log('[render] Opciones:', (state.current.options || []));

  state.selection = new Set();

  const { mode, prompt, options } = state.current;

  elModeBadge.textContent = (mode === "multi" ? "MODO: Múltiple" : "MODO: Única");

  // 👇 Aquí el cambio importante
  elPrompt.innerHTML = prompt || "—";

  elExplain.classList.add('hide');
  elExplain.textContent = "";

  // Pintar opciones
  elOptions.innerHTML = "";
  options.forEach((text, idx) => {
    const btn = document.createElement('button');
    btn.className = 'opt';
    btn.type = "button";
    btn.dataset.index = String(idx);

    // 👇 Usamos innerHTML para que se rendericen tablas HTML
    btn.innerHTML = `<strong>${String.fromCharCode(97 + idx)})</strong> ${text}`;

    btn.addEventListener('click', () => toggleSelect(idx, btn));
    elOptions.appendChild(btn);
  });

  // Equivalencias en recuadro bajo las respuestas
  (function () {
    var box = document.getElementById('equivalenciasBox');
    if (box) {
      box.parentNode && box.parentNode.removeChild(box);
      box = null;
    }
    if (Array.isArray(state.current.equivalencias) && state.current.equivalencias.length) {
      box = document.createElement('div');
      box.id = 'equivalenciasBox';
      box.className = 'card';
      box.style.marginTop = '12px';
      box.style.fontSize = '18px';
      box.style.lineHeight = '1.5';
      var html = '<strong>Equivalencias</strong>' + '<div style="margin-top:6px">'
        + (state.current.equivalencias || []).map(function (e) { return '<div>&bull; ' + e + '</div>'; }).join('') + '</div>';
      box.innerHTML = html;
      elOptions.insertAdjacentElement('afterend', box);
    }
  })();

  // Modo contrarreloj
  if (state.mode === "contrarreloj") {
    clearInterval(state.timerId);
    state.timeLeft = Math.max(20, 40 - (state.level - 1) * 5);
    updateHUD();
    state.timerId = setInterval(() => {
      state.timeLeft--;
      updateHUD();
      if (state.timeLeft <= 0) {
        state.lives--;
        clearInterval(state.timerId);
        if (state.lives <= 0) {
          showResult();
          return;
        } else if (state.timerId) {
          clearInterval(state.timerId);
          state.timerId = null;
        }
        nextQuestion();
      }
    }, 1000);
  }

  // Meta
  elMeta.textContent = state.total ? `Pregunta ${state.asked + 1} de ${state.total}` : `Pregunta ${state.asked + 1}`;
  elNext.disabled = true;
  updateScore();
  updateHUD();
}





function toggleSelect(idx, elBtn){
  const mode = state.current.mode;
  if (mode === "single"){
    state.selection.clear();
    Array.from(elOptions.children).forEach(ch=>{
      ch.classList.remove('selected');
    });
    state.selection.add(idx);
    elBtn.classList.add('selected');
  } else {
    if (state.selection.has(idx)){
      state.selection.delete(idx);
      elBtn.classList.remove('selected');
    } else {
      state.selection.add(idx);
      elBtn.classList.add('selected');
    }
  }
}

function checkAnswer(){
if (state.selection.size===0) return;

  // detener el temporizador mientras se corrige la pregunta
  if (state.mode === "contrarreloj" && state.timerId){
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const correctSet = new Set(state.current.correct);
  const isCorrect = (
    state.selection.size === correctSet.size &&
    Array.from(state.selection).every(i => correctSet.has(i))
  );

  console.log('[check] Selección:', Array.from(state.selection));
  console.log('[check] Correctas:', Array.from(correctSet));
  console.log('[check] ¿Correcto?:', isCorrect);

  // Pintado de feedback
  Array.from(elOptions.children).forEach((btn, i)=>{
    if (correctSet.has(i)) btn.classList.add('correct');
    else if (state.selection.has(i)) btn.classList.add('wrong');
    btn.disabled = true;
  });

  if (isCorrect){
    state.correct++;
    if (state.correct % 5 === 0){ state.level++; }
  } else {
    if (state.mode === "contrarreloj" || state.mode === "vidas"){
      state.lives = Math.max(0, state.lives - 1);
      updateHUD();
      if (state.lives <= 0){ showResult(); return; }
    }
  }

  // Explicación (si la hay)
  if (state.current.explanation){
    elExplain.classList.remove('hide');
    elExplain.classList.add('card');
    var extra = document.createElement('div');
    extra.style.marginTop = '8px';
    extra.textContent = state.current.explanation;
    elExplain.appendChild(extra);
  }

  elNext.disabled = false;
  updateScore();
}


function nextQuestion(){
  state.asked++;
  if (state.total && state.asked >= state.total){
    showResult();
  } else {
      renderQuestion();
}
}


function updateScore(){
  elScore.textContent = `${state.correct} / ${state.asked} acertadas`;
}

function startTest(){
  if (state.timerId) {
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const esp = selEsp.value;
  const asig = selAsig.value;
  const tema = selTema.value;
  const modoSel = document.getElementById("modo").value;

  state.curso = selCurso.value;
  if (!state.curso){ 
    alert("Selecciona el curso académico."); 
    return; 
  }

  state.modelo = selModelo.value;
  if (!state.modelo){ 
    alert("Selecciona el modelo (A–E)."); 
    return; 
  }

  state.mode = modoSel;
  state.asked = 0;
  state.correct = 0;
  state.lives = 3;
  state.level = 1;
  state.timeLeft = 40;
  state.selection = new Set();
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);

  // Inicializar arrays vacíos para evitar errores
  state.pool = [];
  state.repeatables = [];

  // 🔹 Definimos un mapeo de combinaciones a typeKey
  MAPEO_TEMAS = {
    "GENERAL|Constitución|Test Constitución": "constitucion",
    "GENERAL|EOFAS|EOFAS": "eofas",
    "GENERAL|English|Basic English": "ingles_basico",
    "GENERAL|English|Advance English": "ingles_advanzado",
    "CYB|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "CAE|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "PAO|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "CYB|Itinerario Personal para la Empleabilidad|Salud Laboral" : "salud_laboral_cyb",
    "CAE|Itinerario Personal para la Empleabilidad|Salud Laboral" : "salud_laboral_cyb",
    "PAO|Itinerario Personal para la Empleabilidad|Salud Laboral" : "salud_laboral_cyb",
    "CYB|Sistemas informáticos y redes locales|Introducción a la electrónica digital" : "electronica_digital",
    "CAE|Sistemas informáticos y redes locales|Introducción a la electrónica digital" : "electronica_digital",
    "PAO|Sistemas informáticos y redes locales|Introducción a la electrónica digital" : "electronica_digital",
    "ELC|Fundamentos de electricidad|Electricidad estática y conducción": "electricidad_estatica",
    "MER|Fundamentos de electricidad|Electricidad estática y conducción": "electricidad_estatica",
    "PAO|Sistemas de telefonía fija y móvil|Introducción": "introduccion_telefonia",
    "CYB|Sistemas de telefonía fija y móvil|Introducción": "introduccion_telefonia",
    "CAE|Sistemas de telefonía fija y móvil|Introducción": "introduccion_telefonia",
    "MER|Matemáticas|Aritmética": "matematicas_aritmetica",
    "ELC|Matemáticas|Aritmética": "matematicas_aritmetica",
    "MER|Fundamentos de electricidad|Teoría de los electrones": "teoria_electrones",
    "ELC|Fundamentos de electricidad|Teoría de los electrones": "teoria_electrones"
  };

  const key = `${esp}|${asig}|${tema}`;
  state.typeKey = MAPEO_TEMAS[key];

  // Si no está implementado → mostrar aviso, pero mantener el wizard abierto
  if (!state.typeKey || !REGISTRY.types[state.typeKey]) {
    alert(`⚠️ Tema aún no implementado: ${esp} → ${asig} → ${tema}`);
    return;  // 👈 ya no oculta ni reinicia, solo no arranca el test
  }

  // 🔹 Construir pool filtrado
  const def = REGISTRY.types[state.typeKey];
  const templates = Array.isArray(def.templates) ? def.templates : [];

  // Construir el pool inicial de plantillas válidas según el modelo
  state.pool = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo);
    } catch(e){ 
      return false; 
    }
  });

  // Guardar aparte las repetibles para reponerlas cuando se vacíe el pool
  state.repeatables = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo) && q.repeatable === true;
    } catch(e){ 
      return false; 
    }
  });

  // Si no hay preguntas en el pool → avisar y volver al wizard
  if (state.pool.length === 0){
    alert(`⚠️ El tema ${def.name} no tiene preguntas para el modelo ${state.modelo}.`);
    panelTest.classList.add('hide');
    panelConfig.classList.remove('hide');
    return;
  }

  // Ajustar número total de preguntas según modo
  if (state.mode === "estandar") {
    // 🔹 Comprobar si el tema tiene plantillas repetibles
    const hasRepeatables = templates.some(f => {
      try {
        const q = f();
        return q.repeatable === true;
      } catch(e) {
        return false;
      }
    });

    if (hasRepeatables) {
      state.total = 30;   // ✅ fija 30 preguntas aunque se repitan
    } else {
      state.total = state.pool.length;  // ✅ solo las disponibles (no repetibles)
    }
  } else {
    state.total = null;  // en otros modos (vidas, contrarreloj) no hay límite fijo
  }

  // Mostrar panel del test
  panelConfig.classList.add('hide');
  panelResult.classList.add('hide');
  panelTest.classList.remove('hide');

  updateHUD();
  renderQuestion();
}




// En el script
function updateHUD(){
  if (state.mode!=="estandar"){
    document.getElementById("lives").textContent = "❤".repeat(state.lives);
  } else {
    document.getElementById("lives").textContent = "";
  }
  if (state.mode==="contrarreloj"){
    document.getElementById("timer").textContent = state.timeLeft+"s";
  } else {
    document.getElementById("timer").textContent = "";
  }
}


function showResult(){
  panelTest.classList.add('hide');
  panelResult.classList.remove('hide');

  if (state.total){
    elSummary.textContent = `Has acertado ${state.correct} de ${state.total} (${Math.round(100*state.correct/state.total)}%).`;
  } else {
    elSummary.textContent = `Has acertado ${state.correct} preguntas.`;
  }
}


/* ---------- Eventos ---------- */
elStart.addEventListener('click', startTest);
elCheck.addEventListener('click', checkAnswer);
elNext.addEventListener('click', nextQuestion);
elRetry.addEventListener('click', startTest);
elHome.addEventListener('click', ()=>{
  if (state.timerId) { clearInterval(state.timerId); state.timerId = null; }
  panelResult.classList.add('hide');
  panelConfig.classList.remove('hide');
});



/* ---------- Atajos ---------- */
window.addEventListener('keydown', (e)=>{
  if (panelTest.classList.contains('hide')) return;
  const key = e.key.toLowerCase();
  const map = { a:0, b:1, c:2, d:3 };
  if (key in map){
    const idx = map[key];
    const btn = elOptions.children[idx];
    if (btn && !btn.disabled) btn.click();
  } else if (key === 'enter'){
    if (!elNext.disabled) nextQuestion(); else checkAnswer();
  } else if (key === 'n'){
    if (!elNext.disabled) nextQuestion();
  }
});


/* ---------- Datos de especialidades ---------- */
const ESPECIALIDADES_BY_CURSO = {
  "Promocion_XXXIV_STP": {},
  "Promocion_XXXV_STP": {},
  "Promocion_XXXVI_STP": {
    "GENERAL": {
      "Constitución": ["Test Constitución"],
      "EOFAS": ["EOFAS"],
      "English": ["Basic English","Advance English"]
    },
    "CAE": {
      "Técnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonía fija y móvil":["Introducción","Introducción a la telefonía","Evolución de la estructura de la red telefónica","La señal telefónica","Telefonía digital","Multiplexación de canales MIC","Tecnologías de banda ancha. RDSI y ATM","Estructura de la red y tráfico telefónico", "Conmutación telefónica","Sistemas digitales de conmutación","Sistema privado de conmutación PBX"],
      "Auditoría Redes WIFI":["Introducción","Herramientas de auditoría de redes LAN inalámbricas","Criptografía","Medidas de seguridad básicas","Herramientas de captura y analisis de tráfico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    },
    "CYB": {
      "Técnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonía fija y móvil":["Introducción","Introducción a la telefonía","Evolución de la estructura de la red telefónica","La señal telefónica","Telefonía digital","Multiplexación de canales MIC","Tecnologías de banda ancha. RDSI y ATM","Estructura de la red y tráfico telefónico", "Conmutación telefónica","Sistemas digitales de conmutación","Sistema privado de conmutación PBX"],
      "Auditoría Redes WIFI":["Introducción","Herramientas de auditoría de redes LAN inalámbricas","Criptografía","Medidas de seguridad básicas","Herramientas de captura y analisis de tráfico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"],
      "Itinerario Personal para la Empleabilidad":["Salud Laboral"],
      "Sistemas informáticos y redes locales":["Introducción a la electrónica digital"]
    },
    "MER": {
      "Matemáticas":["Aritmética","Álgebra","Geometría"],
      "Física":["La materia","Mecánica","Termodinámica","Óptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["Teoría de los electrones", "Electricidad estática y conducción", "Terminología eléctrica","Generación de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "Teoría del motor/Generador DC","Teoría de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electrónica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["Capítulo 0","Forma del fuselaje","Esfuerzos y deformación","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que actúan en el avión","Velocidades de influencia estructural","Sección D","Cargas estructurales en el helicóptero","Certificación de las estructuras aeronáuticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromecámico":["Generalidades","Rendimiento y limitaciones humanas","Psicología social", "Factores que afectan al rendimiento","Entorno físico","Tareas","Comunación","Error humano","Riesgos Laborales"]
    },
    "ELC": {
      "Matemáticas":["Aritmética","Álgebra","Geometría"],
      "Física":["La materia","Mecánica","Termodinámica","Óptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["Teoría de los electrones", "Electricidad estática y conducción", "Terminología eléctrica","Generación de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "Teoría del motor/Generador DC","Teoría de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electrónica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["Capítulo 0","Forma del fuselaje","Esfuerzos y deformación","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que actúan en el avión","Velocidades de influencia estructural","Sección D","Cargas estructurales en el helicóptero","Certificación de las estructuras aeronáuticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromecámico":["Generalidades","Rendimiento y limitaciones humanas","Psicología social", "Factores que afectan al rendimiento","Entorno físico","Tareas","Comunación","Error humano","Riesgos Laborales"]
    },
    "AYF": {},
    "PAO": {
      "Técnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonía fija y móvil":["Introducción","Introducción a la telefonía","Evolución de la estructura de la red telefónica","La señal telefónica","Telefonía digital","Multiplexación de canales MIC","Tecnologías de banda ancha. RDSI y ATM","Estructura de la red y tráfico telefónico", "Conmutación telefónica","Sistemas digitales de conmutación","Sistema privado de conmutación PBX"],
      "Auditoría Redes WIFI":["Introducción","Herramientas de auditoría de redes LAN inalámbricas","Criptografía","Medidas de seguridad básicas","Herramientas de captura y analisis de tráfico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    }
  }
};

/* ---------- Flujo paso a paso (wizard) y opciones de modelo ---------- */
function updateStartEnabled(){
  const okCurso = !!selCurso.value;
  const okEsp   = !!selEsp.value;
  const okAsig  = !!selAsig.value;
  const okTema  = !!selTema.value;

  const modoSel = document.getElementById("modo").value;
  let okModo = !!modoSel;

  const modelo  = selModelo.value;
  let okModelo  = !!modelo;

  // Validaciones específicas de C/E
  if (modelo === "C"){
    var tipoCEl = document.getElementById("tipoC");
    const tipoC = (tipoCEl && tipoCEl.value) ? tipoCEl.value : "";
    okModelo = okModelo && !!tipoC;
  } else if (modelo === "E"){
    const grupos = Array.from(document.querySelectorAll('input[name="grupoE"]:checked'));
    const tipos  = Array.from(document.querySelectorAll('input[name="tipoE"]:checked'));
    const requiereTipos = (
      selAsig.value.toLowerCase().includes("matem") ||
      selTema.value.toLowerCase().includes("aritm")
    );
    okModelo = okModelo && grupos.length > 0 && (requiereTipos ? tipos.length > 0 : true);
  }

  // El botón siempre está visible, solo se activa/desactiva
  const ready = okCurso && okEsp && okAsig && okTema && okModo && okModelo;
  elStart.disabled = !ready;
}


function renderModelOptions(){
  const modelo = selModelo.value;
  divOpcModelo.innerHTML = "";
  divOpcModelo.classList.add("hide");

  if (!modelo){ updateStartEnabled(); return; }

  if (modelo === "C"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label for="tipoC">Modelo C — ¿qué quieres?</label>
          <select id="tipoC">
            <option value="">-- Selecciona --</option>
            <option value="teoria">Teoría</option>
            <option value="practica">Práctica</option>
            <option value="ambas">Ambas</option>
          </select>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    document.getElementById("tipoC").addEventListener("change", updateStartEnabled);
  } else if (modelo === "E"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label>Grupos (puedes marcar varios)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="A"> Grupo A (Daypo)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="B"> Grupo B (Libro)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="C"> Grupo C (Diario)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="D"> Grupo D (Todo)</label>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="row row-2">
        <div>
          <label>Tipos de ejercicio (si aplica)</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="suma_basica"> Sumas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="resta_basica"> Restas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="multiplicacion_basica"> Multiplicaciones</label>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    Array.from(divOpcModelo.querySelectorAll('input[name="grupoE"], input[name="tipoE"]')).forEach(ch => {
      ch.addEventListener("change", updateStartEnabled);
    });
  }
  updateStartEnabled();

  }


function setupWizard(){
  // Referencias a bloques (no usar getRow con E/A/T porque comparten la misma fila)
  var rowEsp    = document.getElementById("bloque-esp");
  var rowAsig   = document.getElementById("bloque-asig");
  var rowTema   = document.getElementById("bloque-tema");
  var rowModo   = getRow(document.getElementById("modo"));
  var rowModelo = getRow(selModelo);
  var rowStart  = getRow(elStart);
  var filaEAT  = document.getElementById("fila-eat");

  // Estado inicial — solo visible "Curso"
  show(rowEsp,    false);
  show(rowAsig,   false);
  show(rowTema,   false);
  show(rowModo,   false);
  show(rowModelo, false);
  // ❌ no ocultamos rowStart, el botón siempre se ve

  selAsig.disabled = true;
  selTema.disabled = true;
  divOpcModelo.classList.add('hide');
  divOpcModelo.innerHTML = "";

  // PASO 1 → Curso
  function handleCursoChange(){
  try {
    selEsp.value = "";
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";
    const hasCurso = !!selCurso.value;
    selEsp.disabled = !hasCurso;
    if (filaEAT) show(filaEAT, hasCurso);
    show(rowEsp, hasCurso);
    show(rowAsig, false);
    show(rowTema, false);
    show(rowModo, false);
    show(rowModelo, false);
    updateStartEnabled();
    console.log('[wizard] curso change:', selCurso.value);
  } catch(e){ console.error('[wizard] handleCursoChange error', e); }
}
selCurso.addEventListener('change', handleCursoChange);
selCurso.addEventListener('input', handleCursoChange);


    if (selCurso && selCurso.value) { handleCursoChange(); }

// PASO 2 → Especialidad
  selEsp.addEventListener("change", function(){
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    if (!cursoSel){
      alert("⚠️ Selecciona primero el curso académico.");
      selEsp.value = "";
      return;
    }
    var esp = selEsp.value;
    var data = ESPECIALIDADES_BY_CURSO[cursoSel] && ESPECIALIDADES_BY_CURSO[cursoSel][esp];

    if (data){
      Object.keys(data).forEach(function(a){
        var opt = document.createElement("option");
        opt.value = a; opt.textContent = a;
        selAsig.appendChild(opt);
      });
      selAsig.disabled = Object.keys(data).length === 0;
    } else {
      selAsig.innerHTML = '<option value="">— Sin datos para esta especialidad —</option>';
      selAsig.disabled = true;
    }

    show(rowAsig,   true);
    show(rowTema,   false);
    show(rowModo,   false);
    show(rowModelo, false);

    updateStartEnabled();
  });

  // PASO 3 → Asignatura
  selAsig.addEventListener("change", function(){
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    var esp = selEsp.value;
    var asig = selAsig.value;
    var temas = ESPECIALIDADES_BY_CURSO[cursoSel] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp][asig];

    if (Array.isArray(temas)){
      temas.forEach(function(t){
        var opt = document.createElement("option");
        opt.value = t; opt.textContent = t;
        selTema.appendChild(opt);
      });
      selTema.disabled = temas.length === 0;
    }

    show(rowTema,   true);
    show(rowModo,   false);
    show(rowModelo, false);

    // Reset de modo/modelo
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 4 → Tema
  selTema.addEventListener("change", function(){
    show(rowModo,   !!selTema.value);
    show(rowModelo, false);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 5 → Modo
  document.getElementById("modo").addEventListener("change", function(){
    show(rowModelo, !!this.value);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 6 → Modelo
  selModelo.addEventListener("change", function(){
    renderModelOptions();
    updateStartEnabled();
  });

  // Recalcular si cambia el modo (vidas/tiempo)
  var modoSel = document.getElementById("modo");
  if (modoSel) modoSel.addEventListener("change", updateStartEnabled);

  updateStartEnabled();
}






// Ejecutar setup inmediatamente (el script está al final del body)





onReady(function(){
  setupWizard();
});


const ELEMENTOS = {
  1: { nombre: "Hidrógeno", config: "1s¹" },
  2: { nombre: "Helio", config: "1s²" },
  3: { nombre: "Litio", config: "1s² 2s¹" },
  4: { nombre: "Berilio", config: "1s² 2s²" },
  5: { nombre: "Boro", config: "1s² 2s² 2p¹" },
  6: { nombre: "Carbono", config: "1s² 2s² 2p²" },
  7: { nombre: "Nitrógeno", config: "1s² 2s² 2p³" },
  8: { nombre: "Oxígeno", config: "1s² 2s² 2p⁴" },
  9: { nombre: "Flúor", config: "1s² 2s² 2p⁵" },
  10: { nombre: "Neón", config: "1s² 2s² 2p⁶" },
  11: { nombre: "Sodio", config: "1s² 2s² 2p⁶ 3s¹" },
  12: { nombre: "Magnesio", config: "1s² 2s² 2p⁶ 3s²" },
  13: { nombre: "Aluminio", config: "1s² 2s² 2p⁶ 3s² 3p¹" },
  14: { nombre: "Silicio", config: "1s² 2s² 2p⁶ 3s² 3p²" },
  15: { nombre: "Fósforo", config: "1s² 2s² 2p⁶ 3s² 3p³" },
  16: { nombre: "Azufre", config: "1s² 2s² 2p⁶ 3s² 3p⁴" },
  17: { nombre: "Cloro", config: "1s² 2s² 2p⁶ 3s² 3p⁵" },
  18: { nombre: "Argón", config: "1s² 2s² 2p⁶ 3s² 3p⁶" },
  19: { nombre: "Potasio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 4s¹" },
  20: { nombre: "Calcio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 4s²" },
  21: { nombre: "Escandio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹ 4s²" },
  22: { nombre: "Titanio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d² 4s²" },
  23: { nombre: "Vanadio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d³ 4s²" },
  24: { nombre: "Cromo", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁵ 4s¹" },
  25: { nombre: "Manganeso", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁵ 4s²" },
  26: { nombre: "Hierro", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁶ 4s²" },
  27: { nombre: "Cobalto", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁷ 4s²" },
  28: { nombre: "Níquel", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁸ 4s²" },
  29: { nombre: "Cobre", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s¹" },
  30: { nombre: "Zinc", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s²" },
  31: { nombre: "Galio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p¹" },
  32: { nombre: "Germanio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p²" },
  33: { nombre: "Arsénico", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p³" },
  34: { nombre: "Selenio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁴" },
  35: { nombre: "Bromo", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁵" },
  36: { nombre: "Kriptón", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶" },
  37: { nombre: "Rubidio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 5s¹" },
  38: { nombre: "Estroncio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 5s²" },
  39: { nombre: "Itrio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹ 5s²" },
  40: { nombre: "Circonio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d² 5s²" },
  41: { nombre: "Niobio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁴ 5s¹" },
  42: { nombre: "Molibdeno", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁵ 5s¹" },
  43: { nombre: "Tecnecio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁵ 5s²" },
  44: { nombre: "Rutenio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁷ 5s¹" },
  45: { nombre: "Rodio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁸ 5s¹" },
  46: { nombre: "Paladio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰" },
  47: { nombre: "Plata", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s¹" },
  48: { nombre: "Cadmio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s²" },
  49: { nombre: "Indio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s² 5p¹" },
  50: { nombre: "Estaño", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s² 5p²" },

  
};


const EQUIVALENCIAS = {
  distancia: {
    km: { m: {num: 1000, den: 1} },
    m: {
      km: {num: 1, den: 1000},
      cm: {num: 100, den: 1},
      mm: {num: 1000, den: 1},
      in: {num: 39.37, den: 1},
      ft: {num: 3.281, den: 1},
      yd: {num: 1.094, den: 1},
      mi: {num: 1/1609, den: 1}
    },
    cm: { m: {num: 1, den: 100}, mm: {num: 10, den: 1} },
    mm: { m: {num: 1, den: 1000}, cm: {num: 1, den: 10} },
    in: { m: {num: 1, den: 39.37}, ft: {num: 1, den: 12} },
    ft: { m: {num: 1, den: 3.281}, in: {num: 12, den: 1}, yd: {num: 1, den: 3} },
    yd: { m: {num: 1, den: 1.094}, ft: {num: 3, den: 1} },
    mi: { m: {num: 1609, den: 1}, yd: {num: 1760, den: 1} }
  },

  tiempo: {
    h: { min: {num: 60, den: 1}, s: {num: 3600, den: 1}, d: {num: 1/24, den: 1} },
    min: { h: {num: 1, den: 60}, s: {num: 60, den: 1} },
    s: { min: {num: 1, den: 60}, h: {num: 1, den: 3600}, ms: {num: 1000, den: 1} },
    ms: { s: {num: 1, den: 1000} },
    d: { h: {num: 24, den: 1}, año: {num: 1, den: 365} },
    año: { d: {num: 365, den: 1} }
  },


  datos: {
    bit: {
      byte: {num: 1, den: 8}
    },
    byte: {
      bit: {num: 8, den: 1},
      KB: {num: 1, den: 1024}
    },
    KB: {
      byte: {num: 1024, den: 1},
      MB: {num: 1, den: 1024}
    },
    MB: {
      KB: {num: 1024, den: 1},
      GB: {num: 1, den: 1024}
    },
    GB: {
      MB: {num: 1024, den: 1}
    }
  },

  temperatura: {
    C: {
      K: { type: "affine", scale: 1, offset: 273.15, display: "K = °C + 273.15" },
      F: { type: "affine", scale: 9/5, offset: 32, display: "°F = °C * 1.8 + 32" }
    },
    K: {
      C: { type: "affine", scale: 1, offset: -273.15, display: "°C = K - 273.15" },
      F: { type: "affine", scale: 9/5, offset: -459.67, display: "°F = K * 1.8 - 459.67" }
    },
    F: {
      C: { type: "affine", scale: 5/9, offset: -(32 * 5/9), display: "°C = (°F - 32) * 5/9" },
      K: { type: "affine", scale: 5/9, offset: 273.15 - (32 * 5/9), display: "K = (°F - 32) * 5/9 + 273.15" }
    }
  }
};

const UNIT_LABELS = {
  C: "°C",
  F: "°F",
  K: "K"
};

function formatUnitLabel(unit) {
  return UNIT_LABELS[unit] || unit;
}

function formatNumber(num) {
// Formateo robusto con notación científica cuando el redondeo daría 0
  if (!Number.isFinite(num)) {
    return String(num);
  }
  if (Number.isInteger(num)) {
    return String(num);
  }
  const abs = Math.abs(num);
  const fixed = num.toFixed(3);
  const trimmed = fixed.replace(/\.?0+$/, '');
  if (parseFloat(trimmed) === 0 && abs > 0) {
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mant.toFixed(3).replace(/\.?0+$/, '') + '\u00d7' + '10' + expStr;
  }
  return trimmed === '-0' ? '0' : trimmed;
}




function applyConversion(value, rule) {
  if (!rule) {
    throw new Error("Regla de conversión ausente");
  }
  if (typeof rule.convert === "function") {
    return rule.convert(value);
  }
  if (rule.type === "affine") {
    return value * rule.scale + rule.offset;
  }
  if (typeof rule.num !== "undefined" && typeof rule.den !== "undefined") {
    return value * (rule.num / rule.den);
  }
  throw new Error("Tipo de conversión no soportado");
}

function describeConversion(from, to, rule) {
const fromLabel = formatUnitLabel(from);
  const toLabel = formatUnitLabel(to);

  if (rule && rule.display) {
    return rule.display;
  }

  const hasNumDen = rule && typeof rule.num !== 'undefined' && typeof rule.den !== 'undefined';
  const isComposite = String(from).includes('/') || String(to).includes('/');

  // Si tenemos factor numérico, siempre lo mostramos, también para compuestas
  if (hasNumDen) {
    const factor = rule.num / rule.den;
    const factorStr = formatNumber(factor);
    if (isComposite) {
      const splitFrom = String(from).split('/');
      const splitTo = String(to).split('/');
      const fNum = splitFrom[0] || from;
      const fDen = splitFrom[1] || '';
      const tNum = splitTo[0] || to;
      const tDen = splitTo[1] || '';
      const hints = [];
      if (fNum && tNum && fNum !== tNum) {
        hints.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
      }
      if (fDen || tDen) {
        if (fDen && tDen && fDen !== tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
        } else if (fDen && !tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)})`);
        } else if (!fDen && tDen) {
          hints.push(`/ (${formatUnitLabel(tDen)})`);
        }
      }
      const hintStr = hints.length ? ` ${hints.join(' ')}` : '';
      return `1 ${fromLabel} = ${factorStr} ${toLabel}${hintStr}`;
    }
    return `1 ${fromLabel} = ${factorStr} ${toLabel}`;
  }

  if (rule && rule.type === 'affine') {
    const scale = formatNumber(rule.scale);
    const offset = rule.offset || 0;
    if (!offset) {
      return `${toLabel} = ${scale} * ${fromLabel}`;
    }
    const signo = offset >= 0 ? '+' : '-';
    return `${toLabel} = ${scale} * ${fromLabel} ${signo} ${formatNumber(Math.abs(offset))}`;
  }

  // Fallback composito solo con etiquetas si no hay num/den
  if (isComposite) {
    const splitFrom = String(from).split('/');
    const splitTo = String(to).split('/');
    const fNum = splitFrom[0] || from;
    const fDen = splitFrom[1] || '';
    const tNum = splitTo[0] || to;
    const tDen = splitTo[1] || '';
    const parts = [];
    if (fNum && tNum) parts.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
    if (fDen || tDen) {
      if (fDen && tDen) parts.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
      else if (fDen) parts.push(`/ (${formatUnitLabel(fDen)})`);
      else if (tDen) parts.push(`/ (${formatUnitLabel(tDen)})`);
    }
    return `${fromLabel} = ${parts.join(' ')}`;
  }

  return `${fromLabel} \u2192 ${toLabel}`;
}






function conversion_unidades() {  function sci(num){
    if (!Number.isFinite(num)) return String(num);
    if (num === 0) return '0';
    const abs = Math.abs(num);
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const mantStr = mant.toFixed(3).replace(/\.?0+$/, '');
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mantStr + '\u00d7' + '10' + expStr;
  }

  function generarDistractores(valor) {
    const candidatos = new Set();
    const addCandidate = (num) => {
      if (!Number.isFinite(num)) return;
      if (num === valor) return;
      candidatos.add(num);
    };
    addCandidate(valor * 10);
    addCandidate(valor / 10);
    const absValor = Math.abs(valor) || 1;
    const order = Math.floor(Math.log10(absValor));
    let step;
    if (order >= 2) step = Math.pow(10, order - 1);
    else if (order === 1) step = 10;
    else if (order === 0) step = 1;
    else step = Math.pow(10, order);
    if (!Number.isFinite(step) || step === 0) step = absValor * 0.1 || 0.1;
    [Math.floor(valor / step) * step, Math.ceil(valor / step) * step].forEach(addCandidate);
    addCandidate(valor + step);
    addCandidate(valor - step);
    [0.9, 1.1, 0.95, 1.05].forEach((f)=>addCandidate(valor * f));
    let i = 1;
    while (candidatos.size < 3 && i <= 12){ addCandidate(valor + i*step*0.1); addCandidate(valor - i*step*0.1); addCandidate(valor*(1+i*0.02)); i++; }
    if (!candidatos.size){ addCandidate(valor + absValor); addCandidate(valor - absValor); addCandidate(valor + absValor*0.5); }
    return shuffle(Array.from(candidatos));
  }

  function buscarCaminoSimple(grafo, pasos) {
    const unidades = shuffle(Object.keys(grafo));
    for (const origen of unidades) {
      const visitados = new Set([origen]);
      const camino = [origen];
      const res = explorar(origen, pasos, grafo, visitados, camino);
      if (res) return res;
    }
    return null;
  }

  function explorar(actual, restantes, grafo, visitados, camino) {
    if (restantes === 0) return [...camino];
    const vecinos = shuffle(Object.keys(grafo[actual] || {}).filter(u=>!visitados.has(u)));
    for (const v of vecinos){
      visitados.add(v); camino.push(v);
      const r = explorar(v, restantes-1, grafo, visitados, camino);
      if (r) return r;
      camino.pop(); visitados.delete(v);
    }
    return null;
  }

  let intentos = 0;
  const allMagnitudes = Object.keys(EQUIVALENCIAS).filter(k => k !== 'temperatura');

  while (intentos < 10){
    intentos++;
    console.log(`\uD83D\uDD04 Intento ${intentos}`);

    // Elegir cuántas magnitudes combinar (2 a 4)
    const k = Math.min(4, Math.max(2, rndInt(2, Math.min(4, allMagnitudes.length))));
    const mags = shuffle(allMagnitudes).slice(0, k);

    // Partición en numerador/denominador (al menos 1 arriba)
    const numCount = rndInt(1, mags.length);
    const numeradores = mags.slice(0, numCount);
    const denominadores = mags.slice(numCount);

    console.log('[conv] Combinación:', {numeradores, denominadores});

    // Construir caminos por magnitud
    let valido = true;
    const piezas = [];
    for (const [rol, lista] of [['num', numeradores], ['den', denominadores]]){
      for (const mag of lista){
        const grafo = EQUIVALENCIAS[mag];
        const pasos = rndInt(1, 2);
        const camino = buscarCaminoSimple(grafo, pasos);
        if (!camino){ valido = false; break; }
        let factor = 1; const localSteps = [];
        for (let i=0;i<camino.length-1;i++){
          const a = camino[i], b = camino[i+1];
          const regla = (grafo[a]||{})[b];
          if (!regla){ valido = false; break; }
          localSteps.push({from:a, to:b, rule:regla});
          factor = applyConversion(factor, regla);
        }
        if (!valido) break;
        piezas.push({ rol, mag, path: localSteps, factor, from: camino[0], to: camino[camino.length-1], pasos: camino.length-1 });
      }
      if (!valido) break;
    }
    if (!valido || piezas.length === 0) continue;

    // Construir unidades compuestas origen/destino con punto medio
    const dot = '\u00b7';
    const numFrom = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.from));
    const denFrom = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.from));
    const numTo   = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.to));
    const denTo   = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.to));
    const unitFrom = numFrom.join(dot) + (denFrom.length? '/' + denFrom.join(dot) : '');
    const unitTo   = numTo.join(dot)   + (denTo.length?   '/' + denTo.join(dot)   : '');

    console.log('✅ Camino compuesto:', unitFrom, '→', unitTo);

    // Cantidad
    const cantidad = rndInt(1, 20);
    console.log(`\uD83D\uDCE6 Cantidad inicial: ${sci(cantidad)} ${unitFrom}`);

    // Factor combinado
    let factorTotal = 1; const factores = [];
    for (const pieza of piezas){
      for (const st of pieza.path){
        factores.push(describeConversion(st.from, st.to, st.rule));
      }
      if (pieza.rol === 'num') factorTotal *= pieza.factor; else factorTotal /= pieza.factor;
    }

    let valor = cantidad * factorTotal;
    if (!Number.isFinite(valor)){ console.error('💥 Valor no finito:', valor); continue; }

    const correctoStr = sci(valor);
    console.log(`🎯 Resultado correcto: ${correctoStr} ${unitTo}`);
    console.log('🧮 Factores aplicados:', factores);

    const distractoresNum = generarDistractores(valor);
    if (distractoresNum.length < 3){
      const set = new Set(distractoresNum); const base = Math.max(Math.abs(valor), 1);
      let extra=1; while (set.size<3){ set.add(valor + base*extra); extra++; }
      distractoresNum.splice(0, distractoresNum.length, ...Array.from(set));
    }
    const opcionesFmt = shuffle([valor, ...distractoresNum.slice(0,3)]).map(sci);
    console.log('🧠 Opciones generadas:', opcionesFmt);

    return {
      tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
      prompt: `Convierte ${sci(cantidad)} ${unitFrom} a ${unitTo}.`,
      equivalencias: factores,
      options: opcionesFmt,
      correct: [opcionesFmt.indexOf(correctoStr)]
    };
  }

  console.error('❌ No se pudo generar pregunta válida, devolviendo fallback...');
  return { tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
    prompt: 'Convierte 1 km a m. (Equivalencia: 1 km = 1000 m)', options: ['1000','100','10','2000'], correct: [0] };
}






REGISTRY.types["ingles_basico"] = {
  name: "Basic English",
  templates: [conversion_unidades]
};
REGISTRY.types["ingles_advanzado"] = {
  name: "Advance English",
  templates: [conversion_unidades]
};



REGISTRY.types["magnitudes_y_unidades"] = {
  name: "Magnitudes y Unidades",
  templates: [conversion_unidades]
};
REGISTRY.types["electronica_digital"] = {
  name: "Introducción a la electrónica digital",
  templates: [pregunta_cronograma_verdad]
};

REGISTRY.types["salud_laboral_cyb"] = {
  name: "Salud Laboral",
  templates: [pregunta_salud_laboral_1,pregunta_salud_laboral_2,pregunta_salud_laboral_3]
};
REGISTRY.types["introduccion_telefonia"] = {
  name: "Introducción",
  templates: [magnitudes_electricas_cyb]
};


// --- Banco de magnitudes ---
const magnitudesData = [
  { magnitud: "Tensión", simbolo: "U o V", unidad: "Voltio" },
  { magnitud: "Intensidad", simbolo: "I", unidad: "Amperio" },
  { magnitud: "Resistencia", simbolo: "R", unidad: "Ohmio" },
  { magnitud: "Capacidad", simbolo: "C", unidad: "Faradio" },
  { magnitud: "Potencia", simbolo: "P", unidad: "Vatio" },
  { magnitud: "Frecuencia", simbolo: "f", unidad: "Hercio" }
];

// --- Variantes posibles ---
const variantes = [
  { dado: "magnitud", preguntar: "simbolo", texto: (e) => `La magnitud "${e.magnitud}" se representa con el símbolo…` },
  { dado: "magnitud", preguntar: "unidad", texto: (e) => `La magnitud "${e.magnitud}" se mide en…` },
  { dado: "simbolo", preguntar: "magnitud", texto: (e) => `El símbolo "${e.simbolo}" corresponde a la magnitud…` },
  { dado: "simbolo", preguntar: "unidad", texto: (e) => `El símbolo "${e.simbolo}" corresponde a la unidad…` },
  { dado: "unidad", preguntar: "magnitud", texto: (e) => `La unidad "${e.unidad}" corresponde a la magnitud…` },
  { dado: "unidad", preguntar: "simbolo", texto: (e) => `La unidad "${e.unidad}" se representa con el símbolo…` }
];

// --- Mazo global de preguntas únicas ---
let mazoPreguntas = [];

// Generar el mazo completo de preguntas
function generarMazo() {
  const nuevoMazo = [];
  for (const elemento of magnitudesData) {
    for (const v of variantes) {
      nuevoMazo.push({
        elemento,
        variante: v,
        prompt: v.texto(elemento),
        correcta: elemento[v.preguntar],
        preguntar: v.preguntar
      });
    }
  }
  return shuffle(nuevoMazo); // lo barajamos
}

// --- Plantilla ---
function magnitudes_electricas_cyb() {
  if (mazoPreguntas.length === 0) {
    mazoPreguntas = generarMazo();
  }

  // Sacar la siguiente pregunta del mazo
  const { elemento, variante, prompt, correcta, preguntar } = mazoPreguntas.pop();

  // Distractores: valores del mismo campo en otros elementos
  const incorrectas = magnitudesData
    .filter(e => e !== elemento)
    .map(e => e[preguntar]);

  const distractores = shuffle(incorrectas).slice(0, 3);

  const opciones = shuffle([correcta, ...distractores]);

  return {
    mode: "single",
    prompt: prompt,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["C", "D"],
    repeatable: true
  };
}









function configuracion_electronica(){
  const Z = Math.floor(Math.random() * 50) + 1;
  const elem = ELEMENTOS[Z];
  const pregunta = `¿Cuál es la configuración electrónica del ${elem.nombre} (Z=${Z})?`;
  const correcta = elem.config;

  const distractores = new Set();

  function generarIncorrecta(){
    const modo = rndInt(1,4);
    let propuesta = "";

    if (modo === 1){
      const partes = correcta.split(" ");
      if (partes.length > 1) propuesta = [...partes].reverse().join(" ");
    } else if (modo === 2){
      let offset = Z + (Math.random() < 0.5 ? -9 : 9);
      if (ELEMENTOS[offset]) propuesta = ELEMENTOS[offset].config;
    } else if (modo === 3){
      propuesta = correcta.replace(/s/g,"p").replace(/p/g,"s");
    } else {
      propuesta = correcta.replace(/p6/,"p7").replace(/d10/,"d11");
    }

    return propuesta;
  }

  while (distractores.size < 3){
    const cand = generarIncorrecta();
    if (cand && cand !== correcta && !distractores.has(cand)){
      distractores.add(cand);
    }
  }

  const opciones = shuffle([correcta, ...distractores]);

  return {
    tema: "Teoría de los electrones",
    modelos: ["C","D"],
    repeatable: true,
    mode: "single",
    prompt: pregunta,
    options: opciones,
    correct: [opciones.indexOf(correcta)]
  };
}

function pregunta_teoria_de_los_electrones_1() {
  let correcta = "Protones y neutrones";
  let incorrectas = [
    "Electrones y protones",
    "Electrones y neutrones",
    "Electrones, protones y neutrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué partículas forman el núcleo atómico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_2() {
  let correcta = "Ligeramente menor que la del neutrón";
  let incorrectas = [
    "Exactamente igual a la del neutrón",
    "Mayor que la del neutrón",
    "La mitad de la del neutrón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del protón es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_3() {
  let correcta = "Igual en magnitud y de signo contrario";
  let incorrectas = [
    "Mayor en magnitud y del mismo signo",
    "Menor en magnitud y de signo contrario",
    "Igual en magnitud y del mismo signo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La carga del protón, en comparación con la del electrón, es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_4() {
  let correcta = "Aproximadamente 1/1836 de la masa del protón";
  let incorrectas = [
    "Igual a la masa del protón",
    "El doble de la masa del protón",
    "Aproximadamente 1/100 de la masa del protón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del electrón es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_5() {
  let correcta = "Que el número de protones es igual al número de electrones";
  let incorrectas = [
    "Que el número de protones es igual al número de neutrones",
    "Que el número de electrones es igual al número de neutrones",
    "Que el número de protones, electrones y neutrones es siempre el mismo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué significa que un átomo esté en equilibrio?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_6() {
  let correcta = "El número cuántico azimutal (l)";
  let incorrectas = [
    "El número cuántico principal (n)",
    "El número cuántico magnético (m)",
    "El número cuántico de espín (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué número cuántico determina la forma del orbital atómico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_7() {
  let correcta = "El número cuántico magnético (m)";
  let incorrectas = [
    "El número cuántico principal (n)",
    "El número cuántico azimutal (l)",
    "El número cuántico de espín (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué número cuántico determina la orientación del orbital atómico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_8() {
  let correcta = "El nivel de energía y tamaño del orbital";
  let incorrectas = [
    "La forma del orbital",
    "La orientación espacial del orbital",
    "El espín del electrón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué describe el número cuántico principal (n)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_9() {
  let correcta = "La orientación del giro intrínseco del electrón";
  let incorrectas = [
    "La energía del orbital",
    "La forma del orbital",
    "La orientación espacial del orbital"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué indica el número cuántico de espín (s)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_10() {
  let correcta = "2 electrones";
  let incorrectas = [
    "1 electrón",
    "4 electrones",
    "Hasta 8 electrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cuántos electrones pueden alojarse como máximo en un suborbital?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_11() {
  let correcta = "Catión";
  let incorrectas = [
    "Anión",
    "Molécula",
    "Protón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Cuando un átomo pierde un electrón se forma un...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_12() {
  let correcta = "La compartición de electrones entre átomos";
  let incorrectas = [
    "La transferencia completa de electrones", 
    "La atracción electrostática entre iones", 
    "La presencia de un mar de electrones libres"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué caracteriza al enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_13() {
  let correcta = "Entre no metales";
  let incorrectas = [
    "Entre metales y no metales",
    "Entre metales",
    "Entre gases nobles"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Entre qué tipos de elementos se da un enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_14() {
  let correcta = "La energía necesaria para introducir un electrón en un átomo neutro";
  let incorrectas = [
    "La energía necesaria para arrancar un electrón de un átomo neutro", 
    "La capacidad de un átomo para atraer electrones en un enlace químico", 
    "La energía necesaria para separar protones y neutrones en el núcleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué es la afinidad electrónica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_15() {
  let correcta = "Negativa, tienden a ceder electrones, son reductores y se oxidan";
  let incorrectas = [
    "Positiva, tienden a ganar electrones, son oxidantes y se reducen",
    "Negativa, tienden a ganar electrones, son oxidantes y se reducen",
    "Positiva, tienden a ceder electrones, son reductores y se oxidan"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los metales tienen una afinidad electrónica...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_16() {
  let correcta = "En la transferencia completa de electrones entre un metal y un no metal, formándose iones que se atraen por fuerzas electrostáticas";
  let incorrectas = [
    "En la compartición de electrones entre átomos no metálicos",  
    "En la existencia de un mar de electrones libres entre átomos metálicos", 
    "En la atracción de un núcleo hacia los electrones de otro núcleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿En qué consiste un enlace iónico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_17() {
  let correcta = "Covalente";
  let incorrectas = [
    "Iónico",
    "Metálico",
    "De Van der Waals"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "El hidrógeno molecular (H₂) y el oxígeno molecular (O₂) son moléculas con enlace...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_18() {
  let correcta = "Son sólidos cristalinos, con altos puntos de fusión y conductores en disolución o fundidos";
  let incorrectas = [
    "Son blandos, con bajos puntos de fusión y no conducen la electricidad", 
    "Son maleables, dúctiles y buenos conductores en estado sólido", 
    "Son gaseosos en condiciones normales y no forman redes cristalinas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué características físicas presentan los compuestos iónicos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_19() {
  let correcta = "Cationes metálicos";
  let incorrectas = [
    "Aniones metálicos",
    "Protones libres",
    "Electrones deslocalizados"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cómo se denominan los pseudoiones positivos en el enlace metálico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_20() {
  let correcta = "El equilibrio entre los cationes metálicos y los electrones deslocalizados";
  let incorrectas = [
    "La repulsión entre los electrones deslocalizados", 
    "La atracción entre protones y neutrones",
    "La alternancia de iones positivos y negativos en una red cristalina"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué mantiene la neutralidad electrostática en el enlace metálico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_21() {
  let correcta = "1, 8"; 
  let incorrectas = [
    "2, 6", // ❌ Incorrecta
    "3, 7", // ❌ Incorrecta
    "4, 2"  // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los elementos conductores serán aquellos que tienen ... de valencia. Los aislantes serán los que tienen ... electrones en su capa de valencia.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_22() {
  let correcta = "La plata (Ag)";
  let incorrectas = [
    "El cobre (Cu)",   // ❌ Incorrecta
    "El oro (Au)",     // ❌ Incorrecta
    "El aluminio (Al)" // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué material es el mejor conductor de la electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_23() {
  let correcta = "Un material puro cuya conductividad depende de la temperatura y no de impurezas añadidas";
  let incorrectas = [
    "Un material puro cuya conductividad depende únicamente de impurezas añadidas", // ❌ Extrínseco
    "Un metal con baja resistividad eléctrica",                                    // ❌ Incorrecta
    "Un aislante que nunca puede conducir electricidad"                            // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué es un semiconductor intrínseco?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_24() {
  let correcta = "Tipo P";
  let incorrectas = [
    "Tipo N",   // ❌ Incorrecta
    "Tipo NP",  // ❌ Incorrecta
    "Intrínseco" // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Si se añade galio (Ga) a un cristal de silicio (Si), se formará un semiconductor...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_25() {
  let correcta = "N"; 
  let incorrectas = [
    "P",            // ❌ Aceptoras, grupo III
    "NP",           // ❌
    "Intrínsecas"   // ❌
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Un semiconductor donante está dopado con impurezas de tipo...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_26() {
  let correcta = "1,6 × 10⁻¹⁹ C";
  let incorrectas = [
    "1,6 × 10⁻¹⁶ C",
    "9,1 × 10⁻³¹ C",
    "1,6 × 10⁻²³ C"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cuál es la carga de un protón o un electrón en culombios?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_27() {
  let correcta = "La configuración electrónica";
  let incorrectas = [
    "El número másico",
    "La densidad del núcleo",
    "La masa del neutrón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué determina las propiedades químicas y eléctricas de un elemento?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_28() {
  let correcta = "Los gases nobles";
  let incorrectas = [
    "Los metales alcalinos",
    "Los halógenos",
    "Los lantánidos"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué elementos tienen su capa de valencia completa con 8 electrones?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_29() {
  let correcta = "Buscan completar su capa de valencia para lograr estabilidad";
  let incorrectas = [
    "Buscan aumentar el número de protones",
    "Buscan reducir el tamaño del núcleo",
    "Buscan equilibrar neutrones y protones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Por qué los átomos forman enlaces químicos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_30() {
  let correcta = "Sólidos: bandas de conducción y valencia";
  let incorrectas = [
    "Líquidos: bandas de conducción y valencia",
    "Gases: conducción por bandas",
    "Vacío: conducción por bandas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "En qué estado de la materia la conducción se explica por el modelo de bandas?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_31() {
  let correcta = "Mediante iones disueltos (electrolitos)";
  let incorrectas = [
    "Mediante protones libres",
    "Mediante neutrones excitados",
    "Mediante electrones en bandas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cómo conducen la electricidad los líquidos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_32() {
  let correcta = "Cuando se ionizan y forman plasma";
  let incorrectas = [
    "Cuando se enfrían por debajo de 0 °C",
    "Cuando aumentan su presión",
    "Cuando sus moléculas se solidifican"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿En qué condiciones los gases pueden conducir electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_33() {
  let correcta = "Un aislante ideal";
  let incorrectas = [
    "Un semiconductor natural",
    "Un conductor perfecto",
    "Un plasma estable"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cómo se comporta el vacío respecto a la conducción eléctrica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_34() {
  let correcta = "Vidrio, aire, plásticos, madera";
  let incorrectas = [
    "Cobre, oro, plata",
    "Silicio, germanio",
    "Sodio, cloro, litio"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cuáles de los siguientes materiales son aislantes?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_1() {
  let correcta = "Los aislantes se cargan con facilidad"; 
  let incorrectas = [
    "Los conductores se cargan fácilmente", 
    "Ninguno de ellos se carga con facilidad", 
    "Ambos (aislantes y conductores) se cargan igual de fácil"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué tipo de material se carga más fácilmente con electricidad estática?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_2() {
  let correcta = "Con la balanza de torsión"; 
  let incorrectas = [
    "Con el electróforo", 
    "Con la máquina de Wimshurst", 
    "Con el electroscopio"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Con qué dispositivo determinó Coulomb su ley?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_3() {
  let correcta = "Se repelen si son del mismo signo y se atraen si son de distinto signo"; 
  let incorrectas = [
    "Se atraen si son del mismo signo y se repelen si son de distinto signo", 
    "Siempre se atraen independientemente del signo", 
    "Siempre se repelen independientemente del signo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué ocurre entre dos cargas eléctricas según su signo?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_4() {
  let correcta = "El vacío"; 
  let incorrectas = [
    "El aire", 
    "El agua destilada", 
    "El vidrio"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué medio tiene la permitividad eléctrica más pequeña?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_5() {
  const correcta = "No suelen ser superconductores";
  const incorrectas = [
    "Siempre son superconductores",
    "Son superconductores solo a altas temperaturas",
    "Son superconductores solo en presencia de un campo magnético"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "Los materiales ferromagnéticos ¿suelen ser superconductores?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_electricidad_estatica_6() {
  const correcta = "El statcoulomb (esu de carga)";
  const incorrectas = [
    "El coulomb",
    "El faradio",
    "El weber"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La unidad de carga en el sistema CGS es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_7() {
  const correcta = "La intensidad de campo gravitatorio (g)";
  const incorrectas = [
    "La energía potencial gravitatoria",
    "La aceleración centrípeta",
    "La constante de gravitación universal"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Qué magnitud de un campo gravitatorio es análoga a la intensidad de campo electrostático E?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_electricidad_estatica_8() {
  const correcta = "La conductividad eléctrica";
  const incorrectas = [
    "La resistividad eléctrica",
    "La permitividad eléctrica",
    "La permeabilidad magnética"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La ... es la capacidad de una sustancia a permitir el paso de corriente eléctrica a través suya.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_9() {
  const correcta = "La conductividad eléctrica";
  const incorrectas = [
    "La resistividad eléctrica",
    "La permitividad eléctrica",
    "La permeabilidad magnética"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La ... es la capacidad de una sustancia a permitir el paso de corriente eléctrica a través suya.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_10() {
  const correcta = "De la naturaleza del material y de la temperatura";
  const incorrectas = [
    "Únicamente de la temperatura",
    "Únicamente de la presión",
    "Solo del número de protones del átomo"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿De qué depende la conductividad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_11() {
  const correcta = "La banda prohibida (gap energético)";
  const incorrectas = [
    "La banda activa",
    "La banda de conducción",
    "La banda de valencia"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿La banda ... se encuentra entre las de conducción y valencia?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_12() {
  const correcta = "Del orden de 5 eV o más";
  const incorrectas = [
    "Del orden de 0.1 eV",
    "Del orden de 1 eV",
    "Del orden de 10⁻³ eV"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La energía de gap de un aislante es del orden de ...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_13() {
  const correcta = "Se solapan";
  const incorrectas = [
    "Están separadas por un gran gap",
    "Están separadas por un pequeño gap",
    "Son idénticas pero no se tocan"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "En un metal, ¿cómo se encuentran las bandas de conducción y valencia?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_14() {
  const correcta = "Cae bruscamente a cero";
  const incorrectas = [
    "Aumenta ligeramente",
    "Se mantiene constante",
    "Tiende a infinito"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Qué le sucede a la resistividad de un superconductor cuando alcanza su temperatura crítica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_15() {
  const correcta = "Un plasma";
  const incorrectas = [
    "Un condensado",
    "Un superconductor",
    "Un dieléctrico perfecto"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "Los gases se ionizan formando...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_16() {
  const correcta = "Por radiación, por colisión y por efecto termoiónico";
  const incorrectas = [
    "Por conducción, por inducción y por resonancia",
    "Por fricción, por conducción y por radiación",
    "Por presión, por temperatura y por inducción"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿De qué tres formas se puede ionizar un gas?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_17() {
  const correcta = "Es un estado de agregación parecido al gas, pero formado por partículas sensibles a campos eléctricos y magnéticos";
  const incorrectas = [
    "Es un gas perfecto compuesto únicamente por moléculas neutras",
    "Es un líquido conductor con alta viscosidad",
    "Es un sólido formado por cargas fijas en equilibrio"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Qué es el plasma?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_18() {
  const correcta = "Por la fricción entre el combustible y los conductos";
  const incorrectas = [
    "Por la radiación solar directa",
    "Por la acumulación de hielo en las alas",
    "Por el campo magnético terrestre"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "En una aeronave, ¿cómo suele generarse la electricidad estática que representa un riesgo?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_19() {
  const correcta = "Provocar una chispa que inicie un incendio o explosión";
  const incorrectas = [
    "Reducir la velocidad del avión",
    "Desviar las líneas de campo magnético",
    "Incrementar la presión en cabina"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Cuál es el principal peligro de la electricidad estática durante el repostaje de una aeronave?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_20() {
  const correcta = "Puesta a tierra de la aeronave durante el repostaje";
  const incorrectas = [
    "Rociar agua sobre la aeronave",
    "Reducir la temperatura del combustible",
    "Apagar todos los equipos electrónicos"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Qué medida preventiva se utiliza para evitar descargas electrostáticas peligrosas en aviación?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_21() {
  const correcta = "La presencia de ácidos o sales disueltos que se disocian en iones";
  const incorrectas = [
    "La ausencia de oxígeno en el líquido",
    "La densidad del líquido sin importar su composición",
    "El color del líquido"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿De qué depende la conductividad eléctrica en los líquidos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_22() {
  const correcta = "El efecto termoiónico";
  const incorrectas = [
    "La ionización por presión",
    "El efecto fotoeléctrico en sólidos",
    "El magnetismo inducido"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Qué fenómeno permite que el vacío pueda volverse conductor en ciertas condiciones?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_23() {
  const correcta = "Ácido sulfúrico con agua en baterías de automoción y aviación ligera";
  const incorrectas = [
    "Agua destilada en cualquier batería",
    "Mercurio líquido en aviones comerciales",
    "Alcohol etílico disuelto en agua"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Qué electrolito se utiliza en las baterías de automoción y aviación ligera para conducir electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_24() {
  const correcta = "Agua con hidróxido potásico en aviones comerciales";
  const incorrectas = [
    "Agua con ácido sulfúrico en aviones comerciales",
    "Agua con sal común en cualquier batería",
    "Aceite dieléctrico como medio conductor"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¿Qué electrolito utilizan las baterías de aviones comerciales para su funcionamiento?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}






const K = 9e9; // Constante de Coulomb



function formatSci(value, digits = 2) {
  if (!isFinite(value)) return 'NaN';
  if (value === 0) return '0';
  const sign = value < 0 ? '-' : '';
  let mant = Math.abs(value);
  let exp = Math.floor(Math.log10(mant));
  mant /= Math.pow(10, exp);
  mant = parseFloat(mant.toPrecision(digits));
  if (mant >= 10) {
    mant /= 10;
    exp += 1;
  }
  let mantStr = mant.toString();
  if (mantStr.includes('.')) {
    mantStr = mantStr.replace(/0+$/, '').replace(/\.$/, '');
  }
  return `${sign}${mantStr} × 10^${exp}`;
}

function formatValue(value, digits = 2) {
  if (!isFinite(value)) return 'NaN';
  const abs = Math.abs(value);
  if (abs === 0) return '0';
  if (abs >= 1e3 || abs < 1e-2) {
    return formatSci(value, digits);
  }
  const str = value.toFixed(digits);
  return str.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1').replace(/-0$/, '0');
}

function formatWithUnit(value, unit, digits = 2) {
  const core = formatValue(value, digits);
  return unit ? `${core} ${unit}` : core;
}

function formatCharge(value, digits = 2) {
  if (!isFinite(value)) return 'NaN';
  if (value === 0) return '0 C';
  const abs = Math.abs(value);
  if (abs < 1e-9) {
    const scaled = value / 1e-12;
    return `${formatValue(scaled, digits)} pC`;
  }
  if (abs < 1e-5) {
    const scaled = value / 1e-6;
    return `${formatValue(scaled, digits)} μC`;
  }
  return formatWithUnit(value, 'C', digits);
}

function formatDistance(valueMeters, digits = 2) {
  const mm = valueMeters * 1000;
  return `${formatValue(mm, digits)} mm`;
}

function randomCharge() {
  const sign = Math.random() < 0.5 ? -1 : 1;
  if (Math.random() < 0.15) {
    const magnitudeMicro = (0.2 + Math.random() * 0.6) * 1e-6;
    return sign * magnitudeMicro;
  }
  const magnitudePico = (50 + Math.random() * 950) * 1e-12;
  return sign * magnitudePico;
}

function generarOpciones(correcto, digits = 2) {
  const opciones = [correcto];
  const formatos = new Set([formatValue(correcto, digits)]);
  const maxIntentosAleatorios = 80;
  let intentos = 0;

  while (opciones.length < 4 && intentos < maxIntentosAleatorios) {
    intentos++;
    const factor = 1 + (Math.random() - 0.5) * 0.8;
    const candidato = Number((correcto * factor).toPrecision(digits));
    const representacion = formatValue(candidato, digits);
    if (!formatos.has(representacion)) {
      opciones.push(candidato);
      formatos.add(representacion);
    }
  }

  if (opciones.length < 4) {
    const baseAbs = Math.abs(correcto) || 1;
    let paso = Math.pow(10, Math.floor(Math.log10(baseAbs)) - (digits - 1));
    if (!isFinite(paso) || paso === 0) paso = Math.pow(10, -digits);

    while (opciones.length < 4) {
      const signo = opciones.length % 2 === 0 ? 1 : -1;
      const candidato = correcto + signo * paso;
      const representacion = formatValue(candidato, digits);
      paso *= 1.5;
      if (!formatos.has(representacion)) {
        opciones.push(candidato);
        formatos.add(representacion);
      }
    }
  }

  return shuffle(opciones);
}

// ---------- Fuerza eléctrica ----------
function pregunta_fuerza_electrica_generica() {
  const q1 = randomCharge();
  const q2 = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const F = K * Math.abs(q1 * q2) / (r ** 2);
  const incognita = ['F', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'F') {
    correcto = F;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales de q₁ = ${formatCharge(q1)} y q₂ = ${formatCharge(q2)} están separadas por ${formatDistance(r)}.
¿Cuál es la magnitud de la fuerza eléctrica entre ellas?`;
    formatFn = (val) => formatWithUnit(val, 'N');
  } else if (incognita === 'q') {
    correcto = q1;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales están separadas por ${formatDistance(r)} y ejercen una fuerza eléctrica de F = ${formatSci(F)} N.
Si una de ellas vale q₂ = ${formatCharge(q2)}, ¿cuál es la otra carga?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales de q₁ = ${formatCharge(q1)} y q₂ = ${formatCharge(q2)} ejercen una fuerza de F = ${formatSci(F)} N.
¿Cuál es la distancia que las separa?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// ---------- Campo eléctrico ----------
function pregunta_campo_electrico_generica() {
  const q = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const E = K * Math.abs(q) / (r ** 2);
  const incognita = ['E', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'E') {
    correcto = E;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} genera un campo eléctrico a una distancia de ${formatDistance(r)}.
¿Cuál es la intensidad del campo eléctrico en ese punto?`;
    formatFn = (val) => formatWithUnit(val, 'N/C');
  } else if (incognita === 'q') {
    correcto = q;
    opciones = generarOpciones(correcto);
    prompt = `En un punto situado a ${formatDistance(r)} se mide un campo eléctrico de E = ${formatSci(E)} N/C.
¿Cuál es la carga que lo produce?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} produce un campo eléctrico de E = ${formatSci(E)} N/C en un punto.
¿A qué distancia se encuentra dicho punto de la carga?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// ---------- Potencial eléctrico ----------
function pregunta_potencial_electrico_generica() {
  const q = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const V = K * q / r;
  const incognita = ['V', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'V') {
    correcto = V;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} se encuentra a ${formatDistance(r)} de un punto.
¿Cuál es el potencial eléctrico en ese punto?`;
    formatFn = (val) => formatWithUnit(val, 'V');
  } else if (incognita === 'q') {
    correcto = q;
    opciones = generarOpciones(correcto);
    prompt = `En un punto situado a ${formatDistance(r)} se mide un potencial de V = ${formatSci(V)} V.
¿Cuál es el valor de la carga que lo produce?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} produce un potencial de V = ${formatSci(V)} V en un punto.
¿A qué distancia se encuentra dicho punto de la carga?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// ---------- Energía potencial eléctrica ----------
function pregunta_energia_potencial_generica() {
  const q1 = randomCharge();
  const q2 = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const U = K * q1 * q2 / r;
  const incognita = ['U', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'U') {
    correcto = U;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales de q₁ = ${formatCharge(q1)} y q₂ = ${formatCharge(q2)} están separadas por ${formatDistance(r)}.
¿Cuál es la energía potencial eléctrica del sistema?`;
    formatFn = (val) => formatWithUnit(val, 'J');
  } else if (incognita === 'q') {
    correcto = q1;
    opciones = generarOpciones(correcto);
    prompt = `Un sistema de dos cargas tiene una energía potencial de U = ${formatSci(U)} J, con una de las cargas conocida q₂ = ${formatCharge(q2)} y separación ${formatDistance(r)}.
¿Cuál es el valor de la otra carga?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas de q₁ = ${formatCharge(q1)} y q₂ = ${formatCharge(q2)} tienen una energía potencial de U = ${formatSci(U)} J.
¿Cuál es la distancia que las separa?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// Genera carga aleatoria en picocoulombios (con signo)
function randomChargePicoC() {
  const sign = Math.random() < 0.5 ? -1 : 1;
  const magnitudePico = rndInt(50, 950); // entre 50 y 950 pC
  return sign * magnitudePico * 1e-12;   // convertido a C
}

function formatChargePicoC(value) {
  const pico = value / 1e-12;
  return `${pico.toFixed(0)} pC`;
}

function formatDistanceMm(valueMeters) {
  const mm = valueMeters * 1000;
  return `${formatValue(mm)} mm`;
}

// ---------- Trabajo eléctrico (q·ΔV) ----------
function pregunta_electricidad_estatica_25() {
  const q = randomChargePicoC(); // C
  const deltaV = rndInt(50, 500); // V
  const W = q * deltaV; // J

  const incognita = ["W", "q", "V"][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === "W") {
    correcto = W;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} se desplaza entre dos puntos con ΔV = ${deltaV} V.
¿Cuál es el trabajo realizado por el campo eléctrico?`;
    formatFn = (val) => formatWithUnit(val, "J");
  } else if (incognita === "q") {
    correcto = q;
    opciones = generarOpciones(correcto);
    prompt = `Se realiza un trabajo de W = ${formatSci(W)} J al mover una carga entre dos puntos con ΔV = ${deltaV} V.
¿Cuál es el valor de la carga?`;
    formatFn = formatChargePicoC;
  } else {
    correcto = deltaV;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} requiere un trabajo de W = ${formatSci(W)} J para trasladarse entre dos puntos.
¿Cuál es la diferencia de potencial entre dichos puntos?`;
    formatFn = (val) => formatWithUnit(val, "V");
  }

  return {
    mode: "single",
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ["B","D"],
    repeatable: true
  };
}

// ---------- Trabajo eléctrico (q·E·d) ----------
function pregunta_electricidad_estatica_26() {
  const q = randomChargePicoC();
  const E = rndInt(200, 800); // N/C
  const d = rndInt(10, 50) / 1000; // 10–50 mm en metros
  const W = q * E * d;

  const incognita = ["W", "d", "E"][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === "W") {
    correcto = W;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} se mueve en un campo eléctrico de E = ${E} N/C recorriendo una distancia de ${formatDistanceMm(d)}.
¿Cuál es el trabajo realizado por el campo eléctrico?`;
    formatFn = (val) => formatWithUnit(val, "J");
  } else if (incognita === "d") {
    correcto = d;
    opciones = generarOpciones(correcto);
    prompt = `En un campo eléctrico de E = ${E} N/C se realiza un trabajo de W = ${formatSci(W)} J al mover una carga de q = ${formatChargePicoC(q)}.
¿Cuál fue la distancia recorrida?`;
    formatFn = (val) => formatDistanceMm(val);
  } else {
    correcto = E;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} recorre una distancia de ${formatDistanceMm(d)} y el trabajo realizado es W = ${formatSci(W)} J.
¿Cuál era la intensidad del campo eléctrico?`;
    formatFn = (val) => formatWithUnit(val, "N/C");
  }

  return {
    mode: "single",
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ["B","D"],
    repeatable: true
  };
}

// Estado global para controlar combinaciones ya usadas
let usadas_salud_laboral_1 = [];
let usadas_salud_laboral_2 = [];

// Pregunta Aspecto → Importancia
function pregunta_salud_laboral_1() {
  const pares = [
    ["Seguridad y bienestar de los empleados", [
      "Al identificar y abordar los riesgos antes de que se materialicen, reduce la probabilidad de que ocurran accidentes y enfermedades laborales",
      "Mejora la salud física y mental de los empleados",
      "Aumenta la motivación en la plantilla"
    ]],
    ["Eficiencia operativa", [
      "Evita interrupciones en la producción y fomenta la eficiencia y eficacia de los procesos productivos"
    ]],
    ["Cumplimiento normativo", [
      "Evita sanciones y multas por incumplimiento legal",
      "Demuestra compromiso con la responsabilidad"
    ]],
    ["Reducción de costes", [
      "Disminuye el gasto en atención médica, compensaciones y seguros",
      "Mejora la eficiencia en el uso de recursos al minimizar la pérdida de tiempo y de recursos"
    ]],
    ["Imagen de la empresa", [
      "Contribuye a una imagen positiva de la empresa, tanto interna como externamente"
    ]],
    ["Innovación y desarrollo", [
      "Fomenta prácticas sostenibles tanto medioambientales como sociales",
      "Promueve la innovación en la resolución de problemas al fomentar la búsqueda de soluciones creativas y eficientes"
    ]],
    ["Cohesión y compromiso", [
      "Promueve la participación de todos los miembros de la organización, promoviendo un sentido común de responsabilidad"
    ]]
  ];

  // Crear todas las combinaciones posibles aspecto+importancia
  const todas = pares.flatMap(([aspecto, importancias]) => 
    importancias.map(imp => [aspecto, imp])
  );

  // Filtrar las que no se han usado aún
  const disponibles = todas.filter(pair => 
    !usadas_salud_laboral_1.some(usada => usada[0] === pair[0] && usada[1] === pair[1])
  );

  // Si ya no hay disponibles, reiniciar
  if (disponibles.length === 0) {
    usadas_salud_laboral_1 = [];
    return pregunta_salud_laboral_1();
  }

  // Elegir una combinación aleatoria de las disponibles
  const [aspecto, importancia] = disponibles[Math.floor(Math.random() * disponibles.length)];
  usadas_salud_laboral_1.push([aspecto, importancia]);

  const correcta = importancia;
  let incorrectas = todas.map(t => t[1]).filter(i => i !== importancia);
  incorrectas = shuffle(incorrectas).slice(0, 3);

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: `¿Cuál es la importancia de la cultura preventiva en el aspecto "${aspecto}"?`,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: true
  };
}

// Pregunta Importancia → Aspecto
function pregunta_salud_laboral_2() {
  const pares = [
    ["Seguridad y bienestar de los empleados", [
      "Al identificar y abordar los riesgos antes de que se materialicen, reduce la probabilidad de que ocurran accidentes y enfermedades laborales",
      "Mejora la salud física y mental de los empleados",
      "Aumenta la motivación en la plantilla"
    ]],
    ["Eficiencia operativa", [
      "Evita interrupciones en la producción y fomenta la eficiencia y eficacia de los procesos productivos"
    ]],
    ["Cumplimiento normativo", [
      "Evita sanciones y multas por incumplimiento legal",
      "Demuestra compromiso con la responsabilidad"
    ]],
    ["Reducción de costes", [
      "Disminuye el gasto en atención médica, compensaciones y seguros",
      "Mejora la eficiencia en el uso de recursos al minimizar la pérdida de tiempo y de recursos"
    ]],
    ["Imagen de la empresa", [
      "Contribuye a una imagen positiva de la empresa, tanto interna como externamente"
    ]],
    ["Innovación y desarrollo", [
      "Fomenta prácticas sostenibles tanto medioambientales como sociales",
      "Promueve la innovación en la resolución de problemas al fomentar la búsqueda de soluciones creativas y eficientes"
    ]],
    ["Cohesión y compromiso", [
      "Promueve la participación de todos los miembros de la organización, promoviendo un sentido común de responsabilidad"
    ]]
  ];

  // Crear todas las combinaciones posible importancia+aspecto
  const todas = pares.flatMap(([aspecto, importancias]) => 
    importancias.map(imp => [aspecto, imp])
  );

  // Filtrar las que no se han usado aún
  const disponibles = todas.filter(pair => 
    !usadas_salud_laboral_2.some(usada => usada[0] === pair[0] && usada[1] === pair[1])
  );

  // Si ya no hay disponibles, reiniciar
  if (disponibles.length === 0) {
    usadas_salud_laboral_2 = [];
    return pregunta_salud_laboral_2();
  }

  // Elegir una combinación aleatoria de las disponibles
  const [aspecto, importancia] = disponibles[Math.floor(Math.random() * disponibles.length)];
  usadas_salud_laboral_2.push([aspecto, importancia]);

  const correcta = aspecto;
  let incorrectas = pares.map(p => p[0]).filter(a => a !== aspecto);
  incorrectas = shuffle(incorrectas).slice(0, 3);

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: `¿A qué aspecto corresponde la siguiente importancia de la cultura preventiva: "${importancia}"?`,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: true
  };
}



function pregunta_salud_laboral_3() {
  const grupos = {
    "Condiciones de seguridad": {
      factores: ["Lugares de trabajo", "Equipos de trabajo"],
      danos: ["Accidente laboral"]
    },
    "Condiciones medioambientales": {
      factores: ["Agentes físicos", "Agentes químicos", "Agentes biológicos"],
      danos: ["Enfermedad profesional"]
    },
    "Condiciones ergonómicas": {
      factores: ["Carga física", "Carga mental"],
      danos: ["Fatiga física", "Fatiga mental"]
    },
    "Condiciones psicosociales": {
      factores: ["Organización del trabajo", "Características personales"],
      danos: ["Insatisfacción laboral", "Estrés", "Mobbing", "Síndrome de burnout"]
    }
  };

  // Convertimos en pares posibles [condición, factor, daño]
  const todas = Object.entries(grupos).flatMap(([cond, data]) =>
    data.factores.flatMap(f => 
      data.danos.map(d => [cond, f, d])
    )
  );

  // Elegimos una combinación
  const [condicion, factor, dano] = todas[Math.floor(Math.random() * todas.length)];

  // Posibles modos de pregunta
  const modos = ["cond->factor", "factor->cond", "factor->dano", "dano->factor", "cond->dano", "dano->cond"];
  const modo = modos[Math.floor(Math.random() * modos.length)];

  let prompt, correcta, incorrectas;

  switch (modo) {
    case "cond->factor":
      prompt = `¿Cuál es un factor de riesgo laboral asociado a "${condicion}"?`;
      correcta = factor;
      incorrectas = todas.map(t => t[1]).filter(f => f !== factor);
      break;

    case "factor->cond":
      prompt = `¿A qué condición laboral pertenece el factor de riesgo "${factor}"?`;
      correcta = condicion;
      incorrectas = Object.keys(grupos).filter(c => c !== condicion);
      break;

    case "factor->dano":
      prompt = `¿Qué daño laboral puede derivarse del factor de riesgo "${factor}"?`;
      correcta = dano;
      incorrectas = todas.map(t => t[2]).filter(d => d !== dano);
      break;

    case "dano->factor":
      prompt = `¿Qué factor de riesgo laboral puede producir el daño "${dano}"?`;
      correcta = factor;
      incorrectas = todas.map(t => t[1]).filter(f => f !== factor);
      break;

    case "cond->dano":
      prompt = `¿Qué daño laboral puede producirse por las "${condicion}"?`;
      correcta = dano;
      incorrectas = todas.map(t => t[2]).filter(d => d !== dano);
      break;

    case "dano->cond":
      prompt = `¿A qué condición laboral está asociado el daño "${dano}"?`;
      correcta = condicion;
      incorrectas = Object.keys(grupos).filter(c => c !== condicion);
      break;
  }

  // Reducimos distractores a 3
  incorrectas = shuffle(incorrectas).slice(0, 3);
  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: prompt,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: true
  };
}

const bancoDefiniciones = [
  {
    termino: "Cultura preventiva",
    genero: "f",
    tema: "salud_laboral_cyb",
    definicion: "Conjunto de valores, actitudes y prácticas orientadas a evitar riesgos laborales."
  }
];

function pregunta_definiciones_por_tema(tema) {
  // Filtrar el banco por el tema
  const banco = bancoDefiniciones.filter(item => item.tema === tema);

  // Elegir un término aleatorio del tema
  const elegido = banco[Math.floor(Math.random() * banco.length)];

  // Filtrar posibles distractores del mismo tema y género/número
  let posibles = banco.filter(item => item.genero === elegido.genero && item.termino !== elegido.termino);

  // Si no hay suficientes distractores, usar cualquiera del tema
  if (posibles.length < 3) {
    posibles = banco.filter(item => item.termino !== elegido.termino);
  }

  // Seleccionar hasta 3 incorrectas
  const incorrectas = shuffle(posibles.map(item => item.definicion)).slice(0, 3);

  // Correcta
  const correcta = elegido.definicion;
  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: `¿Qué es "${elegido.termino}"?`,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: true
  };
}



function pregunta_cronograma_verdad() {
  const entradas = Math.random() < 0.5 ? 1 : 2;
  const salidas  = Math.random() < 0.5 ? 1 : 2;
  const pasos = 6;
  const stepX = 40;
  const startX = 20;
  const endX = startX + pasos * stepX;
  const labelX = endX + 10;
  const yStep = 40;
  const yBase0 = 30;
  const amp = 15;
  const numSignals = entradas + salidas;
  const svgWidth  = endX + 120;
  const svgHeight = 20 + (numSignals - 1) * yStep + 50;

  // Funciones lógicas disponibles
  const unary = { ID: a => a, NOT: a => a ^ 1 };
  const binary = {
    AND: (a,b) => a & b,
    OR:  (a,b) => a | b,
    XOR: (a,b) => a ^ b,
    NAND:(a,b) => (a & b) ^ 1,
    NOR: (a,b) => (a | b) ^ 1,
    XNOR:(a,b) => (a ^ b) ^ 1
  };
  const funcSet = (entradas === 1) ? unary : binary;
  const funcKeys = Object.keys(funcSet);

  // Elegir funciones de salida
  const f1Name = funcKeys[Math.floor(Math.random() * funcKeys.length)];
  const f1 = funcSet[f1Name];
  let f2Name = null, f2 = null;
  if (salidas === 2) {
    const alt = funcKeys.filter(k => k !== f1Name);
    f2Name = (alt.length ? alt[Math.floor(Math.random() * alt.length)] : f1Name);
    f2 = funcSet[f2Name];
  }

  // Tabla de verdad correcta
  const truthRows = [];
  if (entradas === 1) {
    for (let a = 0; a <= 1; a++) {
      if (salidas === 1) truthRows.push([a, f1(a)]);
      else truthRows.push([a, f1(a), f2(a)]);
    }
  } else {
    for (let a = 0; a <= 1; a++) {
      for (let b = 0; b <= 1; b++) {
        if (salidas === 1) truthRows.push([a, b, f1(a,b)]);
        else truthRows.push([a, b, f1(a,b), f2(a,b)]);
      }
    }
  }

  // Convertir tabla a HTML
  function tablaHTML(rows, inCount, outCount, headNames) {
    const heads = headNames || (
      inCount === 1
        ? (outCount === 1 ? ["Entrada", "Salida"] : ["Entrada", "Salida 1", "Salida 2"])
        : (outCount === 1 ? ["A", "B", "Salida"] : ["A", "B", "Salida 1", "Salida 2"])
    );
    return `<table border="1" style="border-collapse:collapse;text-align:center;min-width:220px">
      <tr>${heads.map(h=>`<th>${h}</th>`).join('')}</tr>
      ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('')}
    </table>`;
  }
  const correcta = tablaHTML(truthRows, entradas, salidas);

  // Generar distractores
  function buildRowsFrom(fAname, fBname) {
    const fA = funcSet[fAname];
    const fB = fBname ? funcSet[fBname] : null;
    const rows = [];
    if (entradas === 1) {
      for (let a = 0; a <= 1; a++) {
        rows.push(salidas === 1 ? [a, fA(a)] : [a, fA(a), fB(a)]);
      }
    } else {
      for (let a = 0; a <= 1; a++) {
        for (let b = 0; b <= 1; b++) {
          rows.push(salidas === 1 ? [a, b, fA(a,b)] : [a, b, fA(a,b), fB(a,b)]);
        }
      }
    }
    return rows;
  }

  const distractores = [];
  const usedPairs = new Set();
  const keyPair = (a,b) => `${a}|${b||'-'}`;
  usedPairs.add(keyPair(f1Name, f2Name));

  if (salidas === 1) {
    const pool = funcKeys.filter(k => k !== f1Name);
    while (distractores.length < 3 && pool.length) {
      const pick = pool.splice(Math.floor(Math.random()*pool.length),1)[0];
      if (!usedPairs.has(keyPair(pick, null))) {
        usedPairs.add(keyPair(pick, null));
        distractores.push(tablaHTML(buildRowsFrom(pick, null), entradas, salidas));
      }
    }
  } else {
    const pairs = [];
    for (let i = 0; i < funcKeys.length; i++) {
      for (let j = 0; j < funcKeys.length; j++) {
        const p = keyPair(funcKeys[i], funcKeys[j]);
        if (!usedPairs.has(p)) pairs.push([funcKeys[i], funcKeys[j]]);
      }
    }
    // barajar y tomar 3
    for (let k = pairs.length - 1; k > 0; k--) {
      const r = Math.floor(Math.random() * (k + 1));
      [pairs[k], pairs[r]] = [pairs[r], pairs[k]];
    }
    for (let i = 0; i < Math.min(3, pairs.length); i++) {
      distractores.push(
        tablaHTML(buildRowsFrom(pairs[i][0], pairs[i][1]), entradas, salidas)
      );
    }
  }
  while (distractores.length < 3) {
    distractores.push(tablaHTML(truthRows, entradas, salidas, ["X","Y","Z","W"].slice(0, entradas + salidas)));
  }

  const opciones = shuffle([correcta, ...distractores]);

  // --- Generar señales garantizando TODAS las combinaciones ---
  let combos = [];
  if (entradas === 1) {
    combos = [[0],[1]];
  } else {
    combos = [[0,0],[0,1],[1,0],[1,1]];
  }
  // barajar combos
  for (let i = combos.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i+1));
    [combos[i], combos[j]] = [combos[j], combos[i]];
  }
  // repetir hasta cubrir pasos
  while (combos.length < pasos) {
    combos = combos.concat(combos);
  }
  combos = combos.slice(0,pasos);
  const e1 = combos.map(c => c[0]);
  const e2 = entradas === 2 ? combos.map(c => c[1]) : null;
  const s1 = e1.map((a,i)=> entradas===1 ? f1(a) : f1(a, e2[i]));
  const s2 = salidas===2 ? e1.map((a,i)=> entradas===1 ? f2(a) : f2(a, e2[i])) : null;

  function generarSenal(bits, yBase, amplitud) {
    let puntos = `${startX},${yBase} `;
    let x = startX, nivel = yBase;
    for (let i = 0; i < bits.length; i++) {
      const y = bits[i] ? yBase - amplitud : yBase;
      puntos += `${x},${nivel} ${x},${y} `;
      x += stepX;
      puntos += `${x},${y} `;
      nivel = y;
    }
    return puntos;
  }

  // SVG cronograma
  let svg = `<svg width="${svgWidth}" height="${svgHeight}" style="border:1px solid #ccc;background:#f9f9f9;">`;
  for (let i = 0; i <= pasos; i++) {
    const x = startX + i * stepX;
    svg += `<line x1="${x}" y1="10" x2="${x}" y2="${svgHeight-10}" stroke="#aaa" stroke-dasharray="3,3"/>`;
  }

  let y = yBase0;
  svg += `<polyline points="${generarSenal(e1, y, amp)}" fill="none" stroke="green" stroke-width="2"/>`;
  svg += `<text x="${labelX}" y="${y+5}" font-size="12">Entrada 1</text>`;
  if (entradas === 2) {
    y += yStep;
    svg += `<polyline points="${generarSenal(e2, y, amp)}" fill="none" stroke="blue" stroke-width="2"/>`;
    svg += `<text x="${labelX}" y="${y+5}" font-size="12">Entrada 2</text>`;
  }
  y += yStep;
  svg += `<polyline points="${generarSenal(s1, y, amp)}" fill="none" stroke="orange" stroke-width="2"/>`;
  svg += `<text x="${labelX}" y="${y+5}" font-size="12">${salidas === 1 ? "Salida" : "Salida 1"}</text>`;
  if (salidas === 2) {
    y += yStep;
    svg += `<polyline points="${generarSenal(s2, y, amp)}" fill="none" stroke="red" stroke-width="2"/>`;
    svg += `<text x="${labelX}" y="${y+5}" font-size="12">Salida 2</text>`;
  }
  svg += `</svg>`;

  return {
    mode: "single",
    prompt: `Observa el cronograma:<br>${svg}<br><br>¿Cuál es la tabla de verdad que describe este comportamiento?`,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: true
  };
}








</script>
</script>
</body>
</html>










