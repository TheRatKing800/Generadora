<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Atenea — prototipo</title>
  <style>
    :root { --pad:16px; --radius:16px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#0f172a; color:#e5e7eb;}
    header { padding:24px var(--pad); background:#111827; border-bottom:1px solid #1f2937;}
    h1 { margin:0 0 6px; font-size:24px; font-weight:500;}
    .sub { color:#9ca3af; font-size:18px;}
    main { max-width:900px; margin: 0 auto; padding: 24px var(--pad) 80px;}
    .card { background:#111827; border:1px solid #1f2937; border-radius:var(--radius); padding: 18px; box-shadow:0 10px 25px rgba(0,0,0,.25);}
    .row { display:grid; gap:12px; }
    @media (min-width: 720px){ .row-3 { grid-template-columns: repeat(3, 1fr);} .row-2 { grid-template-columns: repeat(2, 1fr);} }
    label { font-size:18px; color:#cbd5e1; }
    select, input[type="number"], button, .pill {
      width:100%; background:#0b1220; color:#e5e7eb; border:1px solid #1f2937;
      padding:10px 12px; border-radius:12px; outline:none;
    }
    button { cursor:pointer; font-weight:400; }
    button.primary { background:#2563eb; border-color:#2563eb; }
    button.ghost { background:#0b1220; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .prompt { font-size:24px; line-height:1.5; margin: 8px 0 14px; color:#f3f4f6;}
    .opts { display:grid; gap:10px; }
    .opt { font-size:22px;  text-align:left; padding:12px; border-radius:12px; border:1px solid #1f2937; background:#0b1220; cursor:pointer; }
    .opt.correct { border-color:#16a34a; background:#0b1f14; }
    .opt.wrong   { border-color:#dc2626; background:#1a0b0b; }
    .muted { color:#9ca3af; font-size:15px; }
    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#0b1220; border:1px solid #1f2937; color:#cbd5e1; font-size:14px; }
    .spacer { height:8px; }
    .footer { position:fixed; left:0; right:0; bottom:0; padding:10px var(--pad); background:#0b1220; border-top:1px solid #1f2937; display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .score { font-weight:500; }
    .explain { margin-top:10px; color:#d1d5db; font-size:18px; }
    .hide { display:none; }
    .selected {
      border-color:#2563eb;
      background:#1e3a8a;
    }
  </style>
</head>
<body>

<main>
  <section id="panel-config" class="card">
    

  
  <!-- 🔹 PASO 1: CURSO ACADÉMICO -->
  <div class="row row-2">
    <div>
      <label for="curso">Curso académico</label>
      <select id="curso">
        <option value="">-- Selecciona curso --</option>
        <option value="Promocion_XXXIV_STP">Promoción XXXIV STP</option>
        <option value="Promocion_XXXV_STP">Promoción XXXV STP</option>
        <option value="Promocion_XXXVI_STP">Promoción XXXVI STP</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
<!-- 🔹 NUEVO BLOQUE DE SELECCIÓN EN CASCADA -->
  <div class="row row-3" id="fila-eat">
  <div id="bloque-esp" class="hide">
    <label for="especialidad">Especialidad</label>
    <select id="especialidad">
      <option value="">-- Selecciona especialidad --</option>
      <option value="GENERAL">GENERAL</option>
      <option value="CAE">CAE</option>
      <option value="CYB">CYB</option>
      <option value="MER">MER</option>
      <option value="ELC">ELC</option>
      <option value="AYF">AYF</option>
      <option value="PAO">PAO</option>
    </select>
  </div>
  <div id="bloque-asig" class="hide">
    <label for="asignatura">Asignatura</label>
    <select id="asignatura" disabled>
      <option value="">-- Selecciona asignatura --</option>
    </select>
  </div>
  <div id="bloque-tema" class="hide">
    <label for="tema">Tema</label>
    <select id="tema" disabled>
      <option value="">-- Selecciona tema --</option>
    </select>
  </div>
</div>

  <div class="spacer"></div>
  <!-- 🔹 FIN DEL BLOQUE NUEVO -->
    <div class="row row-1 hide">
  <div>
    <label for="modo">Modo de juego</label>
    <select id="modo">
  <option value="">-- Selecciona modo de juego --</option>
  <option value="estandar">Estándar (30 preguntas, revisión final)</option>
  <option value="contrarreloj">Contrarreloj (vidas + tiempo)</option>
  <option value="vidas">Por vidas (explicaciones + vidas)</option>
</select>

  </div>
</div>

  <div class="spacer"></div>
  <!-- 🔹 PASO FINAL: MODELO -->
  <div class="spacer"></div>
  <div class="row row-1 hide">
    <div>
      <label for="modelo">Modelo</label>
      <select id="modelo">
        <option value="">-- Selecciona --</option>
        <option value="A">Modelo A — Daypo</option>
        <option value="B">Modelo B — Libro</option>
        <option value="C">Modelo C — Diario de la gente</option>
        <option value="D">Modelo D — Todo</option>
        <option value="E">Modelo E — Selección por grupos</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
  <div id="opcionesModelo" class="card hide"></div>
  <div class="spacer"></div>

  <div class="row row-2">
    <button id="start" class="primary" disabled>Empezar</button>
  </div>

  </section> <!-- 🔸 CIERRE correcto de #panel-config -->

<section id="panel-test" class="card hide">
  <div class="muted" id="meta"></div>
  <div class="prompt" id="prompt"></div>
  <div id="options" class="opts"></div>
  <div id="explain" class="explain hide"></div>
</section>

<section id="panel-result" class="card hide">
  <h3>Resumen</h3>
  <p class="muted" id="summary"></p>
  <div class="spacer"></div>
  <div class="row row-2">
    <button id="retry" class="primary">Repetir con mismos ajustes</button>
    <button id="home" class="ghost">Volver al inicio</button>
  </div>
</section>

</main>

<footer class="footer">
  <div style="display:flex; gap:12px; align-items:center;">
    <span class="badge" id="modeBadge">—</span>
    <span id="lives" class="muted"></span>
    <span id="timer" class="muted"></span>
  </div>
  <div class="score" id="score">0 / 0</div>
  <div style="display:flex; gap:8px;">
    <button id="check" class="ghost">Comprobar</button>
    <button id="next" class="primary" disabled>Siguiente</button>
  </div>
</footer>


<script>
/* ==========================================================
   SUPERTEST — MOTOR BÁSICO LIMPIO
========================================================== */

const rndInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

const REGISTRY = { types: {} };

/* ========== TIPO: CONSTITUCIÓN (ejemplo) ========== */
// constitucion.js - TODAS LAS PLANTILLAS TRADUCIDAS DESDE Constitucion_prime.py

(function registerAritmetica() {

  function suma_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a + b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} + ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function multiplicacion_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    const correct = parseFloat((a * b).toFixed(2)); // hasta 2 decimales

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        let valor = correct + delta;
        // Mantener formato si el correcto tiene decimales
        if (String(correct).includes(".")) {
          valor = parseFloat(valor.toFixed(2));
        }
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} × ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function resta_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a - b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} - ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function division_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    if (b === 0) b = 1; // salvaguarda (no debería ocurrir con los rangos)

    const correct = parseFloat((a / b).toFixed(2));

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 3); // ± hasta 3
        } else {
          delta = (Math.random() < 0.5 ? -1 : 1) * 5; // saltos grandes
        }
        let valor = correct + delta;
        valor = parseFloat(valor.toFixed(2));
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritmética",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¿Cuánto es ${a} ÷ ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  REGISTRY.types["matematicas_aritmetica"] = {
    name: "Aritmética",
    templates: [suma_basica, resta_basica, multiplicacion_basica, division_basica]
  };

})();






REGISTRY.types['teoria_electrones'] = { name: 'Teoría de los electrones', templates: [configuracion_electronica,pregunta_teoria_de_los_electrones_1,pregunta_teoria_de_los_electrones_2,pregunta_teoria_de_los_electrones_3,pregunta_teoria_de_los_electrones_4,pregunta_teoria_de_los_electrones_5,pregunta_teoria_de_los_electrones_6,pregunta_teoria_de_los_electrones_7,pregunta_teoria_de_los_electrones_8,pregunta_teoria_de_los_electrones_9,pregunta_teoria_de_los_electrones_10,pregunta_teoria_de_los_electrones_11,pregunta_teoria_de_los_electrones_12,pregunta_teoria_de_los_electrones_13,pregunta_teoria_de_los_electrones_14,pregunta_teoria_de_los_electrones_15,pregunta_teoria_de_los_electrones_16,pregunta_teoria_de_los_electrones_17,pregunta_teoria_de_los_electrones_18,pregunta_teoria_de_los_electrones_19,pregunta_teoria_de_los_electrones_20,pregunta_teoria_de_los_electrones_21,pregunta_teoria_de_los_electrones_22,pregunta_teoria_de_los_electrones_23,pregunta_teoria_de_los_electrones_24,pregunta_teoria_de_los_electrones_25]};
REGISTRY.types['electricidad_estatica'] = { name: 'Electricidad estática y conducción', templates: [(typeof pregunta_electricidad_estatica_1 !== 'undefined' ? pregunta_electricidad_estatica_1 : null),(typeof pregunta_electricidad_estatica_2 !== 'undefined' ? pregunta_electricidad_estatica_2 : null),(typeof pregunta_electricidad_estatica_3 !== 'undefined' ? pregunta_electricidad_estatica_3 : null),(typeof pregunta_electricidad_estatica_4 !== 'undefined' ? pregunta_electricidad_estatica_4 : null),(typeof pregunta_electricidad_estatica_5 !== 'undefined' ? pregunta_electricidad_estatica_5 : null),(typeof pregunta_electricidad_estatica_6 !== 'undefined' ? pregunta_electricidad_estatica_6 : null),(typeof pregunta_electricidad_estatica_7 !== 'undefined' ? pregunta_electricidad_estatica_7 : null),(typeof pregunta_electricidad_estatica_8 !== 'undefined' ? pregunta_electricidad_estatica_8 : null),(typeof pregunta_electricidad_estatica_9 !== 'undefined' ? pregunta_electricidad_estatica_9 : null),(typeof pregunta_electricidad_estatica_10 !== 'undefined' ? pregunta_electricidad_estatica_10 : null),(typeof pregunta_electricidad_estatica_11 !== 'undefined' ? pregunta_electricidad_estatica_11 : null),(typeof pregunta_electricidad_estatica_12 !== 'undefined' ? pregunta_electricidad_estatica_12 : null),(typeof pregunta_electricidad_estatica_13 !== 'undefined' ? pregunta_electricidad_estatica_13 : null),(typeof pregunta_electricidad_estatica_14 !== 'undefined' ? pregunta_electricidad_estatica_14 : null),(typeof pregunta_electricidad_estatica_15 !== 'undefined' ? pregunta_electricidad_estatica_15 : null),(typeof pregunta_electricidad_estatica_16 !== 'undefined' ? pregunta_electricidad_estatica_16 : null),(typeof pregunta_electricidad_estatica_17 !== 'undefined' ? pregunta_electricidad_estatica_17 : null),(typeof pregunta_electricidad_estatica_18 !== 'undefined' ? pregunta_electricidad_estatica_18 : null),(typeof pregunta_electricidad_estatica_19 !== 'undefined' ? pregunta_electricidad_estatica_19 : null),(typeof pregunta_electricidad_estatica_20 !== 'undefined' ? pregunta_electricidad_estatica_20 : null),(typeof pregunta_electricidad_estatica_21 !== 'undefined' ? pregunta_electricidad_estatica_21 : null),(typeof pregunta_electricidad_estatica_22 !== 'undefined' ? pregunta_electricidad_estatica_22 : null),(typeof pregunta_electricidad_estatica_23 !== 'undefined' ? pregunta_electricidad_estatica_23 : null),(typeof pregunta_electricidad_estatica_24 !== 'undefined' ? pregunta_electricidad_estatica_24 : null),(typeof pregunta_electricidad_estatica_25 !== 'undefined' ? pregunta_electricidad_estatica_25 : null),(typeof generarPreguntaCoulomb !== 'undefined' ? generarPreguntaCoulomb : null)].filter(Boolean)};

(function registerEOFAS(){
  function eofas_1(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la Dirección General de Política de Defensa le corresponde:",
    options: [
      "Elaborar las lineas generales de las directrices generales de política de defensa para la participación de otros Departamentos Ministeriales en la Defensa nacional",
      "Ejercer la notaría militar",
      "Establecer la aplicación de los planes de calidad de vida del personal militar.",
      "Gestionar la ordenación farmacéutica"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_2(){
  const base = [
    "El CIFAS está integrado en el EMACOM",
    "El MOPS está integrado en el Cuartel General del EMAD",
    "El EMACON es el órgano auxiliar de mando del JEMAD",
    "__META__" // se convertirá en "A y C son correctas."
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar índices de las opciones que la meta debe referenciar
  const idxCIFAS = barajadas.indexOf("El CIFAS está integrado en el EMACOM");
  const idxEMACON = barajadas.indexOf("El EMACON es el órgano auxiliar de mando del JEMAD");

  // Reescribir la opción meta con las letras reales
  barajadas[idxMeta] = `${letra(idxCIFAS)}) y ${letra(idxEMACON)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta correcta",
    options: barajadas,
    correct: [2] // ⚠️ cámbialo según cuál/es la correcta
  };
}



function eofas_3(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Como órgano de asesoramiento y asistencia inmediata, el Ministro de Defensa cuenta con:",
    options: [
      "La Dirección General de Política de Defensa",
      "La Oficina de Comunicación de la Defensa",
      "El Consejo Superior de los Ejércitos.",
      "Un Gabinete Técnico"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_4(){
  const base = [
    "Dirigir el Plan de Diplomacia de Defensa",
    "Elaborar y proponer disposiciones en materia de retribuciones militares",
    "__META__", // se convertirá en "a) y b) son correctas."
    "El asesoramiento sobre los aspectos relacionados con el estudio, planeamiento y desarrollo de las actividades de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los índices de las dos opciones que la meta debe referenciar
  const idxDiplomacia = barajadas.indexOf("Dirigir el Plan de Diplomacia de Defensa");
  const idxRetribuciones = barajadas.indexOf("Elaborar y proponer disposiciones en materia de retribuciones militares");

  // Reescribir la opción meta con las letras reales
  barajadas[idxMeta] = `${letra(idxDiplomacia)}) y ${letra(idxRetribuciones)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la Secretaría General de Política de Defensa le corresponde:",
    options: barajadas,
    correct: [0] // ⚠️ cámbialo según cuál/es la correcta
  };
}



function eofas_5(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de dirigir la elaboración de los tratados internacionales que afecten a la Defensa es:",
    options: [
      "La SEDEF",
      "La DIGENPER",
      "La SUBDEF.",
      "La Secretaría General de Política de Defensa"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_6(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: [
      "Garantizar la seguridad criptográfica",
      "La función de asesoramiento militar al Presidente del Gobierno",
      "Coordinar el Plan General de la Defensa Nacional.",
      "Asesorar al Secretario de Estado de Defensa en el desarrollo de la política económica de sus ejércitos"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_7(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano auxiliar de mando del JEMAD que apoya y asesora en la definición de la estrategia militares:",
    options: [
      "El EMACON",
      "La SUBDEF",
      "La SEDEF.",
      "El EMACOM"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_8(){
  const base = [
    "Dirigir la política de armamento, en relación con organismos internacionales",
    "Asegurar la eficacia operativa de las Fuerzas Armadas",
    "__META__", // se convertirá en "a) y c) son correctas."
    "Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar las dos opciones que debe referenciar la meta
  const idxArmamento = barajadas.indexOf("Dirigir la política de armamento, en relación con organismos internacionales");
  const idxEjercer = barajadas.indexOf("Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas");

  // Reescribir el texto meta con las letras reales
  barajadas[idxMeta] = `${letra(idxArmamento)}) y ${letra(idxEjercer)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: barajadas,
    correct: [1] // ⚠️ cambia este índice según cuál/es sean correctas
  };
}



function eofas_9(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de realizar las expropiaciones de bienes y derechos así como los arrendamientos pertinentes es:",
    options: [
      "La DIGENIN",
      "La DGAM",
      "La DIGENPER.",
      "La DIGENECO"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_10(){
  const base = [
    "Es un mando conjunto de la estructura operativa constituido de forma permanente",
    "Tiene como misión la intervención en cualquier lugar del territorio nacional exclusivamente",
    "__META__", // se convertirá en "b) y c) son correctas."
    "El JEMAD dictará las normas que regulen su organización"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los índices de las dos opciones que la meta debe señalar
  const idxMision = barajadas.indexOf("Tiene como misión la intervención en cualquier lugar del territorio nacional exclusivamente");
  const idxJEMAD = barajadas.indexOf("El JEMAD dictará las normas que regulen su organización");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMision)}) y ${letra(idxJEMAD)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "La UME:",
    options: barajadas,
    correct: [0] // ⚠️ cámbialo según cuál/es sean las correctas
  };
}



function eofas_11(){
  const base = [
    "Desarrollar la política medioambiental del Departamento",
    "Administrar los recursos financieros destinados a las operaciones de paz",
    "__META__", // se convertirá en "a) y c) son correctas."
    "Dirigir la gestión de los bienes afectos al Ministerio de Defensa"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los índices de las dos opciones que debe señalar la meta
  const idxMedioambiente = barajadas.indexOf("Desarrollar la política medioambiental del Departamento");
  const idxBienes = barajadas.indexOf("Dirigir la gestión de los bienes afectos al Ministerio de Defensa");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMedioambiente)}) y ${letra(idxBienes)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENECO le corresponde:",
    options: barajadas,
    correct: [1] // ⚠️ cámbialo según cuál/es sean correctas
  };
}



function eofas_12(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de llevar el inventario de los bienes del Ministerio de Defensa es:",
    options: [
      "La Secretaría de Estado de Defensa",
      "La Dirección General de Infraestructura",
      "La Subdirección General de Régimen Interior.",
      "La Dirección General de Patrimonio e Inventario"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_13(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de gestionar los sistemas informáticos integrales de dirección y administración económica del Departamento es:",
    options: [
      "La Subdirección General de Servicios Económicos y Pagadurías",
      "La SEGENTE",
      "DIGENECO.",
      "DIGENIN"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_14(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de la dirección de las tecnologías y seguridad de la información en el ámbito de la defensa es:",
    options: [
      "El Presidente del Gobierno",
      "La Junta de Defensa Nacional",
      "La SEDEF.",
      "El JEMAD"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_15(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de proponer la política industrial de la defensa es:",
    options: [
      "La SUBDEF",
      "La DIGENECO",
      "La DGAM",
      "La DGAN"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_16(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de la gestión de los servicios generales del órgano central es:",
    options: [
      "La Secretaría General Técnica",
      "La Subdirección General de Régimen Interior",
      "La Subdirección General de Seguridad y Servicios.",
      "La Subdirección General de Servicios"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_17(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de elaborar estudios e informes sobre cuántos asuntos sean sometidos a la deliberación del Consejo de Ministros es:",
    options: [
      "La SEGENTE",
      "La Dirección General de Sanidad",
      "La Asesoría Jurídica General.",
      "La DIGENPER"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_18(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado del registro general en el órgano central en el Ministerio de Defensa es:",
    options: [
      "La Subdirección General de Régimen Interior",
      "La SEGENTE",
      "La Subdirección General de Registro y Archivos.",
      "La SUBDEF"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_19(){
  const base = [
    "Elaborar el BOD",
    "Coordinar la política de igualdad",
    "__META__", // se convertirá en "a) y c) son correctas."
    "Proponer y elaborar normas sobre reformas de métodos de trabajo"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar índices de las opciones que la meta debe referenciar
  const idxBOD = barajadas.indexOf("Elaborar el BOD");
  const idxNormas = barajadas.indexOf("Proponer y elaborar normas sobre reformas de métodos de trabajo");

  // Reescribir la opción meta con las letras reales
  barajadas[idxMeta] = `${letra(idxBOD)}) y ${letra(idxNormas)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENPER le corresponde:",
    options: barajadas,
    correct: [1] // ⚠️ cámbialo según cuál/es la correcta
  };
}


function eofas_20(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la SEGENTE le corresponde:",
    options: [
      "Gestionar el personal militar de los Cuerpos Comunes",
      "Coordinar la política social para el personal militar",
      "Atender al gobierno de los órganos centrales del Ministerio.",
      "Coordinar, gestionar e inspeccionar las Delegaciones de Defensa"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_21(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta incorrecta:",
    options: [
      "El Ejército de Tierra está constituido por el Cuartel General, la Fuerza y el Apoyo a la Fuerza",
      "A la DIGENPER le corresponde elaborar el régimen general de los centros docentes militares, del alumnado y del profesorado",
      "A la DIGENPER le corresponde reconocer los derechos pasivos y conceder las prestaciones de clases pasivas del personal militar.",
      "A la DIGENPER le corresponde planificar los efectivos y el reclutamiento del personal militar"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_22(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de gestionar la formación para el personal civil es:",
    options: [
      "La DIGENPER",
      "La DIGEREM",
      "La Subdirección General de Régimen Interior.",
      "La SEGENTE"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_23(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El órgano encargado de elaborar los planes de salidas profesionales del personal de las FAS es:",
    options: [
      "La DIGENPER",
      "La Dirección General de Política de Defensa",
      "La DIGEREN.",
      "La DIGEREM"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_24(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Inspector General de Sanidad será desempeñado por:",
    options: [
      "Un General de Brigada del Cuerpo Militar de Sanidad",
      "Un Oficial General de los Cuerpos Comunes",
      "Un General de División del Cuerpo Militar de Sanidad, en situación de servicio activo.",
      "Un General de División de cualquiera de los Ejércitos"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_25(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ejército de Tierra, la Armada y el Ejército del Aire están constituidos por:",
    options: [
      "El Cuartel General, la Logística y el Apoyo a la Fuerza",
      "La Fuerza, el Apoyo a la Fuerza y el Cuartel General",
      "El Apoyo a la Fuerza, el Cuartel General y las Fuerzas Operativas.",
      "La Fuerza, la Logística y el Mando Supremo"
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_26(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Consejo Superior del Ejército del Aire es el órgano colegiado asesor y consultivo de:",
    options: [
      "El Presidente del Gobierno",
      "El Subsecretario de Defensa",
      "La Junta de Defensa Nacional.",
      "El Ministro de Defensa"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_27(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Secretario del CSEA será ejercido por:",
    options: [
      "El Vocal Accidental que se designe",
      "No existe el cargo de Secretario en el Consejo",
      "El Oficial General titular de la Secretaría Permanente del CSEA.",
      "El Vocal de mayor antigüedad"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_28(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al General Jefe del MACOM en el Consejo le corresponderá ser:",
    options: [
      "Vocal Accidental",
      "Vocal asesor",
      "Depende del tipo de reunión a realizar.",
      "Vocal Nato"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_29(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Consejo Superior del Ejército del Aire le corresponde:",
    options: [
      "Emitir informe sobre aquellos asuntos que someta a su consideración el JEMA",
      "Ser oído por el Ministro de Defensa en relación con su propuesta de designación del Jefe de Estado Mayor del Aire",
      "Todas las anteriores son correctas.",
      "Asesorar al Ministro de Defensa en materias relativas a la estructuración del E.A"
    ],
    correct: [2] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_30(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Las reuniones del Consejo Superior del Ejército del Aire serán convocadas por:",
    options: [
      "El Ministro de Defensa",
      "El Presidente del Gobierno",
      "El Director de Política de Defensa.",
      "El Jefe de Estado Mayor de la Defensa"
    ],
    correct: [0] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_31(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Es función del CSEA:",
    options: [
      "Informar las evaluaciones para el ascenso al empleo de Teniente de los Militares de Complemento",
      "Ser oído por el Ministro de Defensa en relación con su propuesta de designación del JEMAD",
      "Todas las anteriores son ciertas.",
      "Emitir informe en aquellos asuntos que someta a su consideración expresa el JEMA"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_32(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "¿A que órgano le corresponde impartir los Altos Estudios de la Defensa Nacional?",
    options: [
      "Centro Superior de Altos Estudios de la Defensa(CESADEF)",
      "Centro Superior de Estudios de la Defensa Institucional(CESEDIN)",
      "Centro Superior de Estudios de la Defensa Nacional(CEDEDEN)",
      "Centro Universitario de la Defensa (CUD)."
    ],
    correct: [1] // ⚠️ Marcar luego la correcta manualmente
  };
}


function eofas_33(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El organismo público dependiente directamente del titular del Departamento, y responsable de facilitar las informaciones, análisis, estudios o propuestas que permitan prevenir y evitar cualquier peligro, amenaza o agresión contra la independencia o integridad territorial de España, los intereses nacionales y la estabilidad del Estado de derecho y sus instituciones es:",
    options: [
      "Dirección Institucional de Contrainteligencia de la Defensa",
      "Asesoría de Información y Riesgos del Ministerio de Defensa",
      "Subdirección de Análisis e Información de la Defensa.",
      "Centro Nacional de Inteligencia"
    ],
    correct: [3] // ⚠️ Marcar luego la correcta manualmente
  };
}

REGISTRY.types["eofas"] = {
    name: "EOFAS",
    templates: [
eofas_1,
eofas_2,
eofas_3,
eofas_4,
eofas_5,
eofas_6,
eofas_7,
eofas_8,
eofas_9,
eofas_10,
eofas_11,
eofas_12,
eofas_13,
eofas_14,
eofas_15,
eofas_16,
eofas_17,
eofas_18,
eofas_19,
eofas_20,
eofas_21,
eofas_22,
eofas_23,
eofas_24,
eofas_25,
eofas_26,
eofas_27,
eofas_28,
eofas_29,
eofas_30,
eofas_31,
eofas_32,
eofas_33

    ]
  };
})();

(function registerConstitucion(){

  function t_constitucion(){
    const anios = [1808,1837,1845,1869,1876];
    const personas = ["Napoleón","María Cristina de Borbón","Isabel II","General Francisco Serrano","Alfonso XII"];
    const idx = Math.floor(Math.random()*anios.length);
    const anio = anios[idx], persona = personas[idx];
    const distractores = personas.filter(p=>p!==persona).sort(()=>Math.random()-0.5).slice(0,3);
    const options = [persona,...distractores].sort(()=>Math.random()-0.5);
    return { modelos:["A","B","C","D","E"], mode:"single", prompt:`La Constitución de ${anio} fue entregada por:`, options, correct:[options.indexOf(persona)] };
  }

  

  REGISTRY.types["constitucion"] = {
    name: "Constitución",
    templates: [
      t_constitucion
    ]
  };
})();


/* ---------- Estado ---------- */
let state = {
  typeKey: null,
  templateName: "__random__",
  mode: "estandar",   // nuevo
  total: 30,          // por defecto
  asked: 0,
  correct: 0,
  lives: 3,           // para contrarreloj/vidas
  timeLeft: 40,       // tiempo actual por pregunta
  level: 1,
  current: null,
  selection: new Set(),
  curso: null,
  modelo: null,
  modeloConfig: {}
};


/* ---------- Referencias UI ---------- */
const elStart = document.getElementById('start');
const panelConfig = document.getElementById('panel-config');
const panelTest = document.getElementById('panel-test');
const panelResult = document.getElementById('panel-result');
const elPrompt = document.getElementById('prompt');
const elOptions = document.getElementById('options');
const elExplain = document.getElementById('explain');
const elMeta = document.getElementById('meta');
const elScore = document.getElementById('score');
const elNext = document.getElementById('next');
const elCheck = document.getElementById('check');
const elModeBadge = document.getElementById('modeBadge');
const elSummary = document.getElementById('summary');
const elRetry = document.getElementById('retry');
const elHome = document.getElementById('home');
const selEsp = document.getElementById("especialidad");
const selAsig = document.getElementById("asignatura");
const selTema = document.getElementById("tema");

const selCurso = document.getElementById("curso");
const selModelo = document.getElementById("modelo");
const divOpcModelo = document.getElementById("opcionesModelo");

// Compatibilidad: ejecutar cuando el DOM esté listo (sin syntaxes modernas)
function onReady(cb){
  if (document.readyState !== 'loading') cb();
  else document.addEventListener('DOMContentLoaded', cb);
}

// Buscar el contenedor .row de un elemento sin usar ?.closest
function getRow(el){
  var p = el;
  while (p && p !== document.body){
    if (p && p.classList && p.classList.contains('row')) return p;
    p = p.parentNode;
  }
  return null;
}

// Mostrar/ocultar nodos usando una clase CSS (más robusto que style.display)
function show(node, on){
  if (!node) return;
  if (on) node.classList.remove('hide');
  else node.classList.add('hide');
}


/* ---------- Lógica ---------- */
function makeQuestion(){
  const def = REGISTRY.types[state.typeKey];
  let fn;
  if (state.templateName === "__random__"){
    fn = def.templates[rndInt(0, def.templates.length-1)];
  } else {
    fn = def.templates[parseInt(state.templateName,10)];
  }
  return fn();
}

function renderQuestion(){
  if (!state.typeKey || !REGISTRY.types[state.typeKey]){
    elPrompt.textContent = "❌ Error: no hay ejercicios cargados para este tema.";
    return;
  }

  // Usar directamente el pool ya preparado en startTest()
if (!state.pool || state.pool.length === 0){
  if (state.repeatables && state.repeatables.length > 0){
    state.pool = state.repeatables.slice();
  } else {
    showResult();
    return;
  }
}



// Elegir al azar una plantilla del pool
const idx = rndInt(0, state.pool.length - 1);
const f = state.pool[idx];
const q = f();

// Si no es repetible → se elimina del pool
if (!q.repeatable) {
  state.pool.splice(idx, 1);
} else {
  // 🔹 Si es repetible, no la quitamos: permanece en el pool
  //    (esto permite que pueda volver a salir)
}

// Guardar la pregunta actual
state.current = q;
  console.log('[render] Pregunta:', state.current.prompt);
  console.log('[render] Opciones:', (state.current.options||[]));











  state.selection = new Set();

  const {mode, prompt, options} = state.current;

  elModeBadge.textContent = (mode === "multi" ? "MODO: Múltiple" : "MODO: Única");
  elPrompt.textContent = prompt || "—";
  elExplain.classList.add('hide'); 
  elExplain.textContent = "";

  // Pintar opciones
  elOptions.innerHTML = "";
  options.forEach((text, idx)=>{
    const btn = document.createElement('button');
    btn.className = 'opt';
    btn.type = "button";
    btn.dataset.index = String(idx);
    btn.innerHTML = `<strong>${String.fromCharCode(97+idx)})</strong> ${text}`;
    btn.addEventListener('click', ()=>toggleSelect(idx, btn));
    elOptions.appendChild(btn);
  });


  // Equivalencias en recuadro bajo las respuestas
  (function(){
    var box = document.getElementById('equivalenciasBox');
    if (box) { box.parentNode && box.parentNode.removeChild(box); box = null; }
    if (Array.isArray(state.current.equivalencias) && state.current.equivalencias.length){
      box = document.createElement('div');
      box.id = 'equivalenciasBox';
      box.className = 'card';
      box.style.marginTop = '12px';
      box.style.fontSize = '18px';
      box.style.lineHeight = '1.5';
      var html = '<strong>Equivalencias</strong>' + '<div style="margin-top:6px">'
        + (state.current.equivalencias||[]).map(function(e){return '<div>&bull; '+e+'</div>';}).join('') + '</div>';
      box.innerHTML = html;
      elOptions.insertAdjacentElement('afterend', box);
    }
  })();  // Modo contrarreloj
  if (state.mode === "contrarreloj"){
    clearInterval(state.timerId);
    state.timeLeft = Math.max(20, 40 - (state.level-1)*5);
    updateHUD();
    state.timerId = setInterval(()=>{
      state.timeLeft--;
      updateHUD();
      if (state.timeLeft <= 0){
        state.lives--;
        clearInterval(state.timerId);
        if (state.lives <= 0){ 
          showResult(); 
          return; 
        } else if (state.timerId){
          clearInterval(state.timerId);
          state.timerId = null;
        }
        nextQuestion();
      }
    }, 1000);
  }

  // Meta
  elMeta.textContent = state.total ? `Pregunta ${state.asked+1} de ${state.total}` : `Pregunta ${state.asked+1}`;
  elNext.disabled = true;
  updateScore();
  updateHUD();
}




function toggleSelect(idx, elBtn){
  const mode = state.current.mode;
  if (mode === "single"){
    state.selection.clear();
    Array.from(elOptions.children).forEach(ch=>{
      ch.classList.remove('selected');
    });
    state.selection.add(idx);
    elBtn.classList.add('selected');
  } else {
    if (state.selection.has(idx)){
      state.selection.delete(idx);
      elBtn.classList.remove('selected');
    } else {
      state.selection.add(idx);
      elBtn.classList.add('selected');
    }
  }
}

function checkAnswer(){
if (state.selection.size===0) return;

  // detener el temporizador mientras se corrige la pregunta
  if (state.mode === "contrarreloj" && state.timerId){
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const correctSet = new Set(state.current.correct);
  const isCorrect = (
    state.selection.size === correctSet.size &&
    Array.from(state.selection).every(i => correctSet.has(i))
  );

  console.log('[check] Selección:', Array.from(state.selection));
  console.log('[check] Correctas:', Array.from(correctSet));
  console.log('[check] ¿Correcto?:', isCorrect);

  // Pintado de feedback
  Array.from(elOptions.children).forEach((btn, i)=>{
    if (correctSet.has(i)) btn.classList.add('correct');
    else if (state.selection.has(i)) btn.classList.add('wrong');
    btn.disabled = true;
  });

  if (isCorrect){
    state.correct++;
    if (state.correct % 5 === 0){ state.level++; }
  } else {
    if (state.mode === "contrarreloj" || state.mode === "vidas"){
      state.lives = Math.max(0, state.lives - 1);
      updateHUD();
      if (state.lives <= 0){ showResult(); return; }
    }
  }

  // Explicación (si la hay)
  if (state.current.explanation){
    elExplain.classList.remove('hide');
    elExplain.classList.add('card');
    var extra = document.createElement('div');
    extra.style.marginTop = '8px';
    extra.textContent = state.current.explanation;
    elExplain.appendChild(extra);
  }

  elNext.disabled = false;
  updateScore();
}


function nextQuestion(){
  state.asked++;
  if (state.total && state.asked >= state.total){
    showResult();
  } else {
      renderQuestion();
}
}


function updateScore(){
  elScore.textContent = `${state.correct} / ${state.asked} acertadas`;
}

function startTest(){
  if (state.timerId) {
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const esp = selEsp.value;
  const asig = selAsig.value;
  const tema = selTema.value;
  const modoSel = document.getElementById("modo").value;

  state.curso = selCurso.value;
  if (!state.curso){ 
    alert("Selecciona el curso académico."); 
    return; 
  }

  state.modelo = selModelo.value;
  if (!state.modelo){ 
    alert("Selecciona el modelo (A–E)."); 
    return; 
  }

  state.mode = modoSel;
  state.asked = 0;
  state.correct = 0;
  state.lives = 3;
  state.level = 1;
  state.timeLeft = 40;
  state.selection = new Set();
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);

  // Inicializar arrays vacíos para evitar errores
  state.pool = [];
  state.repeatables = [];

  // 🔹 Definimos un mapeo de combinaciones a typeKey
  const MAPEO_TEMAS = {
    "GENERAL|Constitución|Test Constitución": "constitucion",
    "GENERAL|EOFAS|EOFAS": "eofas",
    "CYB|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "CAE|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "PAO|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "PAO|Sistemas de telefonía fija y móvil|Introducción": "introduccion_telefonia",
    "CYB|Sistemas de telefonía fija y móvil|Introducción": "introduccion_telefonia",
    "CAE|Sistemas de telefonía fija y móvil|Introducción": "introduccion_telefonia",
    "MER|Matemáticas|Aritmética": "matematicas_aritmetica",
    "ELC|Matemáticas|Aritmética": "matematicas_aritmetica",
    "MER|Fundamentos de electricidad|Teoría de los electrones": "teoria_electrones",
    "ELC|Fundamentos de electricidad|Teoría de los electrones": "teoria_electrones"
  };

  // Construimos la clave con lo que seleccionó el usuario
  const key = `${esp}|${asig}|${tema}`;
  state.typeKey = MAPEO_TEMAS[key];

  // Si no está implementado → mostrar aviso, pero mantener el wizard abierto
  if (!state.typeKey || !REGISTRY.types[state.typeKey]) {
    alert(`⚠️ Tema aún no implementado: ${esp} → ${asig} → ${tema}`);
    return;  // 👈 ya no oculta ni reinicia, solo no arranca el test
  }

  // 🔹 Construir pool filtrado
  const def = REGISTRY.types[state.typeKey];
  const templates = Array.isArray(def.templates) ? def.templates : [];

  // Construir el pool inicial de plantillas válidas según el modelo
  state.pool = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo);
    } catch(e){ 
      return false; 
    }
  });

  // Guardar aparte las repetibles para reponerlas cuando se vacíe el pool
  state.repeatables = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo) && q.repeatable === true;
    } catch(e){ 
      return false; 
    }
  });

  // Si no hay preguntas en el pool → avisar y volver al wizard
  if (state.pool.length === 0){
    alert(`⚠️ El tema ${def.name} no tiene preguntas para el modelo ${state.modelo}.`);
    panelTest.classList.add('hide');
    panelConfig.classList.remove('hide');
    return;
  }

  // Ajustar número total de preguntas según modo
  if (state.mode === "estandar") {
    // 🔹 Comprobar si el tema tiene plantillas repetibles
    const hasRepeatables = templates.some(f => {
      try {
        const q = f();
        return q.repeatable === true;
      } catch(e) {
        return false;
      }
    });

    if (hasRepeatables) {
      state.total = 30;   // ✅ fija 30 preguntas aunque se repitan
    } else {
      state.total = state.pool.length;  // ✅ solo las disponibles (no repetibles)
    }
  } else {
    state.total = null;  // en otros modos (vidas, contrarreloj) no hay límite fijo
  }

  // Mostrar panel del test
  panelConfig.classList.add('hide');
  panelResult.classList.add('hide');
  panelTest.classList.remove('hide');

  updateHUD();
  renderQuestion();
}




// En el script
function updateHUD(){
  if (state.mode!=="estandar"){
    document.getElementById("lives").textContent = "❤".repeat(state.lives);
  } else {
    document.getElementById("lives").textContent = "";
  }
  if (state.mode==="contrarreloj"){
    document.getElementById("timer").textContent = state.timeLeft+"s";
  } else {
    document.getElementById("timer").textContent = "";
  }
}


function showResult(){
  panelTest.classList.add('hide');
  panelResult.classList.remove('hide');

  if (state.total){
    elSummary.textContent = `Has acertado ${state.correct} de ${state.total} (${Math.round(100*state.correct/state.total)}%).`;
  } else {
    elSummary.textContent = `Has acertado ${state.correct} preguntas.`;
  }
}


/* ---------- Eventos ---------- */
elStart.addEventListener('click', startTest);
elCheck.addEventListener('click', checkAnswer);
elNext.addEventListener('click', nextQuestion);
elRetry.addEventListener('click', startTest);
elHome.addEventListener('click', ()=>{
  if (state.timerId) { clearInterval(state.timerId); state.timerId = null; }
  panelResult.classList.add('hide');
  panelConfig.classList.remove('hide');
});



/* ---------- Atajos ---------- */
window.addEventListener('keydown', (e)=>{
  if (panelTest.classList.contains('hide')) return;
  const key = e.key.toLowerCase();
  const map = { a:0, b:1, c:2, d:3 };
  if (key in map){
    const idx = map[key];
    const btn = elOptions.children[idx];
    if (btn && !btn.disabled) btn.click();
  } else if (key === 'enter'){
    if (!elNext.disabled) nextQuestion(); else checkAnswer();
  } else if (key === 'n'){
    if (!elNext.disabled) nextQuestion();
  }
});


/* ---------- Datos de especialidades ---------- */
const ESPECIALIDADES_BY_CURSO = {
  "Promocion_XXXIV_STP": {},
  "Promocion_XXXV_STP": {},
  "Promocion_XXXVI_STP": {
    "GENERAL": {
      "Constitución": ["Test Constitución"],
      "EOFAS": ["EOFAS"],
    },
    "CAE": {
      "Técnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonía fija y móvil":["Introducción","Introducción a la telefonía","Evolución de la estructura de la red telefónica","La señal telefónica","Telefonía digital","Multiplexación de canales MIC","Tecnologías de banda ancha. RDSI y ATM","Estructura de la red y tráfico telefónico", "Conmutación telefónica","Sistemas digitales de conmutación","Sistema privado de conmutación PBX"],
      "Auditoría Redes WIFI":["Introducción","Herramientas de auditoría de redes LAN inalámbricas","Criptografía","Medidas de seguridad básicas","Herramientas de captura y analisis de tráfico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    },
    "CYB": {
      "Técnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonía fija y móvil":["Introducción","Introducción a la telefonía","Evolución de la estructura de la red telefónica","La señal telefónica","Telefonía digital","Multiplexación de canales MIC","Tecnologías de banda ancha. RDSI y ATM","Estructura de la red y tráfico telefónico", "Conmutación telefónica","Sistemas digitales de conmutación","Sistema privado de conmutación PBX"],
      "Auditoría Redes WIFI":["Introducción","Herramientas de auditoría de redes LAN inalámbricas","Criptografía","Medidas de seguridad básicas","Herramientas de captura y analisis de tráfico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    },
    "MER": {
      "Matemáticas":["Aritmética","Álgebra","Geometría"],
      "Física":["La materia","Mecánica","Termodinámica","Óptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["Teoría de los electrones", "Electricidad estática y conducción", "Terminología eléctrica","Generación de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "Teoría del motor/Generador DC","Teoría de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electrónica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["Capítulo 0","Forma del fuselaje","Esfuerzos y deformación","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que actúan en el avión","Velocidades de influencia estructural","Sección D","Cargas estructurales en el helicóptero","Certificación de las estructuras aeronáuticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromecámico":["Generalidades","Rendimiento y limitaciones humanas","Psicología social", "Factores que afectan al rendimiento","Entorno físico","Tareas","Comunación","Error humano","Riesgos Laborales"]
    },
    "ELC": {
      "Matemáticas":["Aritmética","Álgebra","Geometría"],
      "Física":["La materia","Mecánica","Termodinámica","Óptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["Teoría de los electrones", "Electricidad estática y conducción", "Terminología eléctrica","Generación de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "Teoría del motor/Generador DC","Teoría de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electrónica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["Capítulo 0","Forma del fuselaje","Esfuerzos y deformación","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que actúan en el avión","Velocidades de influencia estructural","Sección D","Cargas estructurales en el helicóptero","Certificación de las estructuras aeronáuticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromecámico":["Generalidades","Rendimiento y limitaciones humanas","Psicología social", "Factores que afectan al rendimiento","Entorno físico","Tareas","Comunación","Error humano","Riesgos Laborales"]
    },
    "AYF": {},
    "PAO": {
      "Técnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonía fija y móvil":["Introducción","Introducción a la telefonía","Evolución de la estructura de la red telefónica","La señal telefónica","Telefonía digital","Multiplexación de canales MIC","Tecnologías de banda ancha. RDSI y ATM","Estructura de la red y tráfico telefónico", "Conmutación telefónica","Sistemas digitales de conmutación","Sistema privado de conmutación PBX"],
      "Auditoría Redes WIFI":["Introducción","Herramientas de auditoría de redes LAN inalámbricas","Criptografía","Medidas de seguridad básicas","Herramientas de captura y analisis de tráfico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    }
  }
};

/* ---------- Flujo paso a paso (wizard) y opciones de modelo ---------- */
function updateStartEnabled(){
  const okCurso = !!selCurso.value;
  const okEsp   = !!selEsp.value;
  const okAsig  = !!selAsig.value;
  const okTema  = !!selTema.value;

  const modoSel = document.getElementById("modo").value;
  let okModo = !!modoSel;

  const modelo  = selModelo.value;
  let okModelo  = !!modelo;

  // Validaciones específicas de C/E
  if (modelo === "C"){
    var tipoCEl = document.getElementById("tipoC");
    const tipoC = (tipoCEl && tipoCEl.value) ? tipoCEl.value : "";
    okModelo = okModelo && !!tipoC;
  } else if (modelo === "E"){
    const grupos = Array.from(document.querySelectorAll('input[name="grupoE"]:checked'));
    const tipos  = Array.from(document.querySelectorAll('input[name="tipoE"]:checked'));
    const requiereTipos = (
      selAsig.value.toLowerCase().includes("matem") ||
      selTema.value.toLowerCase().includes("aritm")
    );
    okModelo = okModelo && grupos.length > 0 && (requiereTipos ? tipos.length > 0 : true);
  }

  // El botón siempre está visible, solo se activa/desactiva
  const ready = okCurso && okEsp && okAsig && okTema && okModo && okModelo;
  elStart.disabled = !ready;
}


function renderModelOptions(){
  const modelo = selModelo.value;
  divOpcModelo.innerHTML = "";
  divOpcModelo.classList.add("hide");

  if (!modelo){ updateStartEnabled(); return; }

  if (modelo === "C"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label for="tipoC">Modelo C — ¿qué quieres?</label>
          <select id="tipoC">
            <option value="">-- Selecciona --</option>
            <option value="teoria">Teoría</option>
            <option value="practica">Práctica</option>
            <option value="ambas">Ambas</option>
          </select>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    document.getElementById("tipoC").addEventListener("change", updateStartEnabled);
  } else if (modelo === "E"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label>Grupos (puedes marcar varios)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="A"> Grupo A (Daypo)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="B"> Grupo B (Libro)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="C"> Grupo C (Diario)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="D"> Grupo D (Todo)</label>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="row row-2">
        <div>
          <label>Tipos de ejercicio (si aplica)</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="suma_basica"> Sumas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="resta_basica"> Restas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="multiplicacion_basica"> Multiplicaciones</label>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    Array.from(divOpcModelo.querySelectorAll('input[name="grupoE"], input[name="tipoE"]')).forEach(ch => {
      ch.addEventListener("change", updateStartEnabled);
    });
  }
  updateStartEnabled();

  }


function setupWizard(){
  // Referencias a bloques (no usar getRow con E/A/T porque comparten la misma fila)
  var rowEsp    = document.getElementById("bloque-esp");
  var rowAsig   = document.getElementById("bloque-asig");
  var rowTema   = document.getElementById("bloque-tema");
  var rowModo   = getRow(document.getElementById("modo"));
  var rowModelo = getRow(selModelo);
  var rowStart  = getRow(elStart);
  var filaEAT  = document.getElementById("fila-eat");

  // Estado inicial — solo visible "Curso"
  show(rowEsp,    false);
  show(rowAsig,   false);
  show(rowTema,   false);
  show(rowModo,   false);
  show(rowModelo, false);
  // ❌ no ocultamos rowStart, el botón siempre se ve

  selAsig.disabled = true;
  selTema.disabled = true;
  divOpcModelo.classList.add('hide');
  divOpcModelo.innerHTML = "";

  // PASO 1 → Curso
  function handleCursoChange(){
  try {
    selEsp.value = "";
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";
    const hasCurso = !!selCurso.value;
    selEsp.disabled = !hasCurso;
    if (filaEAT) show(filaEAT, hasCurso);
    show(rowEsp, hasCurso);
    show(rowAsig, false);
    show(rowTema, false);
    show(rowModo, false);
    show(rowModelo, false);
    updateStartEnabled();
    console.log('[wizard] curso change:', selCurso.value);
  } catch(e){ console.error('[wizard] handleCursoChange error', e); }
}
selCurso.addEventListener('change', handleCursoChange);
selCurso.addEventListener('input', handleCursoChange);


    if (selCurso && selCurso.value) { handleCursoChange(); }

// PASO 2 → Especialidad
  selEsp.addEventListener("change", function(){
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    if (!cursoSel){
      alert("⚠️ Selecciona primero el curso académico.");
      selEsp.value = "";
      return;
    }
    var esp = selEsp.value;
    var data = ESPECIALIDADES_BY_CURSO[cursoSel] && ESPECIALIDADES_BY_CURSO[cursoSel][esp];

    if (data){
      Object.keys(data).forEach(function(a){
        var opt = document.createElement("option");
        opt.value = a; opt.textContent = a;
        selAsig.appendChild(opt);
      });
      selAsig.disabled = Object.keys(data).length === 0;
    } else {
      selAsig.innerHTML = '<option value="">— Sin datos para esta especialidad —</option>';
      selAsig.disabled = true;
    }

    show(rowAsig,   true);
    show(rowTema,   false);
    show(rowModo,   false);
    show(rowModelo, false);

    updateStartEnabled();
  });

  // PASO 3 → Asignatura
  selAsig.addEventListener("change", function(){
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    var esp = selEsp.value;
    var asig = selAsig.value;
    var temas = ESPECIALIDADES_BY_CURSO[cursoSel] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp][asig];

    if (Array.isArray(temas)){
      temas.forEach(function(t){
        var opt = document.createElement("option");
        opt.value = t; opt.textContent = t;
        selTema.appendChild(opt);
      });
      selTema.disabled = temas.length === 0;
    }

    show(rowTema,   true);
    show(rowModo,   false);
    show(rowModelo, false);

    // Reset de modo/modelo
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 4 → Tema
  selTema.addEventListener("change", function(){
    show(rowModo,   !!selTema.value);
    show(rowModelo, false);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 5 → Modo
  document.getElementById("modo").addEventListener("change", function(){
    show(rowModelo, !!this.value);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 6 → Modelo
  selModelo.addEventListener("change", function(){
    renderModelOptions();
    updateStartEnabled();
  });

  // Recalcular si cambia el modo (vidas/tiempo)
  var modoSel = document.getElementById("modo");
  if (modoSel) modoSel.addEventListener("change", updateStartEnabled);

  updateStartEnabled();
}






// Ejecutar setup inmediatamente (el script está al final del body)





onReady(function(){
  setupWizard();
});


const ELEMENTOS = {
  1: { nombre: "Hidrógeno", config: "1s¹" },
  2: { nombre: "Helio", config: "1s²" },
  3: { nombre: "Litio", config: "1s² 2s¹" },
  4: { nombre: "Berilio", config: "1s² 2s²" },
  5: { nombre: "Boro", config: "1s² 2s² 2p¹" },
  6: { nombre: "Carbono", config: "1s² 2s² 2p²" },
  7: { nombre: "Nitrógeno", config: "1s² 2s² 2p³" },
  8: { nombre: "Oxígeno", config: "1s² 2s² 2p⁴" },
  9: { nombre: "Flúor", config: "1s² 2s² 2p⁵" },
  10: { nombre: "Neón", config: "1s² 2s² 2p⁶" },
  11: { nombre: "Sodio", config: "1s² 2s² 2p⁶ 3s¹" },
  12: { nombre: "Magnesio", config: "1s² 2s² 2p⁶ 3s²" },
  13: { nombre: "Aluminio", config: "1s² 2s² 2p⁶ 3s² 3p¹" },
  14: { nombre: "Silicio", config: "1s² 2s² 2p⁶ 3s² 3p²" },
  15: { nombre: "Fósforo", config: "1s² 2s² 2p⁶ 3s² 3p³" },
  16: { nombre: "Azufre", config: "1s² 2s² 2p⁶ 3s² 3p⁴" },
  17: { nombre: "Cloro", config: "1s² 2s² 2p⁶ 3s² 3p⁵" },
  18: { nombre: "Argón", config: "1s² 2s² 2p⁶ 3s² 3p⁶" },
  19: { nombre: "Potasio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 4s¹" },
  20: { nombre: "Calcio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 4s²" },
  21: { nombre: "Escandio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹ 4s²" },
  22: { nombre: "Titanio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d² 4s²" },
  23: { nombre: "Vanadio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d³ 4s²" },
  24: { nombre: "Cromo", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁵ 4s¹" },
  25: { nombre: "Manganeso", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁵ 4s²" },
  26: { nombre: "Hierro", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁶ 4s²" },
  27: { nombre: "Cobalto", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁷ 4s²" },
  28: { nombre: "Níquel", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d⁸ 4s²" },
  29: { nombre: "Cobre", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s¹" },
  30: { nombre: "Zinc", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s²" },
  31: { nombre: "Galio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p¹" },
  32: { nombre: "Germanio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p²" },
  33: { nombre: "Arsénico", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p³" },
  34: { nombre: "Selenio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁴" },
  35: { nombre: "Bromo", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁵" },
  36: { nombre: "Kriptón", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶" },
  37: { nombre: "Rubidio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 5s¹" },
  38: { nombre: "Estroncio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 5s²" },
  39: { nombre: "Itrio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹ 5s²" },
  40: { nombre: "Circonio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d² 5s²" },
  41: { nombre: "Niobio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁴ 5s¹" },
  42: { nombre: "Molibdeno", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁵ 5s¹" },
  43: { nombre: "Tecnecio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁵ 5s²" },
  44: { nombre: "Rutenio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁷ 5s¹" },
  45: { nombre: "Rodio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d⁸ 5s¹" },
  46: { nombre: "Paladio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰" },
  47: { nombre: "Plata", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s¹" },
  48: { nombre: "Cadmio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s²" },
  49: { nombre: "Indio", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s² 5p¹" },
  50: { nombre: "Estaño", config: "1s² 2s² 2p⁶ 3s² 3p⁶ 3d¹⁰ 4s² 4p⁶ 4d¹⁰ 5s² 5p²" },

  
};


const EQUIVALENCIAS = {
  distancia: {
    km: { m: {num: 1000, den: 1} },
    m: {
      km: {num: 1, den: 1000},
      cm: {num: 100, den: 1},
      mm: {num: 1000, den: 1},
      in: {num: 39.37, den: 1},
      ft: {num: 3.281, den: 1},
      yd: {num: 1.094, den: 1},
      mi: {num: 1/1609, den: 1}
    },
    cm: { m: {num: 1, den: 100}, mm: {num: 10, den: 1} },
    mm: { m: {num: 1, den: 1000}, cm: {num: 1, den: 10} },
    in: { m: {num: 1, den: 39.37}, ft: {num: 1, den: 12} },
    ft: { m: {num: 1, den: 3.281}, in: {num: 12, den: 1}, yd: {num: 1, den: 3} },
    yd: { m: {num: 1, den: 1.094}, ft: {num: 3, den: 1} },
    mi: { m: {num: 1609, den: 1}, yd: {num: 1760, den: 1} }
  },

  tiempo: {
    h: { min: {num: 60, den: 1}, s: {num: 3600, den: 1}, d: {num: 1/24, den: 1} },
    min: { h: {num: 1, den: 60}, s: {num: 60, den: 1} },
    s: { min: {num: 1, den: 60}, h: {num: 1, den: 3600}, ms: {num: 1000, den: 1} },
    ms: { s: {num: 1, den: 1000} },
    d: { h: {num: 24, den: 1}, año: {num: 1, den: 365} },
    año: { d: {num: 365, den: 1} }
  },


  datos: {
    bit: {
      byte: {num: 1, den: 8}
    },
    byte: {
      bit: {num: 8, den: 1},
      KB: {num: 1, den: 1024}
    },
    KB: {
      byte: {num: 1024, den: 1},
      MB: {num: 1, den: 1024}
    },
    MB: {
      KB: {num: 1024, den: 1},
      GB: {num: 1, den: 1024}
    },
    GB: {
      MB: {num: 1024, den: 1}
    }
  },

  temperatura: {
    C: {
      K: { type: "affine", scale: 1, offset: 273.15, display: "K = °C + 273.15" },
      F: { type: "affine", scale: 9/5, offset: 32, display: "°F = °C * 1.8 + 32" }
    },
    K: {
      C: { type: "affine", scale: 1, offset: -273.15, display: "°C = K - 273.15" },
      F: { type: "affine", scale: 9/5, offset: -459.67, display: "°F = K * 1.8 - 459.67" }
    },
    F: {
      C: { type: "affine", scale: 5/9, offset: -(32 * 5/9), display: "°C = (°F - 32) * 5/9" },
      K: { type: "affine", scale: 5/9, offset: 273.15 - (32 * 5/9), display: "K = (°F - 32) * 5/9 + 273.15" }
    }
  }
};

const UNIT_LABELS = {
  C: "°C",
  F: "°F",
  K: "K"
};

function formatUnitLabel(unit) {
  return UNIT_LABELS[unit] || unit;
}

function formatNumber(num) {
// Formateo robusto con notación científica cuando el redondeo daría 0
  if (!Number.isFinite(num)) {
    return String(num);
  }
  if (Number.isInteger(num)) {
    return String(num);
  }
  const abs = Math.abs(num);
  const fixed = num.toFixed(3);
  const trimmed = fixed.replace(/\.?0+$/, '');
  if (parseFloat(trimmed) === 0 && abs > 0) {
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mant.toFixed(3).replace(/\.?0+$/, '') + '\u00d7' + '10' + expStr;
  }
  return trimmed === '-0' ? '0' : trimmed;
}




function applyConversion(value, rule) {
  if (!rule) {
    throw new Error("Regla de conversión ausente");
  }
  if (typeof rule.convert === "function") {
    return rule.convert(value);
  }
  if (rule.type === "affine") {
    return value * rule.scale + rule.offset;
  }
  if (typeof rule.num !== "undefined" && typeof rule.den !== "undefined") {
    return value * (rule.num / rule.den);
  }
  throw new Error("Tipo de conversión no soportado");
}

function describeConversion(from, to, rule) {
const fromLabel = formatUnitLabel(from);
  const toLabel = formatUnitLabel(to);

  if (rule && rule.display) {
    return rule.display;
  }

  const hasNumDen = rule && typeof rule.num !== 'undefined' && typeof rule.den !== 'undefined';
  const isComposite = String(from).includes('/') || String(to).includes('/');

  // Si tenemos factor numérico, siempre lo mostramos, también para compuestas
  if (hasNumDen) {
    const factor = rule.num / rule.den;
    const factorStr = formatNumber(factor);
    if (isComposite) {
      const splitFrom = String(from).split('/');
      const splitTo = String(to).split('/');
      const fNum = splitFrom[0] || from;
      const fDen = splitFrom[1] || '';
      const tNum = splitTo[0] || to;
      const tDen = splitTo[1] || '';
      const hints = [];
      if (fNum && tNum && fNum !== tNum) {
        hints.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
      }
      if (fDen || tDen) {
        if (fDen && tDen && fDen !== tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
        } else if (fDen && !tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)})`);
        } else if (!fDen && tDen) {
          hints.push(`/ (${formatUnitLabel(tDen)})`);
        }
      }
      const hintStr = hints.length ? ` ${hints.join(' ')}` : '';
      return `1 ${fromLabel} = ${factorStr} ${toLabel}${hintStr}`;
    }
    return `1 ${fromLabel} = ${factorStr} ${toLabel}`;
  }

  if (rule && rule.type === 'affine') {
    const scale = formatNumber(rule.scale);
    const offset = rule.offset || 0;
    if (!offset) {
      return `${toLabel} = ${scale} * ${fromLabel}`;
    }
    const signo = offset >= 0 ? '+' : '-';
    return `${toLabel} = ${scale} * ${fromLabel} ${signo} ${formatNumber(Math.abs(offset))}`;
  }

  // Fallback composito solo con etiquetas si no hay num/den
  if (isComposite) {
    const splitFrom = String(from).split('/');
    const splitTo = String(to).split('/');
    const fNum = splitFrom[0] || from;
    const fDen = splitFrom[1] || '';
    const tNum = splitTo[0] || to;
    const tDen = splitTo[1] || '';
    const parts = [];
    if (fNum && tNum) parts.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
    if (fDen || tDen) {
      if (fDen && tDen) parts.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
      else if (fDen) parts.push(`/ (${formatUnitLabel(fDen)})`);
      else if (tDen) parts.push(`/ (${formatUnitLabel(tDen)})`);
    }
    return `${fromLabel} = ${parts.join(' ')}`;
  }

  return `${fromLabel} \u2192 ${toLabel}`;
}






function conversion_unidades() {  function sci(num){
    if (!Number.isFinite(num)) return String(num);
    if (num === 0) return '0';
    const abs = Math.abs(num);
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const mantStr = mant.toFixed(3).replace(/\.?0+$/, '');
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mantStr + '\u00d7' + '10' + expStr;
  }

  function generarDistractores(valor) {
    const candidatos = new Set();
    const addCandidate = (num) => {
      if (!Number.isFinite(num)) return;
      if (num === valor) return;
      candidatos.add(num);
    };
    addCandidate(valor * 10);
    addCandidate(valor / 10);
    const absValor = Math.abs(valor) || 1;
    const order = Math.floor(Math.log10(absValor));
    let step;
    if (order >= 2) step = Math.pow(10, order - 1);
    else if (order === 1) step = 10;
    else if (order === 0) step = 1;
    else step = Math.pow(10, order);
    if (!Number.isFinite(step) || step === 0) step = absValor * 0.1 || 0.1;
    [Math.floor(valor / step) * step, Math.ceil(valor / step) * step].forEach(addCandidate);
    addCandidate(valor + step);
    addCandidate(valor - step);
    [0.9, 1.1, 0.95, 1.05].forEach((f)=>addCandidate(valor * f));
    let i = 1;
    while (candidatos.size < 3 && i <= 12){ addCandidate(valor + i*step*0.1); addCandidate(valor - i*step*0.1); addCandidate(valor*(1+i*0.02)); i++; }
    if (!candidatos.size){ addCandidate(valor + absValor); addCandidate(valor - absValor); addCandidate(valor + absValor*0.5); }
    return shuffle(Array.from(candidatos));
  }

  function buscarCaminoSimple(grafo, pasos) {
    const unidades = shuffle(Object.keys(grafo));
    for (const origen of unidades) {
      const visitados = new Set([origen]);
      const camino = [origen];
      const res = explorar(origen, pasos, grafo, visitados, camino);
      if (res) return res;
    }
    return null;
  }

  function explorar(actual, restantes, grafo, visitados, camino) {
    if (restantes === 0) return [...camino];
    const vecinos = shuffle(Object.keys(grafo[actual] || {}).filter(u=>!visitados.has(u)));
    for (const v of vecinos){
      visitados.add(v); camino.push(v);
      const r = explorar(v, restantes-1, grafo, visitados, camino);
      if (r) return r;
      camino.pop(); visitados.delete(v);
    }
    return null;
  }

  let intentos = 0;
  const allMagnitudes = Object.keys(EQUIVALENCIAS).filter(k => k !== 'temperatura');

  while (intentos < 10){
    intentos++;
    console.log(`\uD83D\uDD04 Intento ${intentos}`);

    // Elegir cuántas magnitudes combinar (2 a 4)
    const k = Math.min(4, Math.max(2, rndInt(2, Math.min(4, allMagnitudes.length))));
    const mags = shuffle(allMagnitudes).slice(0, k);

    // Partición en numerador/denominador (al menos 1 arriba)
    const numCount = rndInt(1, mags.length);
    const numeradores = mags.slice(0, numCount);
    const denominadores = mags.slice(numCount);

    console.log('[conv] Combinación:', {numeradores, denominadores});

    // Construir caminos por magnitud
    let valido = true;
    const piezas = [];
    for (const [rol, lista] of [['num', numeradores], ['den', denominadores]]){
      for (const mag of lista){
        const grafo = EQUIVALENCIAS[mag];
        const pasos = rndInt(1, 2);
        const camino = buscarCaminoSimple(grafo, pasos);
        if (!camino){ valido = false; break; }
        let factor = 1; const localSteps = [];
        for (let i=0;i<camino.length-1;i++){
          const a = camino[i], b = camino[i+1];
          const regla = (grafo[a]||{})[b];
          if (!regla){ valido = false; break; }
          localSteps.push({from:a, to:b, rule:regla});
          factor = applyConversion(factor, regla);
        }
        if (!valido) break;
        piezas.push({ rol, mag, path: localSteps, factor, from: camino[0], to: camino[camino.length-1], pasos: camino.length-1 });
      }
      if (!valido) break;
    }
    if (!valido || piezas.length === 0) continue;

    // Construir unidades compuestas origen/destino con punto medio
    const dot = '\u00b7';
    const numFrom = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.from));
    const denFrom = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.from));
    const numTo   = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.to));
    const denTo   = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.to));
    const unitFrom = numFrom.join(dot) + (denFrom.length? '/' + denFrom.join(dot) : '');
    const unitTo   = numTo.join(dot)   + (denTo.length?   '/' + denTo.join(dot)   : '');

    console.log('✅ Camino compuesto:', unitFrom, '→', unitTo);

    // Cantidad
    const cantidad = rndInt(1, 20);
    console.log(`\uD83D\uDCE6 Cantidad inicial: ${sci(cantidad)} ${unitFrom}`);

    // Factor combinado
    let factorTotal = 1; const factores = [];
    for (const pieza of piezas){
      for (const st of pieza.path){
        factores.push(describeConversion(st.from, st.to, st.rule));
      }
      if (pieza.rol === 'num') factorTotal *= pieza.factor; else factorTotal /= pieza.factor;
    }

    let valor = cantidad * factorTotal;
    if (!Number.isFinite(valor)){ console.error('💥 Valor no finito:', valor); continue; }

    const correctoStr = sci(valor);
    console.log(`🎯 Resultado correcto: ${correctoStr} ${unitTo}`);
    console.log('🧮 Factores aplicados:', factores);

    const distractoresNum = generarDistractores(valor);
    if (distractoresNum.length < 3){
      const set = new Set(distractoresNum); const base = Math.max(Math.abs(valor), 1);
      let extra=1; while (set.size<3){ set.add(valor + base*extra); extra++; }
      distractoresNum.splice(0, distractoresNum.length, ...Array.from(set));
    }
    const opcionesFmt = shuffle([valor, ...distractoresNum.slice(0,3)]).map(sci);
    console.log('🧠 Opciones generadas:', opcionesFmt);

    return {
      tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
      prompt: `Convierte ${sci(cantidad)} ${unitFrom} a ${unitTo}.`,
      equivalencias: factores,
      options: opcionesFmt,
      correct: [opcionesFmt.indexOf(correctoStr)]
    };
  }

  console.error('❌ No se pudo generar pregunta válida, devolviendo fallback...');
  return { tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
    prompt: 'Convierte 1 km a m. (Equivalencia: 1 km = 1000 m)', options: ['1000','100','10','2000'], correct: [0] };
}










REGISTRY.types["magnitudes_y_unidades"] = {
  name: "Magnitudes y Unidades",
  templates: [conversion_unidades]
};

REGISTRY.types["introduccion_telefonia"] = {
  name: "Introducción",
  templates: [magnitudes_electricas_cyb]
};


function magnitudes_electricas_cyb() {
  const data = [
    { magnitud: "Tensión", simbolo: "U o V", unidad: "Voltio" },
    { magnitud: "Intensidad", simbolo: "I", unidad: "Amperio" },
    { magnitud: "Resistencia", simbolo: "R", unidad: "Ohmio" },
    { magnitud: "Capacidad", simbolo: "C", unidad: "Faradio" },
    { magnitud: "Potencia", simbolo: "P", unidad: "Vatio" },
    { magnitud: "Frecuencia", simbolo: "f", unidad: "Hercio" }
  ];

  // Seleccionar un elemento aleatorio de la lista
  const elemento = data[Math.floor(Math.random() * data.length)];

  // Elegir al azar qué dar (magnitud/símbolo/unidad)
  const campos = ["magnitud", "simbolo", "unidad"];
  const dado = campos[Math.floor(Math.random() * campos.length)];

  // Elegir cuál preguntar (de los otros dos)
  let posibles = campos.filter(c => c !== dado);
  const preguntar = posibles[Math.floor(Math.random() * posibles.length)];

  // Enunciado dinámico
  let prompt;
  if (dado === "magnitud" && preguntar === "simbolo") {
    prompt = `La magnitud "${elemento.magnitud}" se representa con el símbolo…`;
  } else if (dado === "magnitud" && preguntar === "unidad") {
    prompt = `La magnitud "${elemento.magnitud}" se mide en…`;
  } else if (dado === "simbolo" && preguntar === "magnitud") {
    prompt = `El símbolo "${elemento.simbolo}" corresponde a la magnitud…`;
  } else if (dado === "simbolo" && preguntar === "unidad") {
    prompt = `El símbolo "${elemento.simbolo}" corresponde a la unidad…`;
  } else if (dado === "unidad" && preguntar === "magnitud") {
    prompt = `La unidad "${elemento.unidad}" corresponde a la magnitud…`;
  } else if (dado === "unidad" && preguntar === "simbolo") {
    prompt = `La unidad "${elemento.unidad}" se representa con el símbolo…`;
  }

  // Respuesta correcta
  const correcta = elemento[preguntar];

  // Distractores: valores del mismo campo de los otros elementos
  const incorrectas = data
    .filter(e => e !== elemento)
    .map(e => e[preguntar]);

  // Seleccionar 3 distractores al azar
  const distractores = shuffle(incorrectas).slice(0, 3);

  let opciones = shuffle([correcta, ...distractores]);

  return {
    mode: "single",
    prompt: prompt,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["C", "D"],
    repeatable: true
  };
}







function configuracion_electronica(){
  const Z = Math.floor(Math.random() * 50) + 1;
  const elem = ELEMENTOS[Z];
  const pregunta = `¿Cuál es la configuración electrónica del ${elem.nombre} (Z=${Z})?`;
  const correcta = elem.config;

  const distractores = new Set();

  function generarIncorrecta(){
    const modo = rndInt(1,4);
    let propuesta = "";

    if (modo === 1){
      const partes = correcta.split(" ");
      if (partes.length > 1) propuesta = [...partes].reverse().join(" ");
    } else if (modo === 2){
      let offset = Z + (Math.random() < 0.5 ? -9 : 9);
      if (ELEMENTOS[offset]) propuesta = ELEMENTOS[offset].config;
    } else if (modo === 3){
      propuesta = correcta.replace(/s/g,"p").replace(/p/g,"s");
    } else {
      propuesta = correcta.replace(/p6/,"p7").replace(/d10/,"d11");
    }

    return propuesta;
  }

  while (distractores.size < 3){
    const cand = generarIncorrecta();
    if (cand && cand !== correcta && !distractores.has(cand)){
      distractores.add(cand);
    }
  }

  const opciones = shuffle([correcta, ...distractores]);

  return {
    tema: "Teoría de los electrones",
    modelos: ["C","D"],
    repeatable: true,
    mode: "single",
    prompt: pregunta,
    options: opciones,
    correct: [opciones.indexOf(correcta)]
  };
}

function pregunta_teoria_de_los_electrones_1() {
  let correcta = "Protones y neutrones";
  let incorrectas = [
    "Electrones y protones",
    "Electrones y neutrones",
    "Electrones, protones y neutrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué partículas forman el núcleo atómico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_2() {
  let correcta = "Ligeramente menor que la del neutrón";
  let incorrectas = [
    "Exactamente igual a la del neutrón",
    "Mayor que la del neutrón",
    "La mitad de la del neutrón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del protón es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_3() {
  let correcta = "Igual en magnitud y de signo contrario";
  let incorrectas = [
    "Mayor en magnitud y del mismo signo",
    "Menor en magnitud y de signo contrario",
    "Igual en magnitud y del mismo signo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La carga del protón, en comparación con la del electrón, es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_4() {
  let correcta = "Aproximadamente 1/1836 de la masa del protón";
  let incorrectas = [
    "Igual a la masa del protón",
    "El doble de la masa del protón",
    "Aproximadamente 1/100 de la masa del protón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del electrón es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_5() {
  let correcta = "Que el número de protones es igual al número de electrones";
  let incorrectas = [
    "Que el número de protones es igual al número de neutrones",
    "Que el número de electrones es igual al número de neutrones",
    "Que el número de protones, electrones y neutrones es siempre el mismo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué significa que un átomo esté en equilibrio?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_6() {
  let correcta = "El número cuántico azimutal (l)";
  let incorrectas = [
    "El número cuántico principal (n)",
    "El número cuántico magnético (m)",
    "El número cuántico de espín (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué número cuántico determina la forma del orbital atómico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_7() {
  let correcta = "El número cuántico magnético (m)";
  let incorrectas = [
    "El número cuántico principal (n)",
    "El número cuántico azimutal (l)",
    "El número cuántico de espín (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué número cuántico determina la orientación del orbital atómico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_8() {
  let correcta = "El nivel de energía y tamaño del orbital";
  let incorrectas = [
    "La forma del orbital",
    "La orientación espacial del orbital",
    "El espín del electrón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué describe el número cuántico principal (n)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_9() {
  let correcta = "La orientación del giro intrínseco del electrón";
  let incorrectas = [
    "La energía del orbital",
    "La forma del orbital",
    "La orientación espacial del orbital"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué indica el número cuántico de espín (s)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_10() {
  let correcta = "2 electrones";
  let incorrectas = [
    "1 electrón",
    "4 electrones",
    "Hasta 8 electrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cuántos electrones pueden alojarse como máximo en un suborbital?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_11() {
  let correcta = "Catión";
  let incorrectas = [
    "Anión",
    "Molécula",
    "Protón"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Cuando un átomo pierde un electrón se forma un...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_12() {
  let correcta = "La compartición de electrones entre átomos";
  let incorrectas = [
    "La transferencia completa de electrones", 
    "La atracción electrostática entre iones", 
    "La presencia de un mar de electrones libres"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué caracteriza al enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_13() {
  let correcta = "Entre no metales";
  let incorrectas = [
    "Entre metales y no metales",
    "Entre metales",
    "Entre gases nobles"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Entre qué tipos de elementos se da un enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_14() {
  let correcta = "La energía necesaria para introducir un electrón en un átomo neutro";
  let incorrectas = [
    "La energía necesaria para arrancar un electrón de un átomo neutro", 
    "La capacidad de un átomo para atraer electrones en un enlace químico", 
    "La energía necesaria para separar protones y neutrones en el núcleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué es la afinidad electrónica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_15() {
  let correcta = "Negativa, tienden a ceder electrones, son reductores y se oxidan";
  let incorrectas = [
    "Positiva, tienden a ganar electrones, son oxidantes y se reducen",
    "Negativa, tienden a ganar electrones, son oxidantes y se reducen",
    "Positiva, tienden a ceder electrones, son reductores y se oxidan"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los metales tienen una afinidad electrónica...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_16() {
  let correcta = "En la transferencia completa de electrones entre un metal y un no metal, formándose iones que se atraen por fuerzas electrostáticas";
  let incorrectas = [
    "En la compartición de electrones entre átomos no metálicos",  
    "En la existencia de un mar de electrones libres entre átomos metálicos", 
    "En la atracción de un núcleo hacia los electrones de otro núcleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿En qué consiste un enlace iónico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_17() {
  let correcta = "Covalente";
  let incorrectas = [
    "Iónico",
    "Metálico",
    "De Van der Waals"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "El hidrógeno molecular (H₂) y el oxígeno molecular (O₂) son moléculas con enlace...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_18() {
  let correcta = "Son sólidos cristalinos, con altos puntos de fusión y conductores en disolución o fundidos";
  let incorrectas = [
    "Son blandos, con bajos puntos de fusión y no conducen la electricidad", 
    "Son maleables, dúctiles y buenos conductores en estado sólido", 
    "Son gaseosos en condiciones normales y no forman redes cristalinas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué características físicas presentan los compuestos iónicos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_19() {
  let correcta = "Cationes metálicos";
  let incorrectas = [
    "Aniones metálicos",
    "Protones libres",
    "Electrones deslocalizados"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Cómo se denominan los pseudoiones positivos en el enlace metálico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_20() {
  let correcta = "El equilibrio entre los cationes metálicos y los electrones deslocalizados";
  let incorrectas = [
    "La repulsión entre los electrones deslocalizados", 
    "La atracción entre protones y neutrones",
    "La alternancia de iones positivos y negativos en una red cristalina"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué mantiene la neutralidad electrostática en el enlace metálico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_21() {
  let correcta = "1, 8"; 
  let incorrectas = [
    "2, 6", // ❌ Incorrecta
    "3, 7", // ❌ Incorrecta
    "4, 2"  // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los elementos conductores serán aquellos que tienen ... de valencia. Los aislantes serán los que tienen ... electrones en su capa de valencia.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_22() {
  let correcta = "La plata (Ag)";
  let incorrectas = [
    "El cobre (Cu)",   // ❌ Incorrecta
    "El oro (Au)",     // ❌ Incorrecta
    "El aluminio (Al)" // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué material es el mejor conductor de la electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_23() {
  let correcta = "Un material puro cuya conductividad depende de la temperatura y no de impurezas añadidas";
  let incorrectas = [
    "Un material puro cuya conductividad depende únicamente de impurezas añadidas", // ❌ Extrínseco
    "Un metal con baja resistividad eléctrica",                                    // ❌ Incorrecta
    "Un aislante que nunca puede conducir electricidad"                            // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¿Qué es un semiconductor intrínseco?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_24() {
  let correcta = "Tipo P";
  let incorrectas = [
    "Tipo N",   // ❌ Incorrecta
    "Tipo NP",  // ❌ Incorrecta
    "Intrínseco" // ❌ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Si se añade galio (Ga) a un cristal de silicio (Si), se formará un semiconductor...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_25() {
  let correcta = "N"; 
  let incorrectas = [
    "P",            // ❌ Aceptoras, grupo III
    "NP",           // ❌
    "Intrínsecas"   // ❌
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Un semiconductor donante está dopado con impurezas de tipo...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

















</script>


</script>
</body>
</html>










