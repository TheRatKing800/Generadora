<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Atenea ‚Äî prototipo</title>
  <style>
    :root { --pad:16px; --radius:16px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#0f172a; color:#e5e7eb;}
    header { padding:24px var(--pad); background:#111827; border-bottom:1px solid #1f2937;}
    h1 { margin:0 0 6px; font-size:24px; font-weight:500;}
    .sub { color:#9ca3af; font-size:18px;}
    main { max-width:900px; margin: 0 auto; padding: 24px var(--pad) 80px;}
    .card { background:#111827; border:1px solid #1f2937; border-radius:var(--radius); padding: 18px; box-shadow:0 10px 25px rgba(0,0,0,.25);}
    .row { display:grid; gap:12px; }
    @media (min-width: 720px){ .row-3 { grid-template-columns: repeat(3, 1fr);} .row-2 { grid-template-columns: repeat(2, 1fr);} }
    label { font-size:18px; color:#cbd5e1; }
    select, input[type="number"], button, .pill {
      width:100%; background:#0b1220; color:#e5e7eb; border:1px solid #1f2937;
      padding:10px 12px; border-radius:12px; outline:none;
    }
    button { cursor:pointer; font-weight:400; }
    button.primary { background:#2563eb; border-color:#2563eb; }
    button.ghost { background:#0b1220; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .prompt { font-size:24px; line-height:1.5; margin: 8px 0 14px; color:#f3f4f6;}
    .opts { display:grid; gap:10px; }
    .opt { font-size:22px;  text-align:left; padding:12px; border-radius:12px; border:1px solid #1f2937; background:#0b1220; cursor:pointer; }
    .opt.correct { border-color:#16a34a; background:#0b1f14; }
    .opt.wrong   { border-color:#dc2626; background:#1a0b0b; }
    .muted { color:#9ca3af; font-size:15px; }
    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#0b1220; border:1px solid #1f2937; color:#cbd5e1; font-size:14px; }
    .spacer { height:8px; }
    .footer { position:fixed; left:0; right:0; bottom:0; padding:10px var(--pad); background:#0b1220; border-top:1px solid #1f2937; display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .score { font-weight:500; }
    .explain { margin-top:10px; color:#d1d5db; font-size:18px; }
    .hide { display:none; }
    .selected {
      border-color:#2563eb;
      background:#1e3a8a;
    }
  </style>
</head>
<body>

<main>
  <section id="panel-config" class="card">
    

  
  <!-- üîπ PASO 1: CURSO ACAD√âMICO -->
  <div class="row row-2">
    <div>
      <label for="curso">Curso acad√©mico</label>
      <select id="curso">
        <option value="">-- Selecciona curso --</option>
        <option value="Promocion_XXXIV_STP">Promoci√≥n XXXIV STP</option>
        <option value="Promocion_XXXV_STP">Promoci√≥n XXXV STP</option>
        <option value="Promocion_XXXVI_STP">Promoci√≥n XXXVI STP</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
<!-- üîπ NUEVO BLOQUE DE SELECCI√ìN EN CASCADA -->
  <div class="row row-3" id="fila-eat">
  <div id="bloque-esp" class="hide">
    <label for="especialidad">Especialidad</label>
    <select id="especialidad">
      <option value="">-- Selecciona especialidad --</option>
      <option value="GENERAL">GENERAL</option>
      <option value="CAE">CAE</option>
      <option value="CYB">CYB</option>
      <option value="MER">MER</option>
      <option value="ELC">ELC</option>
      <option value="AYF">AYF</option>
      <option value="PAO">PAO</option>
    </select>
  </div>
  <div id="bloque-asig" class="hide">
    <label for="asignatura">Asignatura</label>
    <select id="asignatura" disabled>
      <option value="">-- Selecciona asignatura --</option>
    </select>
  </div>
  <div id="bloque-tema" class="hide">
    <label for="tema">Tema</label>
    <select id="tema" disabled>
      <option value="">-- Selecciona tema --</option>
    </select>
  </div>
</div>

  <div class="spacer"></div>
  <!-- üîπ FIN DEL BLOQUE NUEVO -->
    <div class="row row-1 hide">
  <div>
    <label for="modo">Modo de juego</label>
    <select id="modo">
  <option value="">-- Selecciona modo de juego --</option>
  <option value="estandar">Est√°ndar (30 preguntas, revisi√≥n final)</option>
  <option value="contrarreloj">Contrarreloj (vidas + tiempo)</option>
  <option value="vidas">Por vidas (explicaciones + vidas)</option>
</select>

  </div>
</div>

  <div class="spacer"></div>
  <!-- üîπ PASO FINAL: MODELO -->
  <div class="spacer"></div>
  <div class="row row-1 hide">
    <div>
      <label for="modelo">Modelo</label>
      <select id="modelo">
        <option value="">-- Selecciona --</option>
        <option value="A">Modelo A ‚Äî Daypo</option>
        <option value="B">Modelo B ‚Äî Libro</option>
        <option value="C">Modelo C ‚Äî Diario de la gente</option>
        <option value="D">Modelo D ‚Äî Todo</option>
        <option value="E">Modelo E ‚Äî Selecci√≥n por grupos</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
  <div id="opcionesModelo" class="card hide"></div>
  <div class="spacer"></div>

  <div class="row row-2">
    <button id="start" class="primary" disabled>Empezar</button>
  </div>

  </section> <!-- üî∏ CIERRE correcto de #panel-config -->

<section id="panel-test" class="card hide">
  <div class="muted" id="meta"></div>
  <div class="prompt" id="prompt"></div>
  <div id="options" class="opts"></div>
  <div id="explain" class="explain hide"></div>
</section>

<section id="panel-result" class="card hide">
  <h3>Resumen</h3>
  <p class="muted" id="summary"></p>
  <div class="spacer"></div>
  <div class="row row-2">
    <button id="retry" class="primary">Repetir con mismos ajustes</button>
    <button id="home" class="ghost">Volver al inicio</button>
  </div>
</section>

</main>

<footer class="footer">
  <div style="display:flex; gap:12px; align-items:center;">
    <span class="badge" id="modeBadge">‚Äî</span>
    <span id="lives" class="muted"></span>
    <span id="timer" class="muted"></span>
  </div>
  <div class="score" id="score">0 / 0</div>
  <div style="display:flex; gap:8px;">
    <button id="check" class="ghost">Comprobar</button>
    <button id="next" class="primary" disabled>Siguiente</button>
  </div>
</footer>


<script>
/* ==========================================================
   SUPERTEST ‚Äî MOTOR B√ÅSICO LIMPIO
========================================================== */

const rndInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

const REGISTRY = { types: {} };

/* ========== TIPO: CONSTITUCI√ìN (ejemplo) ========== */
// constitucion.js - TODAS LAS PLANTILLAS TRADUCIDAS DESDE Constitucion_prime.py

(function registerAritmetica() {

  function suma_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a + b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritm√©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¬øCu√°nto es ${a} + ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function multiplicacion_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    const correct = parseFloat((a * b).toFixed(2)); // hasta 2 decimales

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        let valor = correct + delta;
        // Mantener formato si el correcto tiene decimales
        if (String(correct).includes(".")) {
          valor = parseFloat(valor.toFixed(2));
        }
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritm√©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¬øCu√°nto es ${a} √ó ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function resta_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a - b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritm√©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¬øCu√°nto es ${a} - ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function division_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    if (b === 0) b = 1; // salvaguarda (no deber√≠a ocurrir con los rangos)

    const correct = parseFloat((a / b).toFixed(2));

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 3); // ¬± hasta 3
        } else {
          delta = (Math.random() < 0.5 ? -1 : 1) * 5; // saltos grandes
        }
        let valor = correct + delta;
        valor = parseFloat(valor.toFixed(2));
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "Aritm√©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `¬øCu√°nto es ${a} √∑ ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  REGISTRY.types["matematicas_aritmetica"] = {
    name: "Aritm√©tica",
    templates: [suma_basica, resta_basica, multiplicacion_basica, division_basica]
  };

})();






REGISTRY.types['teoria_electrones'] = { name: 'Teor√≠a de los electrones', templates: [configuracion_electronica,pregunta_teoria_de_los_electrones_1,pregunta_teoria_de_los_electrones_2,pregunta_teoria_de_los_electrones_3,pregunta_teoria_de_los_electrones_4,pregunta_teoria_de_los_electrones_5,pregunta_teoria_de_los_electrones_6,pregunta_teoria_de_los_electrones_7,pregunta_teoria_de_los_electrones_8,pregunta_teoria_de_los_electrones_9,pregunta_teoria_de_los_electrones_10,pregunta_teoria_de_los_electrones_11,pregunta_teoria_de_los_electrones_12,pregunta_teoria_de_los_electrones_13,pregunta_teoria_de_los_electrones_14,pregunta_teoria_de_los_electrones_15,pregunta_teoria_de_los_electrones_16,pregunta_teoria_de_los_electrones_17,pregunta_teoria_de_los_electrones_18,pregunta_teoria_de_los_electrones_19,pregunta_teoria_de_los_electrones_20,pregunta_teoria_de_los_electrones_21,pregunta_teoria_de_los_electrones_22,pregunta_teoria_de_los_electrones_23,pregunta_teoria_de_los_electrones_24,pregunta_teoria_de_los_electrones_25,pregunta_teoria_de_los_electrones_26,pregunta_teoria_de_los_electrones_27,pregunta_teoria_de_los_electrones_28,pregunta_teoria_de_los_electrones_29,pregunta_teoria_de_los_electrones_30,pregunta_teoria_de_los_electrones_31,pregunta_teoria_de_los_electrones_32,pregunta_teoria_de_los_electrones_34,pregunta_teoria_de_los_electrones_33]};
REGISTRY.types['electricidad_estatica'] = { name: 'Electricidad est√°tica y conducci√≥n', templates: [pregunta_fuerza_electrica_generica,pregunta_campo_electrico_generica,pregunta_potencial_electrico_generica,pregunta_energia_potencial_generica,pregunta_electricidad_estatica_1,pregunta_electricidad_estatica_2,pregunta_electricidad_estatica_3,pregunta_electricidad_estatica_4,pregunta_electricidad_estatica_5,pregunta_electricidad_estatica_6,pregunta_electricidad_estatica_7,pregunta_electricidad_estatica_8,pregunta_electricidad_estatica_10,pregunta_electricidad_estatica_11,pregunta_electricidad_estatica_9,pregunta_electricidad_estatica_12,pregunta_electricidad_estatica_13,pregunta_electricidad_estatica_14,pregunta_electricidad_estatica_15,pregunta_electricidad_estatica_16,pregunta_electricidad_estatica_17,pregunta_electricidad_estatica_18,pregunta_electricidad_estatica_19,pregunta_electricidad_estatica_20,pregunta_electricidad_estatica_21,pregunta_electricidad_estatica_22,pregunta_electricidad_estatica_23,pregunta_electricidad_estatica_24,pregunta_electricidad_estatica_25,pregunta_electricidad_estatica_26]};

(function registerEOFAS(){
  function eofas_1(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la Direcci√≥n General de Pol√≠tica de Defensa le corresponde:",
    options: [
      "Elaborar las lineas generales de las directrices generales de pol√≠tica de defensa para la participaci√≥n de otros Departamentos Ministeriales en la Defensa nacional",
      "Ejercer la notar√≠a militar",
      "Establecer la aplicaci√≥n de los planes de calidad de vida del personal militar.",
      "Gestionar la ordenaci√≥n farmac√©utica"
    ],
    correct: [0] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_2(){
  const base = [
    "El CIFAS est√° integrado en el EMACOM",
    "El MOPS est√° integrado en el Cuartel General del EMAD",
    "El EMACON es el √≥rgano auxiliar de mando del JEMAD",
    "__META__" // se convertir√° en "A y C son correctas."
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar √≠ndices de las opciones que la meta debe referenciar
  const idxCIFAS = barajadas.indexOf("El CIFAS est√° integrado en el EMACOM");
  const idxEMACON = barajadas.indexOf("El EMACON es el √≥rgano auxiliar de mando del JEMAD");

  // Reescribir la opci√≥n meta con las letras reales
  barajadas[idxMeta] = `${letra(idxCIFAS)}) y ${letra(idxEMACON)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta correcta",
    options: barajadas,
    correct: [2] // ‚ö†Ô∏è c√°mbialo seg√∫n cu√°l/es la correcta
  };
}



function eofas_3(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Como √≥rgano de asesoramiento y asistencia inmediata, el Ministro de Defensa cuenta con:",
    options: [
      "La Direcci√≥n General de Pol√≠tica de Defensa",
      "La Oficina de Comunicaci√≥n de la Defensa",
      "El Consejo Superior de los Ej√©rcitos.",
      "Un Gabinete T√©cnico"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_4(){
  const base = [
    "Dirigir el Plan de Diplomacia de Defensa",
    "Elaborar y proponer disposiciones en materia de retribuciones militares",
    "__META__", // se convertir√° en "a) y b) son correctas."
    "El asesoramiento sobre los aspectos relacionados con el estudio, planeamiento y desarrollo de las actividades de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los √≠ndices de las dos opciones que la meta debe referenciar
  const idxDiplomacia = barajadas.indexOf("Dirigir el Plan de Diplomacia de Defensa");
  const idxRetribuciones = barajadas.indexOf("Elaborar y proponer disposiciones en materia de retribuciones militares");

  // Reescribir la opci√≥n meta con las letras reales
  barajadas[idxMeta] = `${letra(idxDiplomacia)}) y ${letra(idxRetribuciones)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la Secretar√≠a General de Pol√≠tica de Defensa le corresponde:",
    options: barajadas,
    correct: [0] // ‚ö†Ô∏è c√°mbialo seg√∫n cu√°l/es la correcta
  };
}



function eofas_5(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de dirigir la elaboraci√≥n de los tratados internacionales que afecten a la Defensa es:",
    options: [
      "La SEDEF",
      "La DIGENPER",
      "La SUBDEF.",
      "La Secretar√≠a General de Pol√≠tica de Defensa"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_6(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: [
      "Garantizar la seguridad criptogr√°fica",
      "La funci√≥n de asesoramiento militar al Presidente del Gobierno",
      "Coordinar el Plan General de la Defensa Nacional.",
      "Asesorar al Secretario de Estado de Defensa en el desarrollo de la pol√≠tica econ√≥mica de sus ej√©rcitos"
    ],
    correct: [1] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_7(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano auxiliar de mando del JEMAD que apoya y asesora en la definici√≥n de la estrategia militares:",
    options: [
      "El EMACON",
      "La SUBDEF",
      "La SEDEF.",
      "El EMACOM"
    ],
    correct: [0] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_8(){
  const base = [
    "Dirigir la pol√≠tica de armamento, en relaci√≥n con organismos internacionales",
    "Asegurar la eficacia operativa de las Fuerzas Armadas",
    "__META__", // se convertir√° en "a) y c) son correctas."
    "Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar las dos opciones que debe referenciar la meta
  const idxArmamento = barajadas.indexOf("Dirigir la pol√≠tica de armamento, en relaci√≥n con organismos internacionales");
  const idxEjercer = barajadas.indexOf("Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas");

  // Reescribir el texto meta con las letras reales
  barajadas[idxMeta] = `${letra(idxArmamento)}) y ${letra(idxEjercer)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: barajadas,
    correct: [1] // ‚ö†Ô∏è cambia este √≠ndice seg√∫n cu√°l/es sean correctas
  };
}



function eofas_9(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de realizar las expropiaciones de bienes y derechos as√≠ como los arrendamientos pertinentes es:",
    options: [
      "La DIGENIN",
      "La DGAM",
      "La DIGENPER.",
      "La DIGENECO"
    ],
    correct: [0] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_10(){
  const base = [
    "Es un mando conjunto de la estructura operativa constituido de forma permanente",
    "Tiene como misi√≥n la intervenci√≥n en cualquier lugar del territorio nacional exclusivamente",
    "__META__", // se convertir√° en "b) y c) son correctas."
    "El JEMAD dictar√° las normas que regulen su organizaci√≥n"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los √≠ndices de las dos opciones que la meta debe se√±alar
  const idxMision = barajadas.indexOf("Tiene como misi√≥n la intervenci√≥n en cualquier lugar del territorio nacional exclusivamente");
  const idxJEMAD = barajadas.indexOf("El JEMAD dictar√° las normas que regulen su organizaci√≥n");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMision)}) y ${letra(idxJEMAD)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "La UME:",
    options: barajadas,
    correct: [0] // ‚ö†Ô∏è c√°mbialo seg√∫n cu√°l/es sean las correctas
  };
}



function eofas_11(){
  const base = [
    "Desarrollar la pol√≠tica medioambiental del Departamento",
    "Administrar los recursos financieros destinados a las operaciones de paz",
    "__META__", // se convertir√° en "a) y c) son correctas."
    "Dirigir la gesti√≥n de los bienes afectos al Ministerio de Defensa"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los √≠ndices de las dos opciones que debe se√±alar la meta
  const idxMedioambiente = barajadas.indexOf("Desarrollar la pol√≠tica medioambiental del Departamento");
  const idxBienes = barajadas.indexOf("Dirigir la gesti√≥n de los bienes afectos al Ministerio de Defensa");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMedioambiente)}) y ${letra(idxBienes)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENECO le corresponde:",
    options: barajadas,
    correct: [1] // ‚ö†Ô∏è c√°mbialo seg√∫n cu√°l/es sean correctas
  };
}



function eofas_12(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de llevar el inventario de los bienes del Ministerio de Defensa es:",
    options: [
      "La Secretar√≠a de Estado de Defensa",
      "La Direcci√≥n General de Infraestructura",
      "La Subdirecci√≥n General de R√©gimen Interior.",
      "La Direcci√≥n General de Patrimonio e Inventario"
    ],
    correct: [1] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_13(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de gestionar los sistemas inform√°ticos integrales de direcci√≥n y administraci√≥n econ√≥mica del Departamento es:",
    options: [
      "La Subdirecci√≥n General de Servicios Econ√≥micos y Pagadur√≠as",
      "La SEGENTE",
      "DIGENECO.",
      "DIGENIN"
    ],
    correct: [2] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_14(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de la direcci√≥n de las tecnolog√≠as y seguridad de la informaci√≥n en el √°mbito de la defensa es:",
    options: [
      "El Presidente del Gobierno",
      "La Junta de Defensa Nacional",
      "La SEDEF.",
      "El JEMAD"
    ],
    correct: [2] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_15(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de proponer la pol√≠tica industrial de la defensa es:",
    options: [
      "La SUBDEF",
      "La DIGENECO",
      "La DGAM",
      "La DGAN"
    ],
    correct: [2] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_16(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de la gesti√≥n de los servicios generales del √≥rgano central es:",
    options: [
      "La Secretar√≠a General T√©cnica",
      "La Subdirecci√≥n General de R√©gimen Interior",
      "La Subdirecci√≥n General de Seguridad y Servicios.",
      "La Subdirecci√≥n General de Servicios"
    ],
    correct: [1] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_17(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de elaborar estudios e informes sobre cu√°ntos asuntos sean sometidos a la deliberaci√≥n del Consejo de Ministros es:",
    options: [
      "La SEGENTE",
      "La Direcci√≥n General de Sanidad",
      "La Asesor√≠a Jur√≠dica General.",
      "La DIGENPER"
    ],
    correct: [0] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_18(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado del registro general en el √≥rgano central en el Ministerio de Defensa es:",
    options: [
      "La Subdirecci√≥n General de R√©gimen Interior",
      "La SEGENTE",
      "La Subdirecci√≥n General de Registro y Archivos.",
      "La SUBDEF"
    ],
    correct: [0] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_19(){
  const base = [
    "Elaborar el BOD",
    "Coordinar la pol√≠tica de igualdad",
    "__META__", // se convertir√° en "a) y c) son correctas."
    "Proponer y elaborar normas sobre reformas de m√©todos de trabajo"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar √≠ndices de las opciones que la meta debe referenciar
  const idxBOD = barajadas.indexOf("Elaborar el BOD");
  const idxNormas = barajadas.indexOf("Proponer y elaborar normas sobre reformas de m√©todos de trabajo");

  // Reescribir la opci√≥n meta con las letras reales
  barajadas[idxMeta] = `${letra(idxBOD)}) y ${letra(idxNormas)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENPER le corresponde:",
    options: barajadas,
    correct: [1] // ‚ö†Ô∏è c√°mbialo seg√∫n cu√°l/es la correcta
  };
}


function eofas_20(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la SEGENTE le corresponde:",
    options: [
      "Gestionar el personal militar de los Cuerpos Comunes",
      "Coordinar la pol√≠tica social para el personal militar",
      "Atender al gobierno de los √≥rganos centrales del Ministerio.",
      "Coordinar, gestionar e inspeccionar las Delegaciones de Defensa"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_21(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta incorrecta:",
    options: [
      "El Ej√©rcito de Tierra est√° constituido por el Cuartel General, la Fuerza y el Apoyo a la Fuerza",
      "A la DIGENPER le corresponde elaborar el r√©gimen general de los centros docentes militares, del alumnado y del profesorado",
      "A la DIGENPER le corresponde reconocer los derechos pasivos y conceder las prestaciones de clases pasivas del personal militar.",
      "A la DIGENPER le corresponde planificar los efectivos y el reclutamiento del personal militar"
    ],
    correct: [1] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_22(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de gestionar la formaci√≥n para el personal civil es:",
    options: [
      "La DIGENPER",
      "La DIGEREM",
      "La Subdirecci√≥n General de R√©gimen Interior.",
      "La SEGENTE"
    ],
    correct: [0] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_23(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El √≥rgano encargado de elaborar los planes de salidas profesionales del personal de las FAS es:",
    options: [
      "La DIGENPER",
      "La Direcci√≥n General de Pol√≠tica de Defensa",
      "La DIGEREN.",
      "La DIGEREM"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_24(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Inspector General de Sanidad ser√° desempe√±ado por:",
    options: [
      "Un General de Brigada del Cuerpo Militar de Sanidad",
      "Un Oficial General de los Cuerpos Comunes",
      "Un General de Divisi√≥n del Cuerpo Militar de Sanidad, en situaci√≥n de servicio activo.",
      "Un General de Divisi√≥n de cualquiera de los Ej√©rcitos"
    ],
    correct: [2] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_25(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ej√©rcito de Tierra, la Armada y el Ej√©rcito del Aire est√°n constituidos por:",
    options: [
      "El Cuartel General, la Log√≠stica y el Apoyo a la Fuerza",
      "La Fuerza, el Apoyo a la Fuerza y el Cuartel General",
      "El Apoyo a la Fuerza, el Cuartel General y las Fuerzas Operativas.",
      "La Fuerza, la Log√≠stica y el Mando Supremo"
    ],
    correct: [1] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_26(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Consejo Superior del Ej√©rcito del Aire es el √≥rgano colegiado asesor y consultivo de:",
    options: [
      "El Presidente del Gobierno",
      "El Subsecretario de Defensa",
      "La Junta de Defensa Nacional.",
      "El Ministro de Defensa"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_27(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Secretario del CSEA ser√° ejercido por:",
    options: [
      "El Vocal Accidental que se designe",
      "No existe el cargo de Secretario en el Consejo",
      "El Oficial General titular de la Secretar√≠a Permanente del CSEA.",
      "El Vocal de mayor antig√ºedad"
    ],
    correct: [2] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_28(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al General Jefe del MACOM en el Consejo le corresponder√° ser:",
    options: [
      "Vocal Accidental",
      "Vocal asesor",
      "Depende del tipo de reuni√≥n a realizar.",
      "Vocal Nato"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_29(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Consejo Superior del Ej√©rcito del Aire le corresponde:",
    options: [
      "Emitir informe sobre aquellos asuntos que someta a su consideraci√≥n el JEMA",
      "Ser o√≠do por el Ministro de Defensa en relaci√≥n con su propuesta de designaci√≥n del Jefe de Estado Mayor del Aire",
      "Todas las anteriores son correctas.",
      "Asesorar al Ministro de Defensa en materias relativas a la estructuraci√≥n del E.A"
    ],
    correct: [2] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_30(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Las reuniones del Consejo Superior del Ej√©rcito del Aire ser√°n convocadas por:",
    options: [
      "El Ministro de Defensa",
      "El Presidente del Gobierno",
      "El Director de Pol√≠tica de Defensa.",
      "El Jefe de Estado Mayor de la Defensa"
    ],
    correct: [0] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_31(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Es funci√≥n del CSEA:",
    options: [
      "Informar las evaluaciones para el ascenso al empleo de Teniente de los Militares de Complemento",
      "Ser o√≠do por el Ministro de Defensa en relaci√≥n con su propuesta de designaci√≥n del JEMAD",
      "Todas las anteriores son ciertas.",
      "Emitir informe en aquellos asuntos que someta a su consideraci√≥n expresa el JEMA"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_32(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "¬øA que √≥rgano le corresponde impartir los Altos Estudios de la Defensa Nacional?",
    options: [
      "Centro Superior de Altos Estudios de la Defensa(CESADEF)",
      "Centro Superior de Estudios de la Defensa Institucional(CESEDIN)",
      "Centro Superior de Estudios de la Defensa Nacional(CEDEDEN)",
      "Centro Universitario de la Defensa (CUD)."
    ],
    correct: [1] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}


function eofas_33(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El organismo p√∫blico dependiente directamente del titular del Departamento, y responsable de facilitar las informaciones, an√°lisis, estudios o propuestas que permitan prevenir y evitar cualquier peligro, amenaza o agresi√≥n contra la independencia o integridad territorial de Espa√±a, los intereses nacionales y la estabilidad del Estado de derecho y sus instituciones es:",
    options: [
      "Direcci√≥n Institucional de Contrainteligencia de la Defensa",
      "Asesor√≠a de Informaci√≥n y Riesgos del Ministerio de Defensa",
      "Subdirecci√≥n de An√°lisis e Informaci√≥n de la Defensa.",
      "Centro Nacional de Inteligencia"
    ],
    correct: [3] // ‚ö†Ô∏è Marcar luego la correcta manualmente
  };
}

REGISTRY.types["eofas"] = {
    name: "EOFAS",
    templates: [
eofas_1,
eofas_2,
eofas_3,
eofas_4,
eofas_5,
eofas_6,
eofas_7,
eofas_8,
eofas_9,
eofas_10,
eofas_11,
eofas_12,
eofas_13,
eofas_14,
eofas_15,
eofas_16,
eofas_17,
eofas_18,
eofas_19,
eofas_20,
eofas_21,
eofas_22,
eofas_23,
eofas_24,
eofas_25,
eofas_26,
eofas_27,
eofas_28,
eofas_29,
eofas_30,
eofas_31,
eofas_32,
eofas_33

    ]
  };
})();

(function registerConstitucion(){

  function t_constitucion(){
    const anios = [1808,1837,1845,1869,1876];
    const personas = ["Napole√≥n","Mar√≠a Cristina de Borb√≥n","Isabel II","General Francisco Serrano","Alfonso XII"];
    const idx = Math.floor(Math.random()*anios.length);
    const anio = anios[idx], persona = personas[idx];
    const distractores = personas.filter(p=>p!==persona).sort(()=>Math.random()-0.5).slice(0,3);
    const options = [persona,...distractores].sort(()=>Math.random()-0.5);
    return { modelos:["A","B","C","D","E"], mode:"single", prompt:`La Constituci√≥n de ${anio} fue entregada por:`, options, correct:[options.indexOf(persona)] };
  }

  

  REGISTRY.types["constitucion"] = {
    name: "Constituci√≥n",
    templates: [
      t_constitucion
    ]
  };
})();


/* ---------- Estado ---------- */
let state = {
  typeKey: null,
  templateName: "__random__",
  mode: "estandar",   // nuevo
  total: 30,          // por defecto
  asked: 0,
  correct: 0,
  lives: 3,           // para contrarreloj/vidas
  timeLeft: 40,       // tiempo actual por pregunta
  level: 1,
  current: null,
  selection: new Set(),
  curso: null,
  modelo: null,
  modeloConfig: {}
};


/* ---------- Referencias UI ---------- */
const elStart = document.getElementById('start');
const panelConfig = document.getElementById('panel-config');
const panelTest = document.getElementById('panel-test');
const panelResult = document.getElementById('panel-result');
const elPrompt = document.getElementById('prompt');
const elOptions = document.getElementById('options');
const elExplain = document.getElementById('explain');
const elMeta = document.getElementById('meta');
const elScore = document.getElementById('score');
const elNext = document.getElementById('next');
const elCheck = document.getElementById('check');
const elModeBadge = document.getElementById('modeBadge');
const elSummary = document.getElementById('summary');
const elRetry = document.getElementById('retry');
const elHome = document.getElementById('home');
const selEsp = document.getElementById("especialidad");
const selAsig = document.getElementById("asignatura");
const selTema = document.getElementById("tema");

const selCurso = document.getElementById("curso");
const selModelo = document.getElementById("modelo");
const divOpcModelo = document.getElementById("opcionesModelo");

// Compatibilidad: ejecutar cuando el DOM est√© listo (sin syntaxes modernas)
function onReady(cb){
  if (document.readyState !== 'loading') cb();
  else document.addEventListener('DOMContentLoaded', cb);
}

// Buscar el contenedor .row de un elemento sin usar ?.closest
function getRow(el){
  var p = el;
  while (p && p !== document.body){
    if (p && p.classList && p.classList.contains('row')) return p;
    p = p.parentNode;
  }
  return null;
}

// Mostrar/ocultar nodos usando una clase CSS (m√°s robusto que style.display)
function show(node, on){
  if (!node) return;
  if (on) node.classList.remove('hide');
  else node.classList.add('hide');
}


/* ---------- L√≥gica ---------- */
function makeQuestion(){
  const def = REGISTRY.types[state.typeKey];
  let fn;
  if (state.templateName === "__random__"){
    fn = def.templates[rndInt(0, def.templates.length-1)];
  } else {
    fn = def.templates[parseInt(state.templateName,10)];
  }
  return fn();
}

function renderQuestion(){
  if (!state.typeKey || !REGISTRY.types[state.typeKey]){
    elPrompt.textContent = "‚ùå Error: no hay ejercicios cargados para este tema.";
    return;
  }

  // Usar directamente el pool ya preparado en startTest()
if (!state.pool || state.pool.length === 0){
  if (state.repeatables && state.repeatables.length > 0){
    state.pool = state.repeatables.slice();
  } else {
    showResult();
    return;
  }
}



// Elegir al azar una plantilla del pool
let q = null;
let f = null;
let idx = -1;
let attempts = 0;
const maxAttempts = Math.max(3, state.pool.length);

while (!q && state.pool.length > 0 && attempts < maxAttempts) {
  attempts++;
  idx = rndInt(0, state.pool.length - 1);
  f = state.pool[idx];
  try {
    const candidate = f();
    if (!candidate || typeof candidate !== 'object') {
      throw new Error('Plantilla devolvi√≥ un resultado no v√°lido');
    }
    if (!Array.isArray(candidate.options) || candidate.options.length < 2) {
      throw new Error('Pregunta sin opciones suficientes');
    }
    q = candidate;
    if (!q.repeatable) {
      state.pool.splice(idx, 1);
    }
  } catch (err) {
    console.error('[render] Plantilla fallida', f && f.name, err);
    state.pool.splice(idx, 1);
    // Elimina tambi√©n de la lista de repetibles para evitar reinsertarla
    state.repeatables = state.repeatables.filter(fn => fn !== f);
  }
}

if (!q) {
  showResult();
  return;
}

// Guardar la pregunta actual
state.current = q;
  console.log('[render] Pregunta:', state.current.prompt);
  console.log('[render] Opciones:', (state.current.options||[]));











  state.selection = new Set();

  const {mode, prompt, options} = state.current;

  elModeBadge.textContent = (mode === "multi" ? "MODO: M√∫ltiple" : "MODO: √önica");
  elPrompt.textContent = prompt || "‚Äî";
  elExplain.classList.add('hide'); 
  elExplain.textContent = "";

  // Pintar opciones
  elOptions.innerHTML = "";
  options.forEach((text, idx)=>{
    const btn = document.createElement('button');
    btn.className = 'opt';
    btn.type = "button";
    btn.dataset.index = String(idx);
    btn.innerHTML = `<strong>${String.fromCharCode(97+idx)})</strong> ${text}`;
    btn.addEventListener('click', ()=>toggleSelect(idx, btn));
    elOptions.appendChild(btn);
  });


  // Equivalencias en recuadro bajo las respuestas
  (function(){
    var box = document.getElementById('equivalenciasBox');
    if (box) { box.parentNode && box.parentNode.removeChild(box); box = null; }
    if (Array.isArray(state.current.equivalencias) && state.current.equivalencias.length){
      box = document.createElement('div');
      box.id = 'equivalenciasBox';
      box.className = 'card';
      box.style.marginTop = '12px';
      box.style.fontSize = '18px';
      box.style.lineHeight = '1.5';
      var html = '<strong>Equivalencias</strong>' + '<div style="margin-top:6px">'
        + (state.current.equivalencias||[]).map(function(e){return '<div>&bull; '+e+'</div>';}).join('') + '</div>';
      box.innerHTML = html;
      elOptions.insertAdjacentElement('afterend', box);
    }
  })();  // Modo contrarreloj
  if (state.mode === "contrarreloj"){
    clearInterval(state.timerId);
    state.timeLeft = Math.max(20, 40 - (state.level-1)*5);
    updateHUD();
    state.timerId = setInterval(()=>{
      state.timeLeft--;
      updateHUD();
      if (state.timeLeft <= 0){
        state.lives--;
        clearInterval(state.timerId);
        if (state.lives <= 0){ 
          showResult(); 
          return; 
        } else if (state.timerId){
          clearInterval(state.timerId);
          state.timerId = null;
        }
        nextQuestion();
      }
    }, 1000);
  }

  // Meta
  elMeta.textContent = state.total ? `Pregunta ${state.asked+1} de ${state.total}` : `Pregunta ${state.asked+1}`;
  elNext.disabled = true;
  updateScore();
  updateHUD();
}




function toggleSelect(idx, elBtn){
  const mode = state.current.mode;
  if (mode === "single"){
    state.selection.clear();
    Array.from(elOptions.children).forEach(ch=>{
      ch.classList.remove('selected');
    });
    state.selection.add(idx);
    elBtn.classList.add('selected');
  } else {
    if (state.selection.has(idx)){
      state.selection.delete(idx);
      elBtn.classList.remove('selected');
    } else {
      state.selection.add(idx);
      elBtn.classList.add('selected');
    }
  }
}

function checkAnswer(){
if (state.selection.size===0) return;

  // detener el temporizador mientras se corrige la pregunta
  if (state.mode === "contrarreloj" && state.timerId){
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const correctSet = new Set(state.current.correct);
  const isCorrect = (
    state.selection.size === correctSet.size &&
    Array.from(state.selection).every(i => correctSet.has(i))
  );

  console.log('[check] Selecci√≥n:', Array.from(state.selection));
  console.log('[check] Correctas:', Array.from(correctSet));
  console.log('[check] ¬øCorrecto?:', isCorrect);

  // Pintado de feedback
  Array.from(elOptions.children).forEach((btn, i)=>{
    if (correctSet.has(i)) btn.classList.add('correct');
    else if (state.selection.has(i)) btn.classList.add('wrong');
    btn.disabled = true;
  });

  if (isCorrect){
    state.correct++;
    if (state.correct % 5 === 0){ state.level++; }
  } else {
    if (state.mode === "contrarreloj" || state.mode === "vidas"){
      state.lives = Math.max(0, state.lives - 1);
      updateHUD();
      if (state.lives <= 0){ showResult(); return; }
    }
  }

  // Explicaci√≥n (si la hay)
  if (state.current.explanation){
    elExplain.classList.remove('hide');
    elExplain.classList.add('card');
    var extra = document.createElement('div');
    extra.style.marginTop = '8px';
    extra.textContent = state.current.explanation;
    elExplain.appendChild(extra);
  }

  elNext.disabled = false;
  updateScore();
}


function nextQuestion(){
  state.asked++;
  if (state.total && state.asked >= state.total){
    showResult();
  } else {
      renderQuestion();
}
}


function updateScore(){
  elScore.textContent = `${state.correct} / ${state.asked} acertadas`;
}

function startTest(){
  if (state.timerId) {
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const esp = selEsp.value;
  const asig = selAsig.value;
  const tema = selTema.value;
  const modoSel = document.getElementById("modo").value;

  state.curso = selCurso.value;
  if (!state.curso){ 
    alert("Selecciona el curso acad√©mico."); 
    return; 
  }

  state.modelo = selModelo.value;
  if (!state.modelo){ 
    alert("Selecciona el modelo (A‚ÄìE)."); 
    return; 
  }

  state.mode = modoSel;
  state.asked = 0;
  state.correct = 0;
  state.lives = 3;
  state.level = 1;
  state.timeLeft = 40;
  state.selection = new Set();
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);

  // Inicializar arrays vac√≠os para evitar errores
  state.pool = [];
  state.repeatables = [];

  // üîπ Definimos un mapeo de combinaciones a typeKey
  MAPEO_TEMAS = {
    "GENERAL|Constituci√≥n|Test Constituci√≥n": "constitucion",
    "GENERAL|EOFAS|EOFAS": "eofas",
    "CYB|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "CAE|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "PAO|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "ELC|Fundamentos de electricidad|Electricidad est√°tica y conducci√≥n": "electricidad_estatica",
    "MER|Fundamentos de electricidad|Electricidad est√°tica y conducci√≥n": "electricidad_estatica",
    "PAO|Sistemas de telefon√≠a fija y m√≥vil|Introducci√≥n": "introduccion_telefonia",
    "CYB|Sistemas de telefon√≠a fija y m√≥vil|Introducci√≥n": "introduccion_telefonia",
    "CAE|Sistemas de telefon√≠a fija y m√≥vil|Introducci√≥n": "introduccion_telefonia",
    "MER|Matem√°ticas|Aritm√©tica": "matematicas_aritmetica",
    "ELC|Matem√°ticas|Aritm√©tica": "matematicas_aritmetica",
    "MER|Fundamentos de electricidad|Teor√≠a de los electrones": "teoria_electrones",
    "ELC|Fundamentos de electricidad|Teor√≠a de los electrones": "teoria_electrones"
  };

  const key = `${esp}|${asig}|${tema}`;
  state.typeKey = MAPEO_TEMAS[key];

  // Si no est√° implementado ‚Üí mostrar aviso, pero mantener el wizard abierto
  if (!state.typeKey || !REGISTRY.types[state.typeKey]) {
    alert(`‚ö†Ô∏è Tema a√∫n no implementado: ${esp} ‚Üí ${asig} ‚Üí ${tema}`);
    return;  // üëà ya no oculta ni reinicia, solo no arranca el test
  }

  // üîπ Construir pool filtrado
  const def = REGISTRY.types[state.typeKey];
  const templates = Array.isArray(def.templates) ? def.templates : [];

  // Construir el pool inicial de plantillas v√°lidas seg√∫n el modelo
  state.pool = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo);
    } catch(e){ 
      return false; 
    }
  });

  // Guardar aparte las repetibles para reponerlas cuando se vac√≠e el pool
  state.repeatables = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo) && q.repeatable === true;
    } catch(e){ 
      return false; 
    }
  });

  // Si no hay preguntas en el pool ‚Üí avisar y volver al wizard
  if (state.pool.length === 0){
    alert(`‚ö†Ô∏è El tema ${def.name} no tiene preguntas para el modelo ${state.modelo}.`);
    panelTest.classList.add('hide');
    panelConfig.classList.remove('hide');
    return;
  }

  // Ajustar n√∫mero total de preguntas seg√∫n modo
  if (state.mode === "estandar") {
    // üîπ Comprobar si el tema tiene plantillas repetibles
    const hasRepeatables = templates.some(f => {
      try {
        const q = f();
        return q.repeatable === true;
      } catch(e) {
        return false;
      }
    });

    if (hasRepeatables) {
      state.total = 30;   // ‚úÖ fija 30 preguntas aunque se repitan
    } else {
      state.total = state.pool.length;  // ‚úÖ solo las disponibles (no repetibles)
    }
  } else {
    state.total = null;  // en otros modos (vidas, contrarreloj) no hay l√≠mite fijo
  }

  // Mostrar panel del test
  panelConfig.classList.add('hide');
  panelResult.classList.add('hide');
  panelTest.classList.remove('hide');

  updateHUD();
  renderQuestion();
}




// En el script
function updateHUD(){
  if (state.mode!=="estandar"){
    document.getElementById("lives").textContent = "‚ù§".repeat(state.lives);
  } else {
    document.getElementById("lives").textContent = "";
  }
  if (state.mode==="contrarreloj"){
    document.getElementById("timer").textContent = state.timeLeft+"s";
  } else {
    document.getElementById("timer").textContent = "";
  }
}


function showResult(){
  panelTest.classList.add('hide');
  panelResult.classList.remove('hide');

  if (state.total){
    elSummary.textContent = `Has acertado ${state.correct} de ${state.total} (${Math.round(100*state.correct/state.total)}%).`;
  } else {
    elSummary.textContent = `Has acertado ${state.correct} preguntas.`;
  }
}


/* ---------- Eventos ---------- */
elStart.addEventListener('click', startTest);
elCheck.addEventListener('click', checkAnswer);
elNext.addEventListener('click', nextQuestion);
elRetry.addEventListener('click', startTest);
elHome.addEventListener('click', ()=>{
  if (state.timerId) { clearInterval(state.timerId); state.timerId = null; }
  panelResult.classList.add('hide');
  panelConfig.classList.remove('hide');
});



/* ---------- Atajos ---------- */
window.addEventListener('keydown', (e)=>{
  if (panelTest.classList.contains('hide')) return;
  const key = e.key.toLowerCase();
  const map = { a:0, b:1, c:2, d:3 };
  if (key in map){
    const idx = map[key];
    const btn = elOptions.children[idx];
    if (btn && !btn.disabled) btn.click();
  } else if (key === 'enter'){
    if (!elNext.disabled) nextQuestion(); else checkAnswer();
  } else if (key === 'n'){
    if (!elNext.disabled) nextQuestion();
  }
});


/* ---------- Datos de especialidades ---------- */
const ESPECIALIDADES_BY_CURSO = {
  "Promocion_XXXIV_STP": {},
  "Promocion_XXXV_STP": {},
  "Promocion_XXXVI_STP": {
    "GENERAL": {
      "Constituci√≥n": ["Test Constituci√≥n"],
      "EOFAS": ["EOFAS"],
    },
    "CAE": {
      "T√©cnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefon√≠a fija y m√≥vil":["Introducci√≥n","Introducci√≥n a la telefon√≠a","Evoluci√≥n de la estructura de la red telef√≥nica","La se√±al telef√≥nica","Telefon√≠a digital","Multiplexaci√≥n de canales MIC","Tecnolog√≠as de banda ancha. RDSI y ATM","Estructura de la red y tr√°fico telef√≥nico", "Conmutaci√≥n telef√≥nica","Sistemas digitales de conmutaci√≥n","Sistema privado de conmutaci√≥n PBX"],
      "Auditor√≠a Redes WIFI":["Introducci√≥n","Herramientas de auditor√≠a de redes LAN inal√°mbricas","Criptograf√≠a","Medidas de seguridad b√°sicas","Herramientas de captura y analisis de tr√°fico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    },
    "CYB": {
      "T√©cnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefon√≠a fija y m√≥vil":["Introducci√≥n","Introducci√≥n a la telefon√≠a","Evoluci√≥n de la estructura de la red telef√≥nica","La se√±al telef√≥nica","Telefon√≠a digital","Multiplexaci√≥n de canales MIC","Tecnolog√≠as de banda ancha. RDSI y ATM","Estructura de la red y tr√°fico telef√≥nico", "Conmutaci√≥n telef√≥nica","Sistemas digitales de conmutaci√≥n","Sistema privado de conmutaci√≥n PBX"],
      "Auditor√≠a Redes WIFI":["Introducci√≥n","Herramientas de auditor√≠a de redes LAN inal√°mbricas","Criptograf√≠a","Medidas de seguridad b√°sicas","Herramientas de captura y analisis de tr√°fico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    },
    "MER": {
      "Matem√°ticas":["Aritm√©tica","√Ålgebra","Geometr√≠a"],
      "F√≠sica":["La materia","Mec√°nica","Termodin√°mica","√ìptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["Teor√≠a de los electrones", "Electricidad est√°tica y conducci√≥n", "Terminolog√≠a el√©ctrica","Generaci√≥n de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "Teor√≠a del motor/Generador DC","Teor√≠a de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electr√≥nica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["Cap√≠tulo 0","Forma del fuselaje","Esfuerzos y deformaci√≥n","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que act√∫an en el avi√≥n","Velocidades de influencia estructural","Secci√≥n D","Cargas estructurales en el helic√≥ptero","Certificaci√≥n de las estructuras aeron√°uticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromec√°mico":["Generalidades","Rendimiento y limitaciones humanas","Psicolog√≠a social", "Factores que afectan al rendimiento","Entorno f√≠sico","Tareas","Comunaci√≥n","Error humano","Riesgos Laborales"]
    },
    "ELC": {
      "Matem√°ticas":["Aritm√©tica","√Ålgebra","Geometr√≠a"],
      "F√≠sica":["La materia","Mec√°nica","Termodin√°mica","√ìptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["Teor√≠a de los electrones", "Electricidad est√°tica y conducci√≥n", "Terminolog√≠a el√©ctrica","Generaci√≥n de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "Teor√≠a del motor/Generador DC","Teor√≠a de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electr√≥nica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["Cap√≠tulo 0","Forma del fuselaje","Esfuerzos y deformaci√≥n","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que act√∫an en el avi√≥n","Velocidades de influencia estructural","Secci√≥n D","Cargas estructurales en el helic√≥ptero","Certificaci√≥n de las estructuras aeron√°uticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromec√°mico":["Generalidades","Rendimiento y limitaciones humanas","Psicolog√≠a social", "Factores que afectan al rendimiento","Entorno f√≠sico","Tareas","Comunaci√≥n","Error humano","Riesgos Laborales"]
    },
    "AYF": {},
    "PAO": {
      "T√©cnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefon√≠a fija y m√≥vil":["Introducci√≥n","Introducci√≥n a la telefon√≠a","Evoluci√≥n de la estructura de la red telef√≥nica","La se√±al telef√≥nica","Telefon√≠a digital","Multiplexaci√≥n de canales MIC","Tecnolog√≠as de banda ancha. RDSI y ATM","Estructura de la red y tr√°fico telef√≥nico", "Conmutaci√≥n telef√≥nica","Sistemas digitales de conmutaci√≥n","Sistema privado de conmutaci√≥n PBX"],
      "Auditor√≠a Redes WIFI":["Introducci√≥n","Herramientas de auditor√≠a de redes LAN inal√°mbricas","Criptograf√≠a","Medidas de seguridad b√°sicas","Herramientas de captura y analisis de tr√°fico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    }
  }
};

/* ---------- Flujo paso a paso (wizard) y opciones de modelo ---------- */
function updateStartEnabled(){
  const okCurso = !!selCurso.value;
  const okEsp   = !!selEsp.value;
  const okAsig  = !!selAsig.value;
  const okTema  = !!selTema.value;

  const modoSel = document.getElementById("modo").value;
  let okModo = !!modoSel;

  const modelo  = selModelo.value;
  let okModelo  = !!modelo;

  // Validaciones espec√≠ficas de C/E
  if (modelo === "C"){
    var tipoCEl = document.getElementById("tipoC");
    const tipoC = (tipoCEl && tipoCEl.value) ? tipoCEl.value : "";
    okModelo = okModelo && !!tipoC;
  } else if (modelo === "E"){
    const grupos = Array.from(document.querySelectorAll('input[name="grupoE"]:checked'));
    const tipos  = Array.from(document.querySelectorAll('input[name="tipoE"]:checked'));
    const requiereTipos = (
      selAsig.value.toLowerCase().includes("matem") ||
      selTema.value.toLowerCase().includes("aritm")
    );
    okModelo = okModelo && grupos.length > 0 && (requiereTipos ? tipos.length > 0 : true);
  }

  // El bot√≥n siempre est√° visible, solo se activa/desactiva
  const ready = okCurso && okEsp && okAsig && okTema && okModo && okModelo;
  elStart.disabled = !ready;
}


function renderModelOptions(){
  const modelo = selModelo.value;
  divOpcModelo.innerHTML = "";
  divOpcModelo.classList.add("hide");

  if (!modelo){ updateStartEnabled(); return; }

  if (modelo === "C"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label for="tipoC">Modelo C ‚Äî ¬øqu√© quieres?</label>
          <select id="tipoC">
            <option value="">-- Selecciona --</option>
            <option value="teoria">Teor√≠a</option>
            <option value="practica">Pr√°ctica</option>
            <option value="ambas">Ambas</option>
          </select>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    document.getElementById("tipoC").addEventListener("change", updateStartEnabled);
  } else if (modelo === "E"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label>Grupos (puedes marcar varios)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="A"> Grupo A (Daypo)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="B"> Grupo B (Libro)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="C"> Grupo C (Diario)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="D"> Grupo D (Todo)</label>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="row row-2">
        <div>
          <label>Tipos de ejercicio (si aplica)</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="suma_basica"> Sumas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="resta_basica"> Restas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="multiplicacion_basica"> Multiplicaciones</label>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    Array.from(divOpcModelo.querySelectorAll('input[name="grupoE"], input[name="tipoE"]')).forEach(ch => {
      ch.addEventListener("change", updateStartEnabled);
    });
  }
  updateStartEnabled();

  }


function setupWizard(){
  // Referencias a bloques (no usar getRow con E/A/T porque comparten la misma fila)
  var rowEsp    = document.getElementById("bloque-esp");
  var rowAsig   = document.getElementById("bloque-asig");
  var rowTema   = document.getElementById("bloque-tema");
  var rowModo   = getRow(document.getElementById("modo"));
  var rowModelo = getRow(selModelo);
  var rowStart  = getRow(elStart);
  var filaEAT  = document.getElementById("fila-eat");

  // Estado inicial ‚Äî solo visible "Curso"
  show(rowEsp,    false);
  show(rowAsig,   false);
  show(rowTema,   false);
  show(rowModo,   false);
  show(rowModelo, false);
  // ‚ùå no ocultamos rowStart, el bot√≥n siempre se ve

  selAsig.disabled = true;
  selTema.disabled = true;
  divOpcModelo.classList.add('hide');
  divOpcModelo.innerHTML = "";

  // PASO 1 ‚Üí Curso
  function handleCursoChange(){
  try {
    selEsp.value = "";
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";
    const hasCurso = !!selCurso.value;
    selEsp.disabled = !hasCurso;
    if (filaEAT) show(filaEAT, hasCurso);
    show(rowEsp, hasCurso);
    show(rowAsig, false);
    show(rowTema, false);
    show(rowModo, false);
    show(rowModelo, false);
    updateStartEnabled();
    console.log('[wizard] curso change:', selCurso.value);
  } catch(e){ console.error('[wizard] handleCursoChange error', e); }
}
selCurso.addEventListener('change', handleCursoChange);
selCurso.addEventListener('input', handleCursoChange);


    if (selCurso && selCurso.value) { handleCursoChange(); }

// PASO 2 ‚Üí Especialidad
  selEsp.addEventListener("change", function(){
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    if (!cursoSel){
      alert("‚ö†Ô∏è Selecciona primero el curso acad√©mico.");
      selEsp.value = "";
      return;
    }
    var esp = selEsp.value;
    var data = ESPECIALIDADES_BY_CURSO[cursoSel] && ESPECIALIDADES_BY_CURSO[cursoSel][esp];

    if (data){
      Object.keys(data).forEach(function(a){
        var opt = document.createElement("option");
        opt.value = a; opt.textContent = a;
        selAsig.appendChild(opt);
      });
      selAsig.disabled = Object.keys(data).length === 0;
    } else {
      selAsig.innerHTML = '<option value="">‚Äî Sin datos para esta especialidad ‚Äî</option>';
      selAsig.disabled = true;
    }

    show(rowAsig,   true);
    show(rowTema,   false);
    show(rowModo,   false);
    show(rowModelo, false);

    updateStartEnabled();
  });

  // PASO 3 ‚Üí Asignatura
  selAsig.addEventListener("change", function(){
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    var esp = selEsp.value;
    var asig = selAsig.value;
    var temas = ESPECIALIDADES_BY_CURSO[cursoSel] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp][asig];

    if (Array.isArray(temas)){
      temas.forEach(function(t){
        var opt = document.createElement("option");
        opt.value = t; opt.textContent = t;
        selTema.appendChild(opt);
      });
      selTema.disabled = temas.length === 0;
    }

    show(rowTema,   true);
    show(rowModo,   false);
    show(rowModelo, false);

    // Reset de modo/modelo
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 4 ‚Üí Tema
  selTema.addEventListener("change", function(){
    show(rowModo,   !!selTema.value);
    show(rowModelo, false);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 5 ‚Üí Modo
  document.getElementById("modo").addEventListener("change", function(){
    show(rowModelo, !!this.value);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 6 ‚Üí Modelo
  selModelo.addEventListener("change", function(){
    renderModelOptions();
    updateStartEnabled();
  });

  // Recalcular si cambia el modo (vidas/tiempo)
  var modoSel = document.getElementById("modo");
  if (modoSel) modoSel.addEventListener("change", updateStartEnabled);

  updateStartEnabled();
}






// Ejecutar setup inmediatamente (el script est√° al final del body)





onReady(function(){
  setupWizard();
});


const ELEMENTOS = {
  1: { nombre: "Hidr√≥geno", config: "1s¬π" },
  2: { nombre: "Helio", config: "1s¬≤" },
  3: { nombre: "Litio", config: "1s¬≤ 2s¬π" },
  4: { nombre: "Berilio", config: "1s¬≤ 2s¬≤" },
  5: { nombre: "Boro", config: "1s¬≤ 2s¬≤ 2p¬π" },
  6: { nombre: "Carbono", config: "1s¬≤ 2s¬≤ 2p¬≤" },
  7: { nombre: "Nitr√≥geno", config: "1s¬≤ 2s¬≤ 2p¬≥" },
  8: { nombre: "Ox√≠geno", config: "1s¬≤ 2s¬≤ 2p‚Å¥" },
  9: { nombre: "Fl√∫or", config: "1s¬≤ 2s¬≤ 2p‚Åµ" },
  10: { nombre: "Ne√≥n", config: "1s¬≤ 2s¬≤ 2p‚Å∂" },
  11: { nombre: "Sodio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬π" },
  12: { nombre: "Magnesio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤" },
  13: { nombre: "Aluminio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p¬π" },
  14: { nombre: "Silicio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p¬≤" },
  15: { nombre: "F√≥sforo", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p¬≥" },
  16: { nombre: "Azufre", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å¥" },
  17: { nombre: "Cloro", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Åµ" },
  18: { nombre: "Arg√≥n", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂" },
  19: { nombre: "Potasio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 4s¬π" },
  20: { nombre: "Calcio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 4s¬≤" },
  21: { nombre: "Escandio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π 4s¬≤" },
  22: { nombre: "Titanio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬≤ 4s¬≤" },
  23: { nombre: "Vanadio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬≥ 4s¬≤" },
  24: { nombre: "Cromo", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d‚Åµ 4s¬π" },
  25: { nombre: "Manganeso", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d‚Åµ 4s¬≤" },
  26: { nombre: "Hierro", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d‚Å∂ 4s¬≤" },
  27: { nombre: "Cobalto", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d‚Å∑ 4s¬≤" },
  28: { nombre: "N√≠quel", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d‚Å∏ 4s¬≤" },
  29: { nombre: "Cobre", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬π" },
  30: { nombre: "Zinc", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤" },
  31: { nombre: "Galio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p¬π" },
  32: { nombre: "Germanio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p¬≤" },
  33: { nombre: "Ars√©nico", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p¬≥" },
  34: { nombre: "Selenio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å¥" },
  35: { nombre: "Bromo", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Åµ" },
  36: { nombre: "Kript√≥n", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂" },
  37: { nombre: "Rubidio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 5s¬π" },
  38: { nombre: "Estroncio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 5s¬≤" },
  39: { nombre: "Itrio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d¬π 5s¬≤" },
  40: { nombre: "Circonio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d¬≤ 5s¬≤" },
  41: { nombre: "Niobio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d‚Å¥ 5s¬π" },
  42: { nombre: "Molibdeno", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d‚Åµ 5s¬π" },
  43: { nombre: "Tecnecio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d‚Åµ 5s¬≤" },
  44: { nombre: "Rutenio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d‚Å∑ 5s¬π" },
  45: { nombre: "Rodio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d‚Å∏ 5s¬π" },
  46: { nombre: "Paladio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d¬π‚Å∞" },
  47: { nombre: "Plata", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d¬π‚Å∞ 5s¬π" },
  48: { nombre: "Cadmio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d¬π‚Å∞ 5s¬≤" },
  49: { nombre: "Indio", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d¬π‚Å∞ 5s¬≤ 5p¬π" },
  50: { nombre: "Esta√±o", config: "1s¬≤ 2s¬≤ 2p‚Å∂ 3s¬≤ 3p‚Å∂ 3d¬π‚Å∞ 4s¬≤ 4p‚Å∂ 4d¬π‚Å∞ 5s¬≤ 5p¬≤" },

  
};


const EQUIVALENCIAS = {
  distancia: {
    km: { m: {num: 1000, den: 1} },
    m: {
      km: {num: 1, den: 1000},
      cm: {num: 100, den: 1},
      mm: {num: 1000, den: 1},
      in: {num: 39.37, den: 1},
      ft: {num: 3.281, den: 1},
      yd: {num: 1.094, den: 1},
      mi: {num: 1/1609, den: 1}
    },
    cm: { m: {num: 1, den: 100}, mm: {num: 10, den: 1} },
    mm: { m: {num: 1, den: 1000}, cm: {num: 1, den: 10} },
    in: { m: {num: 1, den: 39.37}, ft: {num: 1, den: 12} },
    ft: { m: {num: 1, den: 3.281}, in: {num: 12, den: 1}, yd: {num: 1, den: 3} },
    yd: { m: {num: 1, den: 1.094}, ft: {num: 3, den: 1} },
    mi: { m: {num: 1609, den: 1}, yd: {num: 1760, den: 1} }
  },

  tiempo: {
    h: { min: {num: 60, den: 1}, s: {num: 3600, den: 1}, d: {num: 1/24, den: 1} },
    min: { h: {num: 1, den: 60}, s: {num: 60, den: 1} },
    s: { min: {num: 1, den: 60}, h: {num: 1, den: 3600}, ms: {num: 1000, den: 1} },
    ms: { s: {num: 1, den: 1000} },
    d: { h: {num: 24, den: 1}, a√±o: {num: 1, den: 365} },
    a√±o: { d: {num: 365, den: 1} }
  },


  datos: {
    bit: {
      byte: {num: 1, den: 8}
    },
    byte: {
      bit: {num: 8, den: 1},
      KB: {num: 1, den: 1024}
    },
    KB: {
      byte: {num: 1024, den: 1},
      MB: {num: 1, den: 1024}
    },
    MB: {
      KB: {num: 1024, den: 1},
      GB: {num: 1, den: 1024}
    },
    GB: {
      MB: {num: 1024, den: 1}
    }
  },

  temperatura: {
    C: {
      K: { type: "affine", scale: 1, offset: 273.15, display: "K = ¬∞C + 273.15" },
      F: { type: "affine", scale: 9/5, offset: 32, display: "¬∞F = ¬∞C * 1.8 + 32" }
    },
    K: {
      C: { type: "affine", scale: 1, offset: -273.15, display: "¬∞C = K - 273.15" },
      F: { type: "affine", scale: 9/5, offset: -459.67, display: "¬∞F = K * 1.8 - 459.67" }
    },
    F: {
      C: { type: "affine", scale: 5/9, offset: -(32 * 5/9), display: "¬∞C = (¬∞F - 32) * 5/9" },
      K: { type: "affine", scale: 5/9, offset: 273.15 - (32 * 5/9), display: "K = (¬∞F - 32) * 5/9 + 273.15" }
    }
  }
};

const UNIT_LABELS = {
  C: "¬∞C",
  F: "¬∞F",
  K: "K"
};

function formatUnitLabel(unit) {
  return UNIT_LABELS[unit] || unit;
}

function formatNumber(num) {
// Formateo robusto con notaci√≥n cient√≠fica cuando el redondeo dar√≠a 0
  if (!Number.isFinite(num)) {
    return String(num);
  }
  if (Number.isInteger(num)) {
    return String(num);
  }
  const abs = Math.abs(num);
  const fixed = num.toFixed(3);
  const trimmed = fixed.replace(/\.?0+$/, '');
  if (parseFloat(trimmed) === 0 && abs > 0) {
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mant.toFixed(3).replace(/\.?0+$/, '') + '\u00d7' + '10' + expStr;
  }
  return trimmed === '-0' ? '0' : trimmed;
}




function applyConversion(value, rule) {
  if (!rule) {
    throw new Error("Regla de conversi√≥n ausente");
  }
  if (typeof rule.convert === "function") {
    return rule.convert(value);
  }
  if (rule.type === "affine") {
    return value * rule.scale + rule.offset;
  }
  if (typeof rule.num !== "undefined" && typeof rule.den !== "undefined") {
    return value * (rule.num / rule.den);
  }
  throw new Error("Tipo de conversi√≥n no soportado");
}

function describeConversion(from, to, rule) {
const fromLabel = formatUnitLabel(from);
  const toLabel = formatUnitLabel(to);

  if (rule && rule.display) {
    return rule.display;
  }

  const hasNumDen = rule && typeof rule.num !== 'undefined' && typeof rule.den !== 'undefined';
  const isComposite = String(from).includes('/') || String(to).includes('/');

  // Si tenemos factor num√©rico, siempre lo mostramos, tambi√©n para compuestas
  if (hasNumDen) {
    const factor = rule.num / rule.den;
    const factorStr = formatNumber(factor);
    if (isComposite) {
      const splitFrom = String(from).split('/');
      const splitTo = String(to).split('/');
      const fNum = splitFrom[0] || from;
      const fDen = splitFrom[1] || '';
      const tNum = splitTo[0] || to;
      const tDen = splitTo[1] || '';
      const hints = [];
      if (fNum && tNum && fNum !== tNum) {
        hints.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
      }
      if (fDen || tDen) {
        if (fDen && tDen && fDen !== tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
        } else if (fDen && !tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)})`);
        } else if (!fDen && tDen) {
          hints.push(`/ (${formatUnitLabel(tDen)})`);
        }
      }
      const hintStr = hints.length ? ` ${hints.join(' ')}` : '';
      return `1 ${fromLabel} = ${factorStr} ${toLabel}${hintStr}`;
    }
    return `1 ${fromLabel} = ${factorStr} ${toLabel}`;
  }

  if (rule && rule.type === 'affine') {
    const scale = formatNumber(rule.scale);
    const offset = rule.offset || 0;
    if (!offset) {
      return `${toLabel} = ${scale} * ${fromLabel}`;
    }
    const signo = offset >= 0 ? '+' : '-';
    return `${toLabel} = ${scale} * ${fromLabel} ${signo} ${formatNumber(Math.abs(offset))}`;
  }

  // Fallback composito solo con etiquetas si no hay num/den
  if (isComposite) {
    const splitFrom = String(from).split('/');
    const splitTo = String(to).split('/');
    const fNum = splitFrom[0] || from;
    const fDen = splitFrom[1] || '';
    const tNum = splitTo[0] || to;
    const tDen = splitTo[1] || '';
    const parts = [];
    if (fNum && tNum) parts.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
    if (fDen || tDen) {
      if (fDen && tDen) parts.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
      else if (fDen) parts.push(`/ (${formatUnitLabel(fDen)})`);
      else if (tDen) parts.push(`/ (${formatUnitLabel(tDen)})`);
    }
    return `${fromLabel} = ${parts.join(' ')}`;
  }

  return `${fromLabel} \u2192 ${toLabel}`;
}






function conversion_unidades() {  function sci(num){
    if (!Number.isFinite(num)) return String(num);
    if (num === 0) return '0';
    const abs = Math.abs(num);
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const mantStr = mant.toFixed(3).replace(/\.?0+$/, '');
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mantStr + '\u00d7' + '10' + expStr;
  }

  function generarDistractores(valor) {
    const candidatos = new Set();
    const addCandidate = (num) => {
      if (!Number.isFinite(num)) return;
      if (num === valor) return;
      candidatos.add(num);
    };
    addCandidate(valor * 10);
    addCandidate(valor / 10);
    const absValor = Math.abs(valor) || 1;
    const order = Math.floor(Math.log10(absValor));
    let step;
    if (order >= 2) step = Math.pow(10, order - 1);
    else if (order === 1) step = 10;
    else if (order === 0) step = 1;
    else step = Math.pow(10, order);
    if (!Number.isFinite(step) || step === 0) step = absValor * 0.1 || 0.1;
    [Math.floor(valor / step) * step, Math.ceil(valor / step) * step].forEach(addCandidate);
    addCandidate(valor + step);
    addCandidate(valor - step);
    [0.9, 1.1, 0.95, 1.05].forEach((f)=>addCandidate(valor * f));
    let i = 1;
    while (candidatos.size < 3 && i <= 12){ addCandidate(valor + i*step*0.1); addCandidate(valor - i*step*0.1); addCandidate(valor*(1+i*0.02)); i++; }
    if (!candidatos.size){ addCandidate(valor + absValor); addCandidate(valor - absValor); addCandidate(valor + absValor*0.5); }
    return shuffle(Array.from(candidatos));
  }

  function buscarCaminoSimple(grafo, pasos) {
    const unidades = shuffle(Object.keys(grafo));
    for (const origen of unidades) {
      const visitados = new Set([origen]);
      const camino = [origen];
      const res = explorar(origen, pasos, grafo, visitados, camino);
      if (res) return res;
    }
    return null;
  }

  function explorar(actual, restantes, grafo, visitados, camino) {
    if (restantes === 0) return [...camino];
    const vecinos = shuffle(Object.keys(grafo[actual] || {}).filter(u=>!visitados.has(u)));
    for (const v of vecinos){
      visitados.add(v); camino.push(v);
      const r = explorar(v, restantes-1, grafo, visitados, camino);
      if (r) return r;
      camino.pop(); visitados.delete(v);
    }
    return null;
  }

  let intentos = 0;
  const allMagnitudes = Object.keys(EQUIVALENCIAS).filter(k => k !== 'temperatura');

  while (intentos < 10){
    intentos++;
    console.log(`\uD83D\uDD04 Intento ${intentos}`);

    // Elegir cu√°ntas magnitudes combinar (2 a 4)
    const k = Math.min(4, Math.max(2, rndInt(2, Math.min(4, allMagnitudes.length))));
    const mags = shuffle(allMagnitudes).slice(0, k);

    // Partici√≥n en numerador/denominador (al menos 1 arriba)
    const numCount = rndInt(1, mags.length);
    const numeradores = mags.slice(0, numCount);
    const denominadores = mags.slice(numCount);

    console.log('[conv] Combinaci√≥n:', {numeradores, denominadores});

    // Construir caminos por magnitud
    let valido = true;
    const piezas = [];
    for (const [rol, lista] of [['num', numeradores], ['den', denominadores]]){
      for (const mag of lista){
        const grafo = EQUIVALENCIAS[mag];
        const pasos = rndInt(1, 2);
        const camino = buscarCaminoSimple(grafo, pasos);
        if (!camino){ valido = false; break; }
        let factor = 1; const localSteps = [];
        for (let i=0;i<camino.length-1;i++){
          const a = camino[i], b = camino[i+1];
          const regla = (grafo[a]||{})[b];
          if (!regla){ valido = false; break; }
          localSteps.push({from:a, to:b, rule:regla});
          factor = applyConversion(factor, regla);
        }
        if (!valido) break;
        piezas.push({ rol, mag, path: localSteps, factor, from: camino[0], to: camino[camino.length-1], pasos: camino.length-1 });
      }
      if (!valido) break;
    }
    if (!valido || piezas.length === 0) continue;

    // Construir unidades compuestas origen/destino con punto medio
    const dot = '\u00b7';
    const numFrom = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.from));
    const denFrom = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.from));
    const numTo   = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.to));
    const denTo   = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.to));
    const unitFrom = numFrom.join(dot) + (denFrom.length? '/' + denFrom.join(dot) : '');
    const unitTo   = numTo.join(dot)   + (denTo.length?   '/' + denTo.join(dot)   : '');

    console.log('‚úÖ Camino compuesto:', unitFrom, '‚Üí', unitTo);

    // Cantidad
    const cantidad = rndInt(1, 20);
    console.log(`\uD83D\uDCE6 Cantidad inicial: ${sci(cantidad)} ${unitFrom}`);

    // Factor combinado
    let factorTotal = 1; const factores = [];
    for (const pieza of piezas){
      for (const st of pieza.path){
        factores.push(describeConversion(st.from, st.to, st.rule));
      }
      if (pieza.rol === 'num') factorTotal *= pieza.factor; else factorTotal /= pieza.factor;
    }

    let valor = cantidad * factorTotal;
    if (!Number.isFinite(valor)){ console.error('üí• Valor no finito:', valor); continue; }

    const correctoStr = sci(valor);
    console.log(`üéØ Resultado correcto: ${correctoStr} ${unitTo}`);
    console.log('üßÆ Factores aplicados:', factores);

    const distractoresNum = generarDistractores(valor);
    if (distractoresNum.length < 3){
      const set = new Set(distractoresNum); const base = Math.max(Math.abs(valor), 1);
      let extra=1; while (set.size<3){ set.add(valor + base*extra); extra++; }
      distractoresNum.splice(0, distractoresNum.length, ...Array.from(set));
    }
    const opcionesFmt = shuffle([valor, ...distractoresNum.slice(0,3)]).map(sci);
    console.log('üß† Opciones generadas:', opcionesFmt);

    return {
      tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
      prompt: `Convierte ${sci(cantidad)} ${unitFrom} a ${unitTo}.`,
      equivalencias: factores,
      options: opcionesFmt,
      correct: [opcionesFmt.indexOf(correctoStr)]
    };
  }

  console.error('‚ùå No se pudo generar pregunta v√°lida, devolviendo fallback...');
  return { tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
    prompt: 'Convierte 1 km a m. (Equivalencia: 1 km = 1000 m)', options: ['1000','100','10','2000'], correct: [0] };
}










REGISTRY.types["magnitudes_y_unidades"] = {
  name: "Magnitudes y Unidades",
  templates: [conversion_unidades]
};

REGISTRY.types["introduccion_telefonia"] = {
  name: "Introducci√≥n",
  templates: [magnitudes_electricas_cyb]
};


// --- Banco de magnitudes ---
const magnitudesData = [
  { magnitud: "Tensi√≥n", simbolo: "U o V", unidad: "Voltio" },
  { magnitud: "Intensidad", simbolo: "I", unidad: "Amperio" },
  { magnitud: "Resistencia", simbolo: "R", unidad: "Ohmio" },
  { magnitud: "Capacidad", simbolo: "C", unidad: "Faradio" },
  { magnitud: "Potencia", simbolo: "P", unidad: "Vatio" },
  { magnitud: "Frecuencia", simbolo: "f", unidad: "Hercio" }
];

// --- Variantes posibles ---
const variantes = [
  { dado: "magnitud", preguntar: "simbolo", texto: (e) => `La magnitud "${e.magnitud}" se representa con el s√≠mbolo‚Ä¶` },
  { dado: "magnitud", preguntar: "unidad", texto: (e) => `La magnitud "${e.magnitud}" se mide en‚Ä¶` },
  { dado: "simbolo", preguntar: "magnitud", texto: (e) => `El s√≠mbolo "${e.simbolo}" corresponde a la magnitud‚Ä¶` },
  { dado: "simbolo", preguntar: "unidad", texto: (e) => `El s√≠mbolo "${e.simbolo}" corresponde a la unidad‚Ä¶` },
  { dado: "unidad", preguntar: "magnitud", texto: (e) => `La unidad "${e.unidad}" corresponde a la magnitud‚Ä¶` },
  { dado: "unidad", preguntar: "simbolo", texto: (e) => `La unidad "${e.unidad}" se representa con el s√≠mbolo‚Ä¶` }
];

// --- Mazo global de preguntas √∫nicas ---
let mazoPreguntas = [];

// Generar el mazo completo de preguntas
function generarMazo() {
  const nuevoMazo = [];
  for (const elemento of magnitudesData) {
    for (const v of variantes) {
      nuevoMazo.push({
        elemento,
        variante: v,
        prompt: v.texto(elemento),
        correcta: elemento[v.preguntar],
        preguntar: v.preguntar
      });
    }
  }
  return shuffle(nuevoMazo); // lo barajamos
}

// --- Plantilla ---
function magnitudes_electricas_cyb() {
  if (mazoPreguntas.length === 0) {
    mazoPreguntas = generarMazo();
  }

  // Sacar la siguiente pregunta del mazo
  const { elemento, variante, prompt, correcta, preguntar } = mazoPreguntas.pop();

  // Distractores: valores del mismo campo en otros elementos
  const incorrectas = magnitudesData
    .filter(e => e !== elemento)
    .map(e => e[preguntar]);

  const distractores = shuffle(incorrectas).slice(0, 3);

  const opciones = shuffle([correcta, ...distractores]);

  return {
    mode: "single",
    prompt: prompt,
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["C", "D"],
    repeatable: true
  };
}









function configuracion_electronica(){
  const Z = Math.floor(Math.random() * 50) + 1;
  const elem = ELEMENTOS[Z];
  const pregunta = `¬øCu√°l es la configuraci√≥n electr√≥nica del ${elem.nombre} (Z=${Z})?`;
  const correcta = elem.config;

  const distractores = new Set();

  function generarIncorrecta(){
    const modo = rndInt(1,4);
    let propuesta = "";

    if (modo === 1){
      const partes = correcta.split(" ");
      if (partes.length > 1) propuesta = [...partes].reverse().join(" ");
    } else if (modo === 2){
      let offset = Z + (Math.random() < 0.5 ? -9 : 9);
      if (ELEMENTOS[offset]) propuesta = ELEMENTOS[offset].config;
    } else if (modo === 3){
      propuesta = correcta.replace(/s/g,"p").replace(/p/g,"s");
    } else {
      propuesta = correcta.replace(/p6/,"p7").replace(/d10/,"d11");
    }

    return propuesta;
  }

  while (distractores.size < 3){
    const cand = generarIncorrecta();
    if (cand && cand !== correcta && !distractores.has(cand)){
      distractores.add(cand);
    }
  }

  const opciones = shuffle([correcta, ...distractores]);

  return {
    tema: "Teor√≠a de los electrones",
    modelos: ["C","D"],
    repeatable: true,
    mode: "single",
    prompt: pregunta,
    options: opciones,
    correct: [opciones.indexOf(correcta)]
  };
}

function pregunta_teoria_de_los_electrones_1() {
  let correcta = "Protones y neutrones";
  let incorrectas = [
    "Electrones y protones",
    "Electrones y neutrones",
    "Electrones, protones y neutrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© part√≠culas forman el n√∫cleo at√≥mico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_2() {
  let correcta = "Ligeramente menor que la del neutr√≥n";
  let incorrectas = [
    "Exactamente igual a la del neutr√≥n",
    "Mayor que la del neutr√≥n",
    "La mitad de la del neutr√≥n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del prot√≥n es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_3() {
  let correcta = "Igual en magnitud y de signo contrario";
  let incorrectas = [
    "Mayor en magnitud y del mismo signo",
    "Menor en magnitud y de signo contrario",
    "Igual en magnitud y del mismo signo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La carga del prot√≥n, en comparaci√≥n con la del electr√≥n, es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_4() {
  let correcta = "Aproximadamente 1/1836 de la masa del prot√≥n";
  let incorrectas = [
    "Igual a la masa del prot√≥n",
    "El doble de la masa del prot√≥n",
    "Aproximadamente 1/100 de la masa del prot√≥n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del electr√≥n es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_5() {
  let correcta = "Que el n√∫mero de protones es igual al n√∫mero de electrones";
  let incorrectas = [
    "Que el n√∫mero de protones es igual al n√∫mero de neutrones",
    "Que el n√∫mero de electrones es igual al n√∫mero de neutrones",
    "Que el n√∫mero de protones, electrones y neutrones es siempre el mismo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© significa que un √°tomo est√© en equilibrio?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_6() {
  let correcta = "El n√∫mero cu√°ntico azimutal (l)";
  let incorrectas = [
    "El n√∫mero cu√°ntico principal (n)",
    "El n√∫mero cu√°ntico magn√©tico (m)",
    "El n√∫mero cu√°ntico de esp√≠n (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© n√∫mero cu√°ntico determina la forma del orbital at√≥mico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_7() {
  let correcta = "El n√∫mero cu√°ntico magn√©tico (m)";
  let incorrectas = [
    "El n√∫mero cu√°ntico principal (n)",
    "El n√∫mero cu√°ntico azimutal (l)",
    "El n√∫mero cu√°ntico de esp√≠n (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© n√∫mero cu√°ntico determina la orientaci√≥n del orbital at√≥mico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_8() {
  let correcta = "El nivel de energ√≠a y tama√±o del orbital";
  let incorrectas = [
    "La forma del orbital",
    "La orientaci√≥n espacial del orbital",
    "El esp√≠n del electr√≥n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© describe el n√∫mero cu√°ntico principal (n)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_9() {
  let correcta = "La orientaci√≥n del giro intr√≠nseco del electr√≥n";
  let incorrectas = [
    "La energ√≠a del orbital",
    "La forma del orbital",
    "La orientaci√≥n espacial del orbital"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© indica el n√∫mero cu√°ntico de esp√≠n (s)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_10() {
  let correcta = "2 electrones";
  let incorrectas = [
    "1 electr√≥n",
    "4 electrones",
    "Hasta 8 electrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øCu√°ntos electrones pueden alojarse como m√°ximo en un suborbital?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_11() {
  let correcta = "Cati√≥n";
  let incorrectas = [
    "Ani√≥n",
    "Mol√©cula",
    "Prot√≥n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Cuando un √°tomo pierde un electr√≥n se forma un...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_12() {
  let correcta = "La compartici√≥n de electrones entre √°tomos";
  let incorrectas = [
    "La transferencia completa de electrones", 
    "La atracci√≥n electrost√°tica entre iones", 
    "La presencia de un mar de electrones libres"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© caracteriza al enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_13() {
  let correcta = "Entre no metales";
  let incorrectas = [
    "Entre metales y no metales",
    "Entre metales",
    "Entre gases nobles"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øEntre qu√© tipos de elementos se da un enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_14() {
  let correcta = "La energ√≠a necesaria para introducir un electr√≥n en un √°tomo neutro";
  let incorrectas = [
    "La energ√≠a necesaria para arrancar un electr√≥n de un √°tomo neutro", 
    "La capacidad de un √°tomo para atraer electrones en un enlace qu√≠mico", 
    "La energ√≠a necesaria para separar protones y neutrones en el n√∫cleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© es la afinidad electr√≥nica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_15() {
  let correcta = "Negativa, tienden a ceder electrones, son reductores y se oxidan";
  let incorrectas = [
    "Positiva, tienden a ganar electrones, son oxidantes y se reducen",
    "Negativa, tienden a ganar electrones, son oxidantes y se reducen",
    "Positiva, tienden a ceder electrones, son reductores y se oxidan"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los metales tienen una afinidad electr√≥nica...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_16() {
  let correcta = "En la transferencia completa de electrones entre un metal y un no metal, form√°ndose iones que se atraen por fuerzas electrost√°ticas";
  let incorrectas = [
    "En la compartici√≥n de electrones entre √°tomos no met√°licos",  
    "En la existencia de un mar de electrones libres entre √°tomos met√°licos", 
    "En la atracci√≥n de un n√∫cleo hacia los electrones de otro n√∫cleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øEn qu√© consiste un enlace i√≥nico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_17() {
  let correcta = "Covalente";
  let incorrectas = [
    "I√≥nico",
    "Met√°lico",
    "De Van der Waals"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "El hidr√≥geno molecular (H‚ÇÇ) y el ox√≠geno molecular (O‚ÇÇ) son mol√©culas con enlace...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_18() {
  let correcta = "Son s√≥lidos cristalinos, con altos puntos de fusi√≥n y conductores en disoluci√≥n o fundidos";
  let incorrectas = [
    "Son blandos, con bajos puntos de fusi√≥n y no conducen la electricidad", 
    "Son maleables, d√∫ctiles y buenos conductores en estado s√≥lido", 
    "Son gaseosos en condiciones normales y no forman redes cristalinas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© caracter√≠sticas f√≠sicas presentan los compuestos i√≥nicos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_19() {
  let correcta = "Cationes met√°licos";
  let incorrectas = [
    "Aniones met√°licos",
    "Protones libres",
    "Electrones deslocalizados"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øC√≥mo se denominan los pseudoiones positivos en el enlace met√°lico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_20() {
  let correcta = "El equilibrio entre los cationes met√°licos y los electrones deslocalizados";
  let incorrectas = [
    "La repulsi√≥n entre los electrones deslocalizados", 
    "La atracci√≥n entre protones y neutrones",
    "La alternancia de iones positivos y negativos en una red cristalina"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© mantiene la neutralidad electrost√°tica en el enlace met√°lico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_21() {
  let correcta = "1, 8"; 
  let incorrectas = [
    "2, 6", // ‚ùå Incorrecta
    "3, 7", // ‚ùå Incorrecta
    "4, 2"  // ‚ùå Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los elementos conductores ser√°n aquellos que tienen ... de valencia. Los aislantes ser√°n los que tienen ... electrones en su capa de valencia.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_22() {
  let correcta = "La plata (Ag)";
  let incorrectas = [
    "El cobre (Cu)",   // ‚ùå Incorrecta
    "El oro (Au)",     // ‚ùå Incorrecta
    "El aluminio (Al)" // ‚ùå Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© material es el mejor conductor de la electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_23() {
  let correcta = "Un material puro cuya conductividad depende de la temperatura y no de impurezas a√±adidas";
  let incorrectas = [
    "Un material puro cuya conductividad depende √∫nicamente de impurezas a√±adidas", // ‚ùå Extr√≠nseco
    "Un metal con baja resistividad el√©ctrica",                                    // ‚ùå Incorrecta
    "Un aislante que nunca puede conducir electricidad"                            // ‚ùå Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© es un semiconductor intr√≠nseco?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_24() {
  let correcta = "Tipo P";
  let incorrectas = [
    "Tipo N",   // ‚ùå Incorrecta
    "Tipo NP",  // ‚ùå Incorrecta
    "Intr√≠nseco" // ‚ùå Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Si se a√±ade galio (Ga) a un cristal de silicio (Si), se formar√° un semiconductor...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_25() {
  let correcta = "N"; 
  let incorrectas = [
    "P",            // ‚ùå Aceptoras, grupo III
    "NP",           // ‚ùå
    "Intr√≠nsecas"   // ‚ùå
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Un semiconductor donante est√° dopado con impurezas de tipo...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_26() {
  let correcta = "1,6 √ó 10‚Åª¬π‚Åπ C";
  let incorrectas = [
    "1,6 √ó 10‚Åª¬π‚Å∂ C",
    "9,1 √ó 10‚Åª¬≥¬π C",
    "1,6 √ó 10‚Åª¬≤¬≥ C"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øCu√°l es la carga de un prot√≥n o un electr√≥n en culombios?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_27() {
  let correcta = "La configuraci√≥n electr√≥nica";
  let incorrectas = [
    "El n√∫mero m√°sico",
    "La densidad del n√∫cleo",
    "La masa del neutr√≥n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© determina las propiedades qu√≠micas y el√©ctricas de un elemento?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_28() {
  let correcta = "Los gases nobles";
  let incorrectas = [
    "Los metales alcalinos",
    "Los hal√≥genos",
    "Los lant√°nidos"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© elementos tienen su capa de valencia completa con 8 electrones?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_29() {
  let correcta = "Buscan completar su capa de valencia para lograr estabilidad";
  let incorrectas = [
    "Buscan aumentar el n√∫mero de protones",
    "Buscan reducir el tama√±o del n√∫cleo",
    "Buscan equilibrar neutrones y protones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øPor qu√© los √°tomos forman enlaces qu√≠micos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_30() {
  let correcta = "S√≥lidos: bandas de conducci√≥n y valencia";
  let incorrectas = [
    "L√≠quidos: bandas de conducci√≥n y valencia",
    "Gases: conducci√≥n por bandas",
    "Vac√≠o: conducci√≥n por bandas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "En qu√© estado de la materia la conducci√≥n se explica por el modelo de bandas?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_31() {
  let correcta = "Mediante iones disueltos (electrolitos)";
  let incorrectas = [
    "Mediante protones libres",
    "Mediante neutrones excitados",
    "Mediante electrones en bandas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øC√≥mo conducen la electricidad los l√≠quidos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_32() {
  let correcta = "Cuando se ionizan y forman plasma";
  let incorrectas = [
    "Cuando se enfr√≠an por debajo de 0 ¬∞C",
    "Cuando aumentan su presi√≥n",
    "Cuando sus mol√©culas se solidifican"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øEn qu√© condiciones los gases pueden conducir electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_33() {
  let correcta = "Un aislante ideal";
  let incorrectas = [
    "Un semiconductor natural",
    "Un conductor perfecto",
    "Un plasma estable"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øC√≥mo se comporta el vac√≠o respecto a la conducci√≥n el√©ctrica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_teoria_de_los_electrones_34() {
  let correcta = "Vidrio, aire, pl√°sticos, madera";
  let incorrectas = [
    "Cobre, oro, plata",
    "Silicio, germanio",
    "Sodio, cloro, litio"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øCu√°les de los siguientes materiales son aislantes?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_1() {
  let correcta = "Los aislantes se cargan con facilidad"; 
  let incorrectas = [
    "Los conductores se cargan f√°cilmente", 
    "Ninguno de ellos se carga con facilidad", 
    "Ambos (aislantes y conductores) se cargan igual de f√°cil"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© tipo de material se carga m√°s f√°cilmente con electricidad est√°tica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_2() {
  let correcta = "Con la balanza de torsi√≥n"; 
  let incorrectas = [
    "Con el electr√≥foro", 
    "Con la m√°quina de Wimshurst", 
    "Con el electroscopio"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øCon qu√© dispositivo determin√≥ Coulomb su ley?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_3() {
  let correcta = "Se repelen si son del mismo signo y se atraen si son de distinto signo"; 
  let incorrectas = [
    "Se atraen si son del mismo signo y se repelen si son de distinto signo", 
    "Siempre se atraen independientemente del signo", 
    "Siempre se repelen independientemente del signo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© ocurre entre dos cargas el√©ctricas seg√∫n su signo?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_4() {
  let correcta = "El vac√≠o"; 
  let incorrectas = [
    "El aire", 
    "El agua destilada", 
    "El vidrio"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "¬øQu√© medio tiene la permitividad el√©ctrica m√°s peque√±a?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_5() {
  const correcta = "No suelen ser superconductores";
  const incorrectas = [
    "Siempre son superconductores",
    "Son superconductores solo a altas temperaturas",
    "Son superconductores solo en presencia de un campo magn√©tico"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "Los materiales ferromagn√©ticos ¬øsuelen ser superconductores?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_electricidad_estatica_6() {
  const correcta = "El statcoulomb (esu de carga)";
  const incorrectas = [
    "El coulomb",
    "El faradio",
    "El weber"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La unidad de carga en el sistema CGS es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_7() {
  const correcta = "La intensidad de campo gravitatorio (g)";
  const incorrectas = [
    "La energ√≠a potencial gravitatoria",
    "La aceleraci√≥n centr√≠peta",
    "La constante de gravitaci√≥n universal"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øQu√© magnitud de un campo gravitatorio es an√°loga a la intensidad de campo electrost√°tico E?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_electricidad_estatica_8() {
  const correcta = "La conductividad el√©ctrica";
  const incorrectas = [
    "La resistividad el√©ctrica",
    "La permitividad el√©ctrica",
    "La permeabilidad magn√©tica"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La ... es la capacidad de una sustancia a permitir el paso de corriente el√©ctrica a trav√©s suya.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_9() {
  const correcta = "La conductividad el√©ctrica";
  const incorrectas = [
    "La resistividad el√©ctrica",
    "La permitividad el√©ctrica",
    "La permeabilidad magn√©tica"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La ... es la capacidad de una sustancia a permitir el paso de corriente el√©ctrica a trav√©s suya.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_10() {
  const correcta = "De la naturaleza del material y de la temperatura";
  const incorrectas = [
    "√önicamente de la temperatura",
    "√önicamente de la presi√≥n",
    "Solo del n√∫mero de protones del √°tomo"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øDe qu√© depende la conductividad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_11() {
  const correcta = "La banda prohibida (gap energ√©tico)";
  const incorrectas = [
    "La banda activa",
    "La banda de conducci√≥n",
    "La banda de valencia"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øLa banda ... se encuentra entre las de conducci√≥n y valencia?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_12() {
  const correcta = "Del orden de 5 eV o m√°s";
  const incorrectas = [
    "Del orden de 0.1 eV",
    "Del orden de 1 eV",
    "Del orden de 10‚Åª¬≥ eV"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "La energ√≠a de gap de un aislante es del orden de ...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_13() {
  const correcta = "Se solapan";
  const incorrectas = [
    "Est√°n separadas por un gran gap",
    "Est√°n separadas por un peque√±o gap",
    "Son id√©nticas pero no se tocan"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "En un metal, ¬øc√≥mo se encuentran las bandas de conducci√≥n y valencia?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_14() {
  const correcta = "Cae bruscamente a cero";
  const incorrectas = [
    "Aumenta ligeramente",
    "Se mantiene constante",
    "Tiende a infinito"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øQu√© le sucede a la resistividad de un superconductor cuando alcanza su temperatura cr√≠tica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_15() {
  const correcta = "Un plasma";
  const incorrectas = [
    "Un condensado",
    "Un superconductor",
    "Un diel√©ctrico perfecto"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "Los gases se ionizan formando...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_16() {
  const correcta = "Por radiaci√≥n, por colisi√≥n y por efecto termoi√≥nico";
  const incorrectas = [
    "Por conducci√≥n, por inducci√≥n y por resonancia",
    "Por fricci√≥n, por conducci√≥n y por radiaci√≥n",
    "Por presi√≥n, por temperatura y por inducci√≥n"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øDe qu√© tres formas se puede ionizar un gas?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_17() {
  const correcta = "Es un estado de agregaci√≥n parecido al gas, pero formado por part√≠culas sensibles a campos el√©ctricos y magn√©ticos";
  const incorrectas = [
    "Es un gas perfecto compuesto √∫nicamente por mol√©culas neutras",
    "Es un l√≠quido conductor con alta viscosidad",
    "Es un s√≥lido formado por cargas fijas en equilibrio"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øQu√© es el plasma?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_18() {
  const correcta = "Por la fricci√≥n entre el combustible y los conductos";
  const incorrectas = [
    "Por la radiaci√≥n solar directa",
    "Por la acumulaci√≥n de hielo en las alas",
    "Por el campo magn√©tico terrestre"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "En una aeronave, ¬øc√≥mo suele generarse la electricidad est√°tica que representa un riesgo?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_19() {
  const correcta = "Provocar una chispa que inicie un incendio o explosi√≥n";
  const incorrectas = [
    "Reducir la velocidad del avi√≥n",
    "Desviar las l√≠neas de campo magn√©tico",
    "Incrementar la presi√≥n en cabina"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øCu√°l es el principal peligro de la electricidad est√°tica durante el repostaje de una aeronave?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_20() {
  const correcta = "Puesta a tierra de la aeronave durante el repostaje";
  const incorrectas = [
    "Rociar agua sobre la aeronave",
    "Reducir la temperatura del combustible",
    "Apagar todos los equipos electr√≥nicos"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øQu√© medida preventiva se utiliza para evitar descargas electrost√°ticas peligrosas en aviaci√≥n?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_21() {
  const correcta = "La presencia de √°cidos o sales disueltos que se disocian en iones";
  const incorrectas = [
    "La ausencia de ox√≠geno en el l√≠quido",
    "La densidad del l√≠quido sin importar su composici√≥n",
    "El color del l√≠quido"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øDe qu√© depende la conductividad el√©ctrica en los l√≠quidos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_22() {
  const correcta = "El efecto termoi√≥nico";
  const incorrectas = [
    "La ionizaci√≥n por presi√≥n",
    "El efecto fotoel√©ctrico en s√≥lidos",
    "El magnetismo inducido"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øQu√© fen√≥meno permite que el vac√≠o pueda volverse conductor en ciertas condiciones?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_23() {
  const correcta = "√Åcido sulf√∫rico con agua en bater√≠as de automoci√≥n y aviaci√≥n ligera";
  const incorrectas = [
    "Agua destilada en cualquier bater√≠a",
    "Mercurio l√≠quido en aviones comerciales",
    "Alcohol et√≠lico disuelto en agua"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øQu√© electrolito se utiliza en las bater√≠as de automoci√≥n y aviaci√≥n ligera para conducir electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

function pregunta_electricidad_estatica_24() {
  const correcta = "Agua con hidr√≥xido pot√°sico en aviones comerciales";
  const incorrectas = [
    "Agua con √°cido sulf√∫rico en aviones comerciales",
    "Agua con sal com√∫n en cualquier bater√≠a",
    "Aceite diel√©ctrico como medio conductor"
  ];

  const opciones = shuffle([correcta, ...incorrectas]);

  return {
    mode: "single",
    prompt: "¬øQu√© electrolito utilizan las bater√≠as de aviones comerciales para su funcionamiento?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}






const K = 9e9; // Constante de Coulomb



function formatSci(value, digits = 2) {
  if (!isFinite(value)) return 'NaN';
  if (value === 0) return '0';
  const sign = value < 0 ? '-' : '';
  let mant = Math.abs(value);
  let exp = Math.floor(Math.log10(mant));
  mant /= Math.pow(10, exp);
  mant = parseFloat(mant.toPrecision(digits));
  if (mant >= 10) {
    mant /= 10;
    exp += 1;
  }
  let mantStr = mant.toString();
  if (mantStr.includes('.')) {
    mantStr = mantStr.replace(/0+$/, '').replace(/\.$/, '');
  }
  return `${sign}${mantStr} √ó 10^${exp}`;
}

function formatValue(value, digits = 2) {
  if (!isFinite(value)) return 'NaN';
  const abs = Math.abs(value);
  if (abs === 0) return '0';
  if (abs >= 1e3 || abs < 1e-2) {
    return formatSci(value, digits);
  }
  const str = value.toFixed(digits);
  return str.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1').replace(/-0$/, '0');
}

function formatWithUnit(value, unit, digits = 2) {
  const core = formatValue(value, digits);
  return unit ? `${core} ${unit}` : core;
}

function formatCharge(value, digits = 2) {
  if (!isFinite(value)) return 'NaN';
  if (value === 0) return '0 C';
  const abs = Math.abs(value);
  if (abs < 1e-9) {
    const scaled = value / 1e-12;
    return `${formatValue(scaled, digits)} pC`;
  }
  if (abs < 1e-5) {
    const scaled = value / 1e-6;
    return `${formatValue(scaled, digits)} ŒºC`;
  }
  return formatWithUnit(value, 'C', digits);
}

function formatDistance(valueMeters, digits = 2) {
  const mm = valueMeters * 1000;
  return `${formatValue(mm, digits)} mm`;
}

function randomCharge() {
  const sign = Math.random() < 0.5 ? -1 : 1;
  if (Math.random() < 0.15) {
    const magnitudeMicro = (0.2 + Math.random() * 0.6) * 1e-6;
    return sign * magnitudeMicro;
  }
  const magnitudePico = (50 + Math.random() * 950) * 1e-12;
  return sign * magnitudePico;
}

function generarOpciones(correcto, digits = 2) {
  const opciones = [correcto];
  const formatos = new Set([formatValue(correcto, digits)]);
  const maxIntentosAleatorios = 80;
  let intentos = 0;

  while (opciones.length < 4 && intentos < maxIntentosAleatorios) {
    intentos++;
    const factor = 1 + (Math.random() - 0.5) * 0.8;
    const candidato = Number((correcto * factor).toPrecision(digits));
    const representacion = formatValue(candidato, digits);
    if (!formatos.has(representacion)) {
      opciones.push(candidato);
      formatos.add(representacion);
    }
  }

  if (opciones.length < 4) {
    const baseAbs = Math.abs(correcto) || 1;
    let paso = Math.pow(10, Math.floor(Math.log10(baseAbs)) - (digits - 1));
    if (!isFinite(paso) || paso === 0) paso = Math.pow(10, -digits);

    while (opciones.length < 4) {
      const signo = opciones.length % 2 === 0 ? 1 : -1;
      const candidato = correcto + signo * paso;
      const representacion = formatValue(candidato, digits);
      paso *= 1.5;
      if (!formatos.has(representacion)) {
        opciones.push(candidato);
        formatos.add(representacion);
      }
    }
  }

  return shuffle(opciones);
}

// ---------- Fuerza el√©ctrica ----------
function pregunta_fuerza_electrica_generica() {
  const q1 = randomCharge();
  const q2 = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const F = K * Math.abs(q1 * q2) / (r ** 2);
  const incognita = ['F', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'F') {
    correcto = F;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales de q‚ÇÅ = ${formatCharge(q1)} y q‚ÇÇ = ${formatCharge(q2)} est√°n separadas por ${formatDistance(r)}.
¬øCu√°l es la magnitud de la fuerza el√©ctrica entre ellas?`;
    formatFn = (val) => formatWithUnit(val, 'N');
  } else if (incognita === 'q') {
    correcto = q1;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales est√°n separadas por ${formatDistance(r)} y ejercen una fuerza el√©ctrica de F = ${formatSci(F)} N.
Si una de ellas vale q‚ÇÇ = ${formatCharge(q2)}, ¬øcu√°l es la otra carga?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales de q‚ÇÅ = ${formatCharge(q1)} y q‚ÇÇ = ${formatCharge(q2)} ejercen una fuerza de F = ${formatSci(F)} N.
¬øCu√°l es la distancia que las separa?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// ---------- Campo el√©ctrico ----------
function pregunta_campo_electrico_generica() {
  const q = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const E = K * Math.abs(q) / (r ** 2);
  const incognita = ['E', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'E') {
    correcto = E;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} genera un campo el√©ctrico a una distancia de ${formatDistance(r)}.
¬øCu√°l es la intensidad del campo el√©ctrico en ese punto?`;
    formatFn = (val) => formatWithUnit(val, 'N/C');
  } else if (incognita === 'q') {
    correcto = q;
    opciones = generarOpciones(correcto);
    prompt = `En un punto situado a ${formatDistance(r)} se mide un campo el√©ctrico de E = ${formatSci(E)} N/C.
¬øCu√°l es la carga que lo produce?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} produce un campo el√©ctrico de E = ${formatSci(E)} N/C en un punto.
¬øA qu√© distancia se encuentra dicho punto de la carga?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// ---------- Potencial el√©ctrico ----------
function pregunta_potencial_electrico_generica() {
  const q = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const V = K * q / r;
  const incognita = ['V', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'V') {
    correcto = V;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} se encuentra a ${formatDistance(r)} de un punto.
¬øCu√°l es el potencial el√©ctrico en ese punto?`;
    formatFn = (val) => formatWithUnit(val, 'V');
  } else if (incognita === 'q') {
    correcto = q;
    opciones = generarOpciones(correcto);
    prompt = `En un punto situado a ${formatDistance(r)} se mide un potencial de V = ${formatSci(V)} V.
¬øCu√°l es el valor de la carga que lo produce?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Una carga puntual de q = ${formatCharge(q)} produce un potencial de V = ${formatSci(V)} V en un punto.
¬øA qu√© distancia se encuentra dicho punto de la carga?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// ---------- Energ√≠a potencial el√©ctrica ----------
function pregunta_energia_potencial_generica() {
  const q1 = randomCharge();
  const q2 = randomCharge();
  const rMm = rndInt(20, 300);
  const r = rMm / 1000;

  const U = K * q1 * q2 / r;
  const incognita = ['U', 'q', 'r'][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === 'U') {
    correcto = U;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas puntuales de q‚ÇÅ = ${formatCharge(q1)} y q‚ÇÇ = ${formatCharge(q2)} est√°n separadas por ${formatDistance(r)}.
¬øCu√°l es la energ√≠a potencial el√©ctrica del sistema?`;
    formatFn = (val) => formatWithUnit(val, 'J');
  } else if (incognita === 'q') {
    correcto = q1;
    opciones = generarOpciones(correcto);
    prompt = `Un sistema de dos cargas tiene una energ√≠a potencial de U = ${formatSci(U)} J, con una de las cargas conocida q‚ÇÇ = ${formatCharge(q2)} y separaci√≥n ${formatDistance(r)}.
¬øCu√°l es el valor de la otra carga?`;
    formatFn = formatCharge;
  } else {
    correcto = r;
    opciones = generarOpciones(correcto);
    prompt = `Dos cargas de q‚ÇÅ = ${formatCharge(q1)} y q‚ÇÇ = ${formatCharge(q2)} tienen una energ√≠a potencial de U = ${formatSci(U)} J.
¬øCu√°l es la distancia que las separa?`;
    formatFn = formatDistance;
  }

  return {
    mode: 'single',
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ['B','D'],
    repeatable: true
  };
}

// Genera carga aleatoria en picocoulombios (con signo)
function randomChargePicoC() {
  const sign = Math.random() < 0.5 ? -1 : 1;
  const magnitudePico = rndInt(50, 950); // entre 50 y 950 pC
  return sign * magnitudePico * 1e-12;   // convertido a C
}

function formatChargePicoC(value) {
  const pico = value / 1e-12;
  return `${pico.toFixed(0)} pC`;
}

function formatDistanceMm(valueMeters) {
  const mm = valueMeters * 1000;
  return `${formatValue(mm)} mm`;
}

// ---------- Trabajo el√©ctrico (q¬∑ŒîV) ----------
function pregunta_electricidad_estatica_25() {
  const q = randomChargePicoC(); // C
  const deltaV = rndInt(50, 500); // V
  const W = q * deltaV; // J

  const incognita = ["W", "q", "V"][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === "W") {
    correcto = W;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} se desplaza entre dos puntos con ŒîV = ${deltaV} V.
¬øCu√°l es el trabajo realizado por el campo el√©ctrico?`;
    formatFn = (val) => formatWithUnit(val, "J");
  } else if (incognita === "q") {
    correcto = q;
    opciones = generarOpciones(correcto);
    prompt = `Se realiza un trabajo de W = ${formatSci(W)} J al mover una carga entre dos puntos con ŒîV = ${deltaV} V.
¬øCu√°l es el valor de la carga?`;
    formatFn = formatChargePicoC;
  } else {
    correcto = deltaV;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} requiere un trabajo de W = ${formatSci(W)} J para trasladarse entre dos puntos.
¬øCu√°l es la diferencia de potencial entre dichos puntos?`;
    formatFn = (val) => formatWithUnit(val, "V");
  }

  return {
    mode: "single",
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ["B","D"],
    repeatable: true
  };
}

// ---------- Trabajo el√©ctrico (q¬∑E¬∑d) ----------
function pregunta_electricidad_estatica_26() {
  const q = randomChargePicoC();
  const E = rndInt(200, 800); // N/C
  const d = rndInt(10, 50) / 1000; // 10‚Äì50 mm en metros
  const W = q * E * d;

  const incognita = ["W", "d", "E"][Math.floor(Math.random() * 3)];
  let prompt, correcto, opciones, formatFn;

  if (incognita === "W") {
    correcto = W;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} se mueve en un campo el√©ctrico de E = ${E} N/C recorriendo una distancia de ${formatDistanceMm(d)}.
¬øCu√°l es el trabajo realizado por el campo el√©ctrico?`;
    formatFn = (val) => formatWithUnit(val, "J");
  } else if (incognita === "d") {
    correcto = d;
    opciones = generarOpciones(correcto);
    prompt = `En un campo el√©ctrico de E = ${E} N/C se realiza un trabajo de W = ${formatSci(W)} J al mover una carga de q = ${formatChargePicoC(q)}.
¬øCu√°l fue la distancia recorrida?`;
    formatFn = (val) => formatDistanceMm(val);
  } else {
    correcto = E;
    opciones = generarOpciones(correcto);
    prompt = `Una carga de q = ${formatChargePicoC(q)} recorre una distancia de ${formatDistanceMm(d)} y el trabajo realizado es W = ${formatSci(W)} J.
¬øCu√°l era la intensidad del campo el√©ctrico?`;
    formatFn = (val) => formatWithUnit(val, "N/C");
  }

  return {
    mode: "single",
    prompt,
    options: opciones.map(formatFn),
    correct: [opciones.indexOf(correcto)],
    modelos: ["B","D"],
    repeatable: true
  };
}






















</script>


</script>
</body>
</html>










