<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Atenea â€” prototipo</title>
  <style>
    :root { --pad:16px; --radius:16px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#0f172a; color:#e5e7eb;}
    header { padding:24px var(--pad); background:#111827; border-bottom:1px solid #1f2937;}
    h1 { margin:0 0 6px; font-size:24px; font-weight:500;}
    .sub { color:#9ca3af; font-size:18px;}
    main { max-width:900px; margin: 0 auto; padding: 24px var(--pad) 80px;}
    .card { background:#111827; border:1px solid #1f2937; border-radius:var(--radius); padding: 18px; box-shadow:0 10px 25px rgba(0,0,0,.25);}
    .row { display:grid; gap:12px; }
    @media (min-width: 720px){ .row-3 { grid-template-columns: repeat(3, 1fr);} .row-2 { grid-template-columns: repeat(2, 1fr);} }
    label { font-size:18px; color:#cbd5e1; }
    select, input[type="number"], button, .pill {
      width:100%; background:#0b1220; color:#e5e7eb; border:1px solid #1f2937;
      padding:10px 12px; border-radius:12px; outline:none;
    }
    button { cursor:pointer; font-weight:400; }
    button.primary { background:#2563eb; border-color:#2563eb; }
    button.ghost { background:#0b1220; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .prompt { font-size:24px; line-height:1.5; margin: 8px 0 14px; color:#f3f4f6;}
    .opts { display:grid; gap:10px; }
    .opt { font-size:22px;  text-align:left; padding:12px; border-radius:12px; border:1px solid #1f2937; background:#0b1220; cursor:pointer; }
    .opt.correct { border-color:#16a34a; background:#0b1f14; }
    .opt.wrong   { border-color:#dc2626; background:#1a0b0b; }
    .muted { color:#9ca3af; font-size:15px; }
    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#0b1220; border:1px solid #1f2937; color:#cbd5e1; font-size:14px; }
    .spacer { height:8px; }
    .footer { position:fixed; left:0; right:0; bottom:0; padding:10px var(--pad); background:#0b1220; border-top:1px solid #1f2937; display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .score { font-weight:500; }
    .explain { margin-top:10px; color:#d1d5db; font-size:18px; }
    .hide { display:none; }
    .selected {
      border-color:#2563eb;
      background:#1e3a8a;
    }
  </style>
</head>
<body>

<main>
  <section id="panel-config" class="card">
    

  
  <!-- ðŸ”¹ PASO 1: CURSO ACADÃ‰MICO -->
  <div class="row row-2">
    <div>
      <label for="curso">Curso acadÃ©mico</label>
      <select id="curso">
        <option value="">-- Selecciona curso --</option>
        <option value="Promocion_XXXIV_STP">PromociÃ³n XXXIV STP</option>
        <option value="Promocion_XXXV_STP">PromociÃ³n XXXV STP</option>
        <option value="Promocion_XXXVI_STP">PromociÃ³n XXXVI STP</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
<!-- ðŸ”¹ NUEVO BLOQUE DE SELECCIÃ“N EN CASCADA -->
  <div class="row row-3" id="fila-eat">
  <div id="bloque-esp" class="hide">
    <label for="especialidad">Especialidad</label>
    <select id="especialidad">
      <option value="">-- Selecciona especialidad --</option>
      <option value="GENERAL">GENERAL</option>
      <option value="CAE">CAE</option>
      <option value="CYB">CYB</option>
      <option value="MER">MER</option>
      <option value="ELC">ELC</option>
      <option value="AYF">AYF</option>
      <option value="PAO">PAO</option>
    </select>
  </div>
  <div id="bloque-asig" class="hide">
    <label for="asignatura">Asignatura</label>
    <select id="asignatura" disabled>
      <option value="">-- Selecciona asignatura --</option>
    </select>
  </div>
  <div id="bloque-tema" class="hide">
    <label for="tema">Tema</label>
    <select id="tema" disabled>
      <option value="">-- Selecciona tema --</option>
    </select>
  </div>
</div>

  <div class="spacer"></div>
  <!-- ðŸ”¹ FIN DEL BLOQUE NUEVO -->
    <div class="row row-1 hide">
  <div>
    <label for="modo">Modo de juego</label>
    <select id="modo">
  <option value="">-- Selecciona modo de juego --</option>
  <option value="estandar">EstÃ¡ndar (30 preguntas, revisiÃ³n final)</option>
  <option value="contrarreloj">Contrarreloj (vidas + tiempo)</option>
  <option value="vidas">Por vidas (explicaciones + vidas)</option>
</select>

  </div>
</div>

  <div class="spacer"></div>
  <!-- ðŸ”¹ PASO FINAL: MODELO -->
  <div class="spacer"></div>
  <div class="row row-1 hide">
    <div>
      <label for="modelo">Modelo</label>
      <select id="modelo">
        <option value="">-- Selecciona --</option>
        <option value="A">Modelo A â€” Daypo</option>
        <option value="B">Modelo B â€” Libro</option>
        <option value="C">Modelo C â€” Diario de la gente</option>
        <option value="D">Modelo D â€” Todo</option>
        <option value="E">Modelo E â€” SelecciÃ³n por grupos</option>
      </select>
    </div>
  </div>
  <div class="spacer"></div>
  <div id="opcionesModelo" class="card hide"></div>
  <div class="spacer"></div>

  <div class="row row-2">
    <button id="start" class="primary" disabled>Empezar</button>
  </div>

  </section> <!-- ðŸ”¸ CIERRE correcto de #panel-config -->

<section id="panel-test" class="card hide">
  <div class="muted" id="meta"></div>
  <div class="prompt" id="prompt"></div>
  <div id="options" class="opts"></div>
  <div id="explain" class="explain hide"></div>
</section>

<section id="panel-result" class="card hide">
  <h3>Resumen</h3>
  <p class="muted" id="summary"></p>
  <div class="spacer"></div>
  <div class="row row-2">
    <button id="retry" class="primary">Repetir con mismos ajustes</button>
    <button id="home" class="ghost">Volver al inicio</button>
  </div>
</section>

</main>

<footer class="footer">
  <div style="display:flex; gap:12px; align-items:center;">
    <span class="badge" id="modeBadge">â€”</span>
    <span id="lives" class="muted"></span>
    <span id="timer" class="muted"></span>
  </div>
  <div class="score" id="score">0 / 0</div>
  <div style="display:flex; gap:8px;">
    <button id="check" class="ghost">Comprobar</button>
    <button id="next" class="primary" disabled>Siguiente</button>
  </div>
</footer>


<script>
/* ==========================================================
   SUPERTEST â€” MOTOR BÃSICO LIMPIO
========================================================== */

const rndInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

const REGISTRY = { types: {} };

/* ========== TIPO: CONSTITUCIÃ“N (ejemplo) ========== */
// constitucion.js - TODAS LAS PLANTILLAS TRADUCIDAS DESDE Constitucion_prime.py

(function registerAritmetica() {

  function suma_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a + b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "AritmÃ©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `Â¿CuÃ¡nto es ${a} + ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function multiplicacion_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    const correct = parseFloat((a * b).toFixed(2)); // hasta 2 decimales

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        let valor = correct + delta;
        // Mantener formato si el correcto tiene decimales
        if (String(correct).includes(".")) {
          valor = parseFloat(valor.toFixed(2));
        }
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "AritmÃ©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `Â¿CuÃ¡nto es ${a} Ã— ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function resta_basica() {
    const a = rndInt(1, 1000);
    const b = rndInt(1, 1000);
    const correct = a - b;

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = rndInt(-9, 9);
          if (delta === 0) continue;
        } else {
          delta = Math.random() < 0.5 ? -10 : 10;
        }
        const valor = correct + delta;
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "AritmÃ©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `Â¿CuÃ¡nto es ${a} - ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  function division_basica() {
    let a, b;
    const tipo = rndInt(1, 3);

    function generarNumero(baseMin, baseMax) {
      let num = rndInt(baseMin, baseMax);
      const r = Math.random();
      if (r < 0.7) {
        num = parseFloat((num + Math.random()).toFixed(1)); // 1 decimal
      } else {
        num = parseFloat((num + Math.random()).toFixed(2)); // 2 decimales
      }
      return num;
    }

    if (tipo === 1) {
      a = generarNumero(1, 9);
      b = generarNumero(1, 9);
    } else if (tipo === 2) {
      if (Math.random() < 0.5) {
        a = generarNumero(2, 9);
        b = generarNumero(10, 99);
      } else {
        a = generarNumero(10, 99);
        b = generarNumero(2, 9);
      }
    } else {
      a = generarNumero(10, 99);
      b = generarNumero(10, 99);
    }

    if (b === 0) b = 1; // salvaguarda (no deberÃ­a ocurrir con los rangos)

    const correct = parseFloat((a / b).toFixed(2));

    function generarDistractores(correct) {
      const distractores = new Set();
      while (distractores.size < 3) {
        let delta;
        if (Math.random() < 0.8) {
          delta = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 3); // Â± hasta 3
        } else {
          delta = (Math.random() < 0.5 ? -1 : 1) * 5; // saltos grandes
        }
        let valor = correct + delta;
        valor = parseFloat(valor.toFixed(2));
        if (valor !== correct && !distractores.has(valor)) {
          distractores.add(valor);
        }
      }
      return Array.from(distractores);
    }

    const opcionesNum = shuffle([correct, ...generarDistractores(correct)]);
    const opciones = opcionesNum.map(String);
    const correctIdx = opciones.indexOf(String(correct));

    return {
      tema: "AritmÃ©tica",
      modelos: ["B", "D"],
      repeatable: true,
      mode: "single",
      prompt: `Â¿CuÃ¡nto es ${a} Ã· ${b}?`,
      options: opciones,
      correct: [correctIdx]
    };
  }

  REGISTRY.types["matematicas_aritmetica"] = {
    name: "AritmÃ©tica",
    templates: [suma_basica, resta_basica, multiplicacion_basica, division_basica]
  };

})();






REGISTRY.types['teoria_electrones'] = { name: 'TeorÃ­a de los electrones', templates: [configuracion_electronica,pregunta_teoria_de_los_electrones_1,pregunta_teoria_de_los_electrones_2,pregunta_teoria_de_los_electrones_3,pregunta_teoria_de_los_electrones_4,pregunta_teoria_de_los_electrones_5,pregunta_teoria_de_los_electrones_6,pregunta_teoria_de_los_electrones_7,pregunta_teoria_de_los_electrones_8,pregunta_teoria_de_los_electrones_9,pregunta_teoria_de_los_electrones_10,pregunta_teoria_de_los_electrones_11,pregunta_teoria_de_los_electrones_12,pregunta_teoria_de_los_electrones_13,pregunta_teoria_de_los_electrones_14,pregunta_teoria_de_los_electrones_15,pregunta_teoria_de_los_electrones_16,pregunta_teoria_de_los_electrones_17,pregunta_teoria_de_los_electrones_18,pregunta_teoria_de_los_electrones_19,pregunta_teoria_de_los_electrones_20,pregunta_teoria_de_los_electrones_21,pregunta_teoria_de_los_electrones_22,pregunta_teoria_de_los_electrones_23,pregunta_teoria_de_los_electrones_24,pregunta_teoria_de_los_electrones_25]};
REGISTRY.types['electricidad_estatica'] = { name: 'Electricidad estÃ¡tica y conducciÃ³n', templates: [(typeof pregunta_electricidad_estatica_1 !== 'undefined' ? pregunta_electricidad_estatica_1 : null),(typeof pregunta_electricidad_estatica_2 !== 'undefined' ? pregunta_electricidad_estatica_2 : null),(typeof pregunta_electricidad_estatica_3 !== 'undefined' ? pregunta_electricidad_estatica_3 : null),(typeof pregunta_electricidad_estatica_4 !== 'undefined' ? pregunta_electricidad_estatica_4 : null),(typeof pregunta_electricidad_estatica_5 !== 'undefined' ? pregunta_electricidad_estatica_5 : null),(typeof pregunta_electricidad_estatica_6 !== 'undefined' ? pregunta_electricidad_estatica_6 : null),(typeof pregunta_electricidad_estatica_7 !== 'undefined' ? pregunta_electricidad_estatica_7 : null),(typeof pregunta_electricidad_estatica_8 !== 'undefined' ? pregunta_electricidad_estatica_8 : null),(typeof pregunta_electricidad_estatica_9 !== 'undefined' ? pregunta_electricidad_estatica_9 : null),(typeof pregunta_electricidad_estatica_10 !== 'undefined' ? pregunta_electricidad_estatica_10 : null),(typeof pregunta_electricidad_estatica_11 !== 'undefined' ? pregunta_electricidad_estatica_11 : null),(typeof pregunta_electricidad_estatica_12 !== 'undefined' ? pregunta_electricidad_estatica_12 : null),(typeof pregunta_electricidad_estatica_13 !== 'undefined' ? pregunta_electricidad_estatica_13 : null),(typeof pregunta_electricidad_estatica_14 !== 'undefined' ? pregunta_electricidad_estatica_14 : null),(typeof pregunta_electricidad_estatica_15 !== 'undefined' ? pregunta_electricidad_estatica_15 : null),(typeof pregunta_electricidad_estatica_16 !== 'undefined' ? pregunta_electricidad_estatica_16 : null),(typeof pregunta_electricidad_estatica_17 !== 'undefined' ? pregunta_electricidad_estatica_17 : null),(typeof pregunta_electricidad_estatica_18 !== 'undefined' ? pregunta_electricidad_estatica_18 : null),(typeof pregunta_electricidad_estatica_19 !== 'undefined' ? pregunta_electricidad_estatica_19 : null),(typeof pregunta_electricidad_estatica_20 !== 'undefined' ? pregunta_electricidad_estatica_20 : null),(typeof pregunta_electricidad_estatica_21 !== 'undefined' ? pregunta_electricidad_estatica_21 : null),(typeof pregunta_electricidad_estatica_22 !== 'undefined' ? pregunta_electricidad_estatica_22 : null),(typeof pregunta_electricidad_estatica_23 !== 'undefined' ? pregunta_electricidad_estatica_23 : null),(typeof pregunta_electricidad_estatica_24 !== 'undefined' ? pregunta_electricidad_estatica_24 : null),(typeof pregunta_electricidad_estatica_25 !== 'undefined' ? pregunta_electricidad_estatica_25 : null),(typeof generarPreguntaCoulomb !== 'undefined' ? generarPreguntaCoulomb : null)].filter(Boolean)};

(function registerEOFAS(){
  function eofas_1(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DirecciÃ³n General de PolÃ­tica de Defensa le corresponde:",
    options: [
      "Elaborar las lineas generales de las directrices generales de polÃ­tica de defensa para la participaciÃ³n de otros Departamentos Ministeriales en la Defensa nacional",
      "Ejercer la notarÃ­a militar",
      "Establecer la aplicaciÃ³n de los planes de calidad de vida del personal militar.",
      "Gestionar la ordenaciÃ³n farmacÃ©utica"
    ],
    correct: [0] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_2(){
  const base = [
    "El CIFAS estÃ¡ integrado en el EMACOM",
    "El MOPS estÃ¡ integrado en el Cuartel General del EMAD",
    "El EMACON es el Ã³rgano auxiliar de mando del JEMAD",
    "__META__" // se convertirÃ¡ en "A y C son correctas."
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar Ã­ndices de las opciones que la meta debe referenciar
  const idxCIFAS = barajadas.indexOf("El CIFAS estÃ¡ integrado en el EMACOM");
  const idxEMACON = barajadas.indexOf("El EMACON es el Ã³rgano auxiliar de mando del JEMAD");

  // Reescribir la opciÃ³n meta con las letras reales
  barajadas[idxMeta] = `${letra(idxCIFAS)}) y ${letra(idxEMACON)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta correcta",
    options: barajadas,
    correct: [2] // âš ï¸ cÃ¡mbialo segÃºn cuÃ¡l/es la correcta
  };
}



function eofas_3(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Como Ã³rgano de asesoramiento y asistencia inmediata, el Ministro de Defensa cuenta con:",
    options: [
      "La DirecciÃ³n General de PolÃ­tica de Defensa",
      "La Oficina de ComunicaciÃ³n de la Defensa",
      "El Consejo Superior de los EjÃ©rcitos.",
      "Un Gabinete TÃ©cnico"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_4(){
  const base = [
    "Dirigir el Plan de Diplomacia de Defensa",
    "Elaborar y proponer disposiciones en materia de retribuciones militares",
    "__META__", // se convertirÃ¡ en "a) y b) son correctas."
    "El asesoramiento sobre los aspectos relacionados con el estudio, planeamiento y desarrollo de las actividades de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los Ã­ndices de las dos opciones que la meta debe referenciar
  const idxDiplomacia = barajadas.indexOf("Dirigir el Plan de Diplomacia de Defensa");
  const idxRetribuciones = barajadas.indexOf("Elaborar y proponer disposiciones en materia de retribuciones militares");

  // Reescribir la opciÃ³n meta con las letras reales
  barajadas[idxMeta] = `${letra(idxDiplomacia)}) y ${letra(idxRetribuciones)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la SecretarÃ­a General de PolÃ­tica de Defensa le corresponde:",
    options: barajadas,
    correct: [0] // âš ï¸ cÃ¡mbialo segÃºn cuÃ¡l/es la correcta
  };
}



function eofas_5(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de dirigir la elaboraciÃ³n de los tratados internacionales que afecten a la Defensa es:",
    options: [
      "La SEDEF",
      "La DIGENPER",
      "La SUBDEF.",
      "La SecretarÃ­a General de PolÃ­tica de Defensa"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_6(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: [
      "Garantizar la seguridad criptogrÃ¡fica",
      "La funciÃ³n de asesoramiento militar al Presidente del Gobierno",
      "Coordinar el Plan General de la Defensa Nacional.",
      "Asesorar al Secretario de Estado de Defensa en el desarrollo de la polÃ­tica econÃ³mica de sus ejÃ©rcitos"
    ],
    correct: [1] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_7(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano auxiliar de mando del JEMAD que apoya y asesora en la definiciÃ³n de la estrategia militares:",
    options: [
      "El EMACON",
      "La SUBDEF",
      "La SEDEF.",
      "El EMACOM"
    ],
    correct: [0] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_8(){
  const base = [
    "Dirigir la polÃ­tica de armamento, en relaciÃ³n con organismos internacionales",
    "Asegurar la eficacia operativa de las Fuerzas Armadas",
    "__META__", // se convertirÃ¡ en "a) y c) son correctas."
    "Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar las dos opciones que debe referenciar la meta
  const idxArmamento = barajadas.indexOf("Dirigir la polÃ­tica de armamento, en relaciÃ³n con organismos internacionales");
  const idxEjercer = barajadas.indexOf("Ejercer bajo la dependencia del Presidente del Gobierno el mando de la estructura operativa de las Fuerzas Armadas");

  // Reescribir el texto meta con las letras reales
  barajadas[idxMeta] = `${letra(idxArmamento)}) y ${letra(idxEjercer)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Jefe de Estado Mayor de la Defensa le corresponde:",
    options: barajadas,
    correct: [1] // âš ï¸ cambia este Ã­ndice segÃºn cuÃ¡l/es sean correctas
  };
}



function eofas_9(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de realizar las expropiaciones de bienes y derechos asÃ­ como los arrendamientos pertinentes es:",
    options: [
      "La DIGENIN",
      "La DGAM",
      "La DIGENPER.",
      "La DIGENECO"
    ],
    correct: [0] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_10(){
  const base = [
    "Es un mando conjunto de la estructura operativa constituido de forma permanente",
    "Tiene como misiÃ³n la intervenciÃ³n en cualquier lugar del territorio nacional exclusivamente",
    "__META__", // se convertirÃ¡ en "b) y c) son correctas."
    "El JEMAD dictarÃ¡ las normas que regulen su organizaciÃ³n"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los Ã­ndices de las dos opciones que la meta debe seÃ±alar
  const idxMision = barajadas.indexOf("Tiene como misiÃ³n la intervenciÃ³n en cualquier lugar del territorio nacional exclusivamente");
  const idxJEMAD = barajadas.indexOf("El JEMAD dictarÃ¡ las normas que regulen su organizaciÃ³n");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMision)}) y ${letra(idxJEMAD)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "La UME:",
    options: barajadas,
    correct: [0] // âš ï¸ cÃ¡mbialo segÃºn cuÃ¡l/es sean las correctas
  };
}



function eofas_11(){
  const base = [
    "Desarrollar la polÃ­tica medioambiental del Departamento",
    "Administrar los recursos financieros destinados a las operaciones de paz",
    "__META__", // se convertirÃ¡ en "a) y c) son correctas."
    "Dirigir la gestiÃ³n de los bienes afectos al Ministerio de Defensa"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar los Ã­ndices de las dos opciones que debe seÃ±alar la meta
  const idxMedioambiente = barajadas.indexOf("Desarrollar la polÃ­tica medioambiental del Departamento");
  const idxBienes = barajadas.indexOf("Dirigir la gestiÃ³n de los bienes afectos al Ministerio de Defensa");

  // Reescribir el texto meta con las letras actuales
  barajadas[idxMeta] = `${letra(idxMedioambiente)}) y ${letra(idxBienes)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENECO le corresponde:",
    options: barajadas,
    correct: [1] // âš ï¸ cÃ¡mbialo segÃºn cuÃ¡l/es sean correctas
  };
}



function eofas_12(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de llevar el inventario de los bienes del Ministerio de Defensa es:",
    options: [
      "La SecretarÃ­a de Estado de Defensa",
      "La DirecciÃ³n General de Infraestructura",
      "La SubdirecciÃ³n General de RÃ©gimen Interior.",
      "La DirecciÃ³n General de Patrimonio e Inventario"
    ],
    correct: [1] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_13(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de gestionar los sistemas informÃ¡ticos integrales de direcciÃ³n y administraciÃ³n econÃ³mica del Departamento es:",
    options: [
      "La SubdirecciÃ³n General de Servicios EconÃ³micos y PagadurÃ­as",
      "La SEGENTE",
      "DIGENECO.",
      "DIGENIN"
    ],
    correct: [2] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_14(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de la direcciÃ³n de las tecnologÃ­as y seguridad de la informaciÃ³n en el Ã¡mbito de la defensa es:",
    options: [
      "El Presidente del Gobierno",
      "La Junta de Defensa Nacional",
      "La SEDEF.",
      "El JEMAD"
    ],
    correct: [2] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_15(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de proponer la polÃ­tica industrial de la defensa es:",
    options: [
      "La SUBDEF",
      "La DIGENECO",
      "La DGAM",
      "La DGAN"
    ],
    correct: [2] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_16(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de la gestiÃ³n de los servicios generales del Ã³rgano central es:",
    options: [
      "La SecretarÃ­a General TÃ©cnica",
      "La SubdirecciÃ³n General de RÃ©gimen Interior",
      "La SubdirecciÃ³n General de Seguridad y Servicios.",
      "La SubdirecciÃ³n General de Servicios"
    ],
    correct: [1] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_17(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de elaborar estudios e informes sobre cuÃ¡ntos asuntos sean sometidos a la deliberaciÃ³n del Consejo de Ministros es:",
    options: [
      "La SEGENTE",
      "La DirecciÃ³n General de Sanidad",
      "La AsesorÃ­a JurÃ­dica General.",
      "La DIGENPER"
    ],
    correct: [0] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_18(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado del registro general en el Ã³rgano central en el Ministerio de Defensa es:",
    options: [
      "La SubdirecciÃ³n General de RÃ©gimen Interior",
      "La SEGENTE",
      "La SubdirecciÃ³n General de Registro y Archivos.",
      "La SUBDEF"
    ],
    correct: [0] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_19(){
  const base = [
    "Elaborar el BOD",
    "Coordinar la polÃ­tica de igualdad",
    "__META__", // se convertirÃ¡ en "a) y c) son correctas."
    "Proponer y elaborar normas sobre reformas de mÃ©todos de trabajo"
  ];

  const barajadas = shuffle(base);
  const idxMeta = barajadas.indexOf("__META__");

  const letra = (i) => String.fromCharCode(97 + i);

  // Localizar Ã­ndices de las opciones que la meta debe referenciar
  const idxBOD = barajadas.indexOf("Elaborar el BOD");
  const idxNormas = barajadas.indexOf("Proponer y elaborar normas sobre reformas de mÃ©todos de trabajo");

  // Reescribir la opciÃ³n meta con las letras reales
  barajadas[idxMeta] = `${letra(idxBOD)}) y ${letra(idxNormas)}) son correctas.`;

  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la DIGENPER le corresponde:",
    options: barajadas,
    correct: [1] // âš ï¸ cÃ¡mbialo segÃºn cuÃ¡l/es la correcta
  };
}


function eofas_20(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "A la SEGENTE le corresponde:",
    options: [
      "Gestionar el personal militar de los Cuerpos Comunes",
      "Coordinar la polÃ­tica social para el personal militar",
      "Atender al gobierno de los Ã³rganos centrales del Ministerio.",
      "Coordinar, gestionar e inspeccionar las Delegaciones de Defensa"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_21(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Marcar la respuesta incorrecta:",
    options: [
      "El EjÃ©rcito de Tierra estÃ¡ constituido por el Cuartel General, la Fuerza y el Apoyo a la Fuerza",
      "A la DIGENPER le corresponde elaborar el rÃ©gimen general de los centros docentes militares, del alumnado y del profesorado",
      "A la DIGENPER le corresponde reconocer los derechos pasivos y conceder las prestaciones de clases pasivas del personal militar.",
      "A la DIGENPER le corresponde planificar los efectivos y el reclutamiento del personal militar"
    ],
    correct: [1] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_22(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de gestionar la formaciÃ³n para el personal civil es:",
    options: [
      "La DIGENPER",
      "La DIGEREM",
      "La SubdirecciÃ³n General de RÃ©gimen Interior.",
      "La SEGENTE"
    ],
    correct: [0] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_23(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Ã³rgano encargado de elaborar los planes de salidas profesionales del personal de las FAS es:",
    options: [
      "La DIGENPER",
      "La DirecciÃ³n General de PolÃ­tica de Defensa",
      "La DIGEREN.",
      "La DIGEREM"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_24(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Inspector General de Sanidad serÃ¡ desempeÃ±ado por:",
    options: [
      "Un General de Brigada del Cuerpo Militar de Sanidad",
      "Un Oficial General de los Cuerpos Comunes",
      "Un General de DivisiÃ³n del Cuerpo Militar de Sanidad, en situaciÃ³n de servicio activo.",
      "Un General de DivisiÃ³n de cualquiera de los EjÃ©rcitos"
    ],
    correct: [2] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_25(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El EjÃ©rcito de Tierra, la Armada y el EjÃ©rcito del Aire estÃ¡n constituidos por:",
    options: [
      "El Cuartel General, la LogÃ­stica y el Apoyo a la Fuerza",
      "La Fuerza, el Apoyo a la Fuerza y el Cuartel General",
      "El Apoyo a la Fuerza, el Cuartel General y las Fuerzas Operativas.",
      "La Fuerza, la LogÃ­stica y el Mando Supremo"
    ],
    correct: [1] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_26(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El Consejo Superior del EjÃ©rcito del Aire es el Ã³rgano colegiado asesor y consultivo de:",
    options: [
      "El Presidente del Gobierno",
      "El Subsecretario de Defensa",
      "La Junta de Defensa Nacional.",
      "El Ministro de Defensa"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_27(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El cargo de Secretario del CSEA serÃ¡ ejercido por:",
    options: [
      "El Vocal Accidental que se designe",
      "No existe el cargo de Secretario en el Consejo",
      "El Oficial General titular de la SecretarÃ­a Permanente del CSEA.",
      "El Vocal de mayor antigÃ¼edad"
    ],
    correct: [2] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_28(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al General Jefe del MACOM en el Consejo le corresponderÃ¡ ser:",
    options: [
      "Vocal Accidental",
      "Vocal asesor",
      "Depende del tipo de reuniÃ³n a realizar.",
      "Vocal Nato"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_29(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Al Consejo Superior del EjÃ©rcito del Aire le corresponde:",
    options: [
      "Emitir informe sobre aquellos asuntos que someta a su consideraciÃ³n el JEMA",
      "Ser oÃ­do por el Ministro de Defensa en relaciÃ³n con su propuesta de designaciÃ³n del Jefe de Estado Mayor del Aire",
      "Todas las anteriores son correctas.",
      "Asesorar al Ministro de Defensa en materias relativas a la estructuraciÃ³n del E.A"
    ],
    correct: [2] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_30(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Las reuniones del Consejo Superior del EjÃ©rcito del Aire serÃ¡n convocadas por:",
    options: [
      "El Ministro de Defensa",
      "El Presidente del Gobierno",
      "El Director de PolÃ­tica de Defensa.",
      "El Jefe de Estado Mayor de la Defensa"
    ],
    correct: [0] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_31(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Es funciÃ³n del CSEA:",
    options: [
      "Informar las evaluaciones para el ascenso al empleo de Teniente de los Militares de Complemento",
      "Ser oÃ­do por el Ministro de Defensa en relaciÃ³n con su propuesta de designaciÃ³n del JEMAD",
      "Todas las anteriores son ciertas.",
      "Emitir informe en aquellos asuntos que someta a su consideraciÃ³n expresa el JEMA"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_32(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "Â¿A que Ã³rgano le corresponde impartir los Altos Estudios de la Defensa Nacional?",
    options: [
      "Centro Superior de Altos Estudios de la Defensa(CESADEF)",
      "Centro Superior de Estudios de la Defensa Institucional(CESEDIN)",
      "Centro Superior de Estudios de la Defensa Nacional(CEDEDEN)",
      "Centro Universitario de la Defensa (CUD)."
    ],
    correct: [1] // âš ï¸ Marcar luego la correcta manualmente
  };
}


function eofas_33(){
  return {
    tema: "EOFAS",
    modelos: ["A","D"],
    repeatable: false,
    mode: "single",
    prompt: "El organismo pÃºblico dependiente directamente del titular del Departamento, y responsable de facilitar las informaciones, anÃ¡lisis, estudios o propuestas que permitan prevenir y evitar cualquier peligro, amenaza o agresiÃ³n contra la independencia o integridad territorial de EspaÃ±a, los intereses nacionales y la estabilidad del Estado de derecho y sus instituciones es:",
    options: [
      "DirecciÃ³n Institucional de Contrainteligencia de la Defensa",
      "AsesorÃ­a de InformaciÃ³n y Riesgos del Ministerio de Defensa",
      "SubdirecciÃ³n de AnÃ¡lisis e InformaciÃ³n de la Defensa.",
      "Centro Nacional de Inteligencia"
    ],
    correct: [3] // âš ï¸ Marcar luego la correcta manualmente
  };
}

REGISTRY.types["eofas"] = {
    name: "EOFAS",
    templates: [
eofas_1,
eofas_2,
eofas_3,
eofas_4,
eofas_5,
eofas_6,
eofas_7,
eofas_8,
eofas_9,
eofas_10,
eofas_11,
eofas_12,
eofas_13,
eofas_14,
eofas_15,
eofas_16,
eofas_17,
eofas_18,
eofas_19,
eofas_20,
eofas_21,
eofas_22,
eofas_23,
eofas_24,
eofas_25,
eofas_26,
eofas_27,
eofas_28,
eofas_29,
eofas_30,
eofas_31,
eofas_32,
eofas_33

    ]
  };
})();

(function registerConstitucion(){

  function t_constitucion(){
    const anios = [1808,1837,1845,1869,1876];
    const personas = ["NapoleÃ³n","MarÃ­a Cristina de BorbÃ³n","Isabel II","General Francisco Serrano","Alfonso XII"];
    const idx = Math.floor(Math.random()*anios.length);
    const anio = anios[idx], persona = personas[idx];
    const distractores = personas.filter(p=>p!==persona).sort(()=>Math.random()-0.5).slice(0,3);
    const options = [persona,...distractores].sort(()=>Math.random()-0.5);
    return { modelos:["A","B","C","D","E"], mode:"single", prompt:`La ConstituciÃ³n de ${anio} fue entregada por:`, options, correct:[options.indexOf(persona)] };
  }

  

  REGISTRY.types["constitucion"] = {
    name: "ConstituciÃ³n",
    templates: [
      t_constitucion
    ]
  };
})();


/* ---------- Estado ---------- */
let state = {
  typeKey: null,
  templateName: "__random__",
  mode: "estandar",   // nuevo
  total: 30,          // por defecto
  asked: 0,
  correct: 0,
  lives: 3,           // para contrarreloj/vidas
  timeLeft: 40,       // tiempo actual por pregunta
  level: 1,
  current: null,
  selection: new Set(),
  curso: null,
  modelo: null,
  modeloConfig: {}
};


/* ---------- Referencias UI ---------- */
const elStart = document.getElementById('start');
const panelConfig = document.getElementById('panel-config');
const panelTest = document.getElementById('panel-test');
const panelResult = document.getElementById('panel-result');
const elPrompt = document.getElementById('prompt');
const elOptions = document.getElementById('options');
const elExplain = document.getElementById('explain');
const elMeta = document.getElementById('meta');
const elScore = document.getElementById('score');
const elNext = document.getElementById('next');
const elCheck = document.getElementById('check');
const elModeBadge = document.getElementById('modeBadge');
const elSummary = document.getElementById('summary');
const elRetry = document.getElementById('retry');
const elHome = document.getElementById('home');
const selEsp = document.getElementById("especialidad");
const selAsig = document.getElementById("asignatura");
const selTema = document.getElementById("tema");

const selCurso = document.getElementById("curso");
const selModelo = document.getElementById("modelo");
const divOpcModelo = document.getElementById("opcionesModelo");

// Compatibilidad: ejecutar cuando el DOM estÃ© listo (sin syntaxes modernas)
function onReady(cb){
  if (document.readyState !== 'loading') cb();
  else document.addEventListener('DOMContentLoaded', cb);
}

// Buscar el contenedor .row de un elemento sin usar ?.closest
function getRow(el){
  var p = el;
  while (p && p !== document.body){
    if (p && p.classList && p.classList.contains('row')) return p;
    p = p.parentNode;
  }
  return null;
}

// Mostrar/ocultar nodos usando una clase CSS (mÃ¡s robusto que style.display)
function show(node, on){
  if (!node) return;
  if (on) node.classList.remove('hide');
  else node.classList.add('hide');
}


/* ---------- LÃ³gica ---------- */
function makeQuestion(){
  const def = REGISTRY.types[state.typeKey];
  let fn;
  if (state.templateName === "__random__"){
    fn = def.templates[rndInt(0, def.templates.length-1)];
  } else {
    fn = def.templates[parseInt(state.templateName,10)];
  }
  return fn();
}

function renderQuestion(){
  if (!state.typeKey || !REGISTRY.types[state.typeKey]){
    elPrompt.textContent = "âŒ Error: no hay ejercicios cargados para este tema.";
    return;
  }

  // Usar directamente el pool ya preparado en startTest()
if (!state.pool || state.pool.length === 0){
  if (state.repeatables && state.repeatables.length > 0){
    state.pool = state.repeatables.slice();
  } else {
    showResult();
    return;
  }
}



// Elegir al azar una plantilla del pool
const idx = rndInt(0, state.pool.length - 1);
const f = state.pool[idx];
const q = f();

// Si no es repetible â†’ se elimina del pool
if (!q.repeatable) {
  state.pool.splice(idx, 1);
} else {
  // ðŸ”¹ Si es repetible, no la quitamos: permanece en el pool
  //    (esto permite que pueda volver a salir)
}

// Guardar la pregunta actual
state.current = q;
  console.log('[render] Pregunta:', state.current.prompt);
  console.log('[render] Opciones:', (state.current.options||[]));











  state.selection = new Set();

  const {mode, prompt, options} = state.current;

  elModeBadge.textContent = (mode === "multi" ? "MODO: MÃºltiple" : "MODO: Ãšnica");
  elPrompt.textContent = prompt || "â€”";
  elExplain.classList.add('hide'); 
  elExplain.textContent = "";

  // Pintar opciones
  elOptions.innerHTML = "";
  options.forEach((text, idx)=>{
    const btn = document.createElement('button');
    btn.className = 'opt';
    btn.type = "button";
    btn.dataset.index = String(idx);
    btn.innerHTML = `<strong>${String.fromCharCode(97+idx)})</strong> ${text}`;
    btn.addEventListener('click', ()=>toggleSelect(idx, btn));
    elOptions.appendChild(btn);
  });


  // Equivalencias en recuadro bajo las respuestas
  (function(){
    var box = document.getElementById('equivalenciasBox');
    if (box) { box.parentNode && box.parentNode.removeChild(box); box = null; }
    if (Array.isArray(state.current.equivalencias) && state.current.equivalencias.length){
      box = document.createElement('div');
      box.id = 'equivalenciasBox';
      box.className = 'card';
      box.style.marginTop = '12px';
      box.style.fontSize = '18px';
      box.style.lineHeight = '1.5';
      var html = '<strong>Equivalencias</strong>' + '<div style="margin-top:6px">'
        + (state.current.equivalencias||[]).map(function(e){return '<div>&bull; '+e+'</div>';}).join('') + '</div>';
      box.innerHTML = html;
      elOptions.insertAdjacentElement('afterend', box);
    }
  })();  // Modo contrarreloj
  if (state.mode === "contrarreloj"){
    clearInterval(state.timerId);
    state.timeLeft = Math.max(20, 40 - (state.level-1)*5);
    updateHUD();
    state.timerId = setInterval(()=>{
      state.timeLeft--;
      updateHUD();
      if (state.timeLeft <= 0){
        state.lives--;
        clearInterval(state.timerId);
        if (state.lives <= 0){ 
          showResult(); 
          return; 
        } else if (state.timerId){
          clearInterval(state.timerId);
          state.timerId = null;
        }
        nextQuestion();
      }
    }, 1000);
  }

  // Meta
  elMeta.textContent = state.total ? `Pregunta ${state.asked+1} de ${state.total}` : `Pregunta ${state.asked+1}`;
  elNext.disabled = true;
  updateScore();
  updateHUD();
}




function toggleSelect(idx, elBtn){
  const mode = state.current.mode;
  if (mode === "single"){
    state.selection.clear();
    Array.from(elOptions.children).forEach(ch=>{
      ch.classList.remove('selected');
    });
    state.selection.add(idx);
    elBtn.classList.add('selected');
  } else {
    if (state.selection.has(idx)){
      state.selection.delete(idx);
      elBtn.classList.remove('selected');
    } else {
      state.selection.add(idx);
      elBtn.classList.add('selected');
    }
  }
}

function checkAnswer(){
if (state.selection.size===0) return;

  // detener el temporizador mientras se corrige la pregunta
  if (state.mode === "contrarreloj" && state.timerId){
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const correctSet = new Set(state.current.correct);
  const isCorrect = (
    state.selection.size === correctSet.size &&
    Array.from(state.selection).every(i => correctSet.has(i))
  );

  console.log('[check] SelecciÃ³n:', Array.from(state.selection));
  console.log('[check] Correctas:', Array.from(correctSet));
  console.log('[check] Â¿Correcto?:', isCorrect);

  // Pintado de feedback
  Array.from(elOptions.children).forEach((btn, i)=>{
    if (correctSet.has(i)) btn.classList.add('correct');
    else if (state.selection.has(i)) btn.classList.add('wrong');
    btn.disabled = true;
  });

  if (isCorrect){
    state.correct++;
    if (state.correct % 5 === 0){ state.level++; }
  } else {
    if (state.mode === "contrarreloj" || state.mode === "vidas"){
      state.lives = Math.max(0, state.lives - 1);
      updateHUD();
      if (state.lives <= 0){ showResult(); return; }
    }
  }

  // ExplicaciÃ³n (si la hay)
  if (state.current.explanation){
    elExplain.classList.remove('hide');
    elExplain.classList.add('card');
    var extra = document.createElement('div');
    extra.style.marginTop = '8px';
    extra.textContent = state.current.explanation;
    elExplain.appendChild(extra);
  }

  elNext.disabled = false;
  updateScore();
}


function nextQuestion(){
  state.asked++;
  if (state.total && state.asked >= state.total){
    showResult();
  } else {
      renderQuestion();
}
}


function updateScore(){
  elScore.textContent = `${state.correct} / ${state.asked} acertadas`;
}

function startTest(){
  if (state.timerId) {
    clearInterval(state.timerId);
    state.timerId = null;
  }

  const esp = selEsp.value;
  const asig = selAsig.value;
  const tema = selTema.value;
  const modoSel = document.getElementById("modo").value;

  state.curso = selCurso.value;
  if (!state.curso){ 
    alert("Selecciona el curso acadÃ©mico."); 
    return; 
  }

  state.modelo = selModelo.value;
  if (!state.modelo){ 
    alert("Selecciona el modelo (Aâ€“E)."); 
    return; 
  }

  state.mode = modoSel;
  state.asked = 0;
  state.correct = 0;
  state.lives = 3;
  state.level = 1;
  state.timeLeft = 40;
  state.selection = new Set();
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);
  console.log('[wizard] Entrada:', { curso: state.curso, especialidad: selEsp.value, asignatura: selAsig.value, tema: selTema.value, modo: modoSel, modelo: selModelo.value });
  console.log('[wizard] MAPEO key:', `${selEsp.value}|${selAsig.value}|${selTema.value}`);

  // Inicializar arrays vacÃ­os para evitar errores
  state.pool = [];
  state.repeatables = [];

  // ðŸ”¹ Definimos un mapeo de combinaciones a typeKey
  const MAPEO_TEMAS = {
    "GENERAL|ConstituciÃ³n|Test ConstituciÃ³n": "constitucion",
    "GENERAL|EOFAS|EOFAS": "eofas",
    "CYB|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "CAE|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "PAO|Elementos de Sistemas de Telecomunicaciones|Magnitudes y unidades": "magnitudes_y_unidades",
    "MER|MatemÃ¡ticas|AritmÃ©tica": "matematicas_aritmetica",
    "ELC|MatemÃ¡ticas|AritmÃ©tica": "matematicas_aritmetica",
    "MER|Fundamentos de electricidad|TeorÃ­a de los electrones": "teoria_electrones",
    "ELC|Fundamentos de electricidad|TeorÃ­a de los electrones": "teoria_electrones"
  };

  // Construimos la clave con lo que seleccionÃ³ el usuario
  const key = `${esp}|${asig}|${tema}`;
  state.typeKey = MAPEO_TEMAS[key];

  // Si no estÃ¡ implementado â†’ mostrar aviso, pero mantener el wizard abierto
  if (!state.typeKey || !REGISTRY.types[state.typeKey]) {
    alert(`âš ï¸ Tema aÃºn no implementado: ${esp} â†’ ${asig} â†’ ${tema}`);
    return;  // ðŸ‘ˆ ya no oculta ni reinicia, solo no arranca el test
  }

  // ðŸ”¹ Construir pool filtrado
  const def = REGISTRY.types[state.typeKey];
  const templates = Array.isArray(def.templates) ? def.templates : [];

  // Construir el pool inicial de plantillas vÃ¡lidas segÃºn el modelo
  state.pool = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo);
    } catch(e){ 
      return false; 
    }
  });

  // Guardar aparte las repetibles para reponerlas cuando se vacÃ­e el pool
  state.repeatables = templates.filter(f => {
    try {
      if (f.name === "configuracion_electronica" && state.modelo === "B") return false;
      const q = f();
      return q && Array.isArray(q.modelos) && q.modelos.includes(state.modelo) && q.repeatable === true;
    } catch(e){ 
      return false; 
    }
  });

  // Si no hay preguntas en el pool â†’ avisar y volver al wizard
  if (state.pool.length === 0){
    alert(`âš ï¸ El tema ${def.name} no tiene preguntas para el modelo ${state.modelo}.`);
    panelTest.classList.add('hide');
    panelConfig.classList.remove('hide');
    return;
  }

  // Ajustar nÃºmero total de preguntas segÃºn modo
  if (state.mode === "estandar") {
    // ðŸ”¹ Comprobar si el tema tiene plantillas repetibles
    const hasRepeatables = templates.some(f => {
      try {
        const q = f();
        return q.repeatable === true;
      } catch(e) {
        return false;
      }
    });

    if (hasRepeatables) {
      state.total = 30;   // âœ… fija 30 preguntas aunque se repitan
    } else {
      state.total = state.pool.length;  // âœ… solo las disponibles (no repetibles)
    }
  } else {
    state.total = null;  // en otros modos (vidas, contrarreloj) no hay lÃ­mite fijo
  }

  // Mostrar panel del test
  panelConfig.classList.add('hide');
  panelResult.classList.add('hide');
  panelTest.classList.remove('hide');

  updateHUD();
  renderQuestion();
}




// En el script
function updateHUD(){
  if (state.mode!=="estandar"){
    document.getElementById("lives").textContent = "â¤".repeat(state.lives);
  } else {
    document.getElementById("lives").textContent = "";
  }
  if (state.mode==="contrarreloj"){
    document.getElementById("timer").textContent = state.timeLeft+"s";
  } else {
    document.getElementById("timer").textContent = "";
  }
}


function showResult(){
  panelTest.classList.add('hide');
  panelResult.classList.remove('hide');

  if (state.total){
    elSummary.textContent = `Has acertado ${state.correct} de ${state.total} (${Math.round(100*state.correct/state.total)}%).`;
  } else {
    elSummary.textContent = `Has acertado ${state.correct} preguntas.`;
  }
}


/* ---------- Eventos ---------- */
elStart.addEventListener('click', startTest);
elCheck.addEventListener('click', checkAnswer);
elNext.addEventListener('click', nextQuestion);
elRetry.addEventListener('click', startTest);
elHome.addEventListener('click', ()=>{
  if (state.timerId) { clearInterval(state.timerId); state.timerId = null; }
  panelResult.classList.add('hide');
  panelConfig.classList.remove('hide');
});



/* ---------- Atajos ---------- */
window.addEventListener('keydown', (e)=>{
  if (panelTest.classList.contains('hide')) return;
  const key = e.key.toLowerCase();
  const map = { a:0, b:1, c:2, d:3 };
  if (key in map){
    const idx = map[key];
    const btn = elOptions.children[idx];
    if (btn && !btn.disabled) btn.click();
  } else if (key === 'enter'){
    if (!elNext.disabled) nextQuestion(); else checkAnswer();
  } else if (key === 'n'){
    if (!elNext.disabled) nextQuestion();
  }
});


/* ---------- Datos de especialidades ---------- */
const ESPECIALIDADES_BY_CURSO = {
  "Promocion_XXXIV_STP": {},
  "Promocion_XXXV_STP": {},
  "Promocion_XXXVI_STP": {
    "GENERAL": {
      "ConstituciÃ³n": ["Test ConstituciÃ³n"],
      "EOFAS": ["EOFAS"],
    },
    "CAE": {
      "TÃ©cnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonÃ­a fija y mÃ³vil":["IntroducciÃ³n","IntroducciÃ³n a la telefonÃ­a","EvoluciÃ³n de la estructura de la red telefÃ³nica","La seÃ±al telefÃ³nica","TelefonÃ­a digital","MultiplexaciÃ³n de canales MIC","TecnologÃ­as de banda ancha. RDSI y ATM","Estructura de la red y trÃ¡fico telefÃ³nico", "ConmutaciÃ³n telefÃ³nica","Sistemas digitales de conmutaciÃ³n","Sistema privado de conmutaciÃ³n PBX"],
      "AuditorÃ­a Redes WIFI":["IntroducciÃ³n","Herramientas de auditorÃ­a de redes LAN inalÃ¡mbricas","CriptografÃ­a","Medidas de seguridad bÃ¡sicas","Herramientas de captura y analisis de trÃ¡fico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    },
    "CYB": {
      "TÃ©cnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonÃ­a fija y mÃ³vil":["IntroducciÃ³n","IntroducciÃ³n a la telefonÃ­a","EvoluciÃ³n de la estructura de la red telefÃ³nica","La seÃ±al telefÃ³nica","TelefonÃ­a digital","MultiplexaciÃ³n de canales MIC","TecnologÃ­as de banda ancha. RDSI y ATM","Estructura de la red y trÃ¡fico telefÃ³nico", "ConmutaciÃ³n telefÃ³nica","Sistemas digitales de conmutaciÃ³n","Sistema privado de conmutaciÃ³n PBX"],
      "AuditorÃ­a Redes WIFI":["IntroducciÃ³n","Herramientas de auditorÃ­a de redes LAN inalÃ¡mbricas","CriptografÃ­a","Medidas de seguridad bÃ¡sicas","Herramientas de captura y analisis de trÃ¡fico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    },
    "MER": {
      "MatemÃ¡ticas":["AritmÃ©tica","Ãlgebra","GeometrÃ­a"],
      "FÃ­sica":["La materia","MecÃ¡nica","TermodinÃ¡mica","Ã“ptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["TeorÃ­a de los electrones", "Electricidad estÃ¡tica y conducciÃ³n", "TerminologÃ­a elÃ©ctrica","GeneraciÃ³n de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "TeorÃ­a del motor/Generador DC","TeorÃ­a de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electrÃ³nica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["CapÃ­tulo 0","Forma del fuselaje","Esfuerzos y deformaciÃ³n","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que actÃºan en el aviÃ³n","Velocidades de influencia estructural","SecciÃ³n D","Cargas estructurales en el helicÃ³ptero","CertificaciÃ³n de las estructuras aeronÃ¡uticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromecÃ¡mico":["Generalidades","Rendimiento y limitaciones humanas","PsicologÃ­a social", "Factores que afectan al rendimiento","Entorno fÃ­sico","Tareas","ComunaciÃ³n","Error humano","Riesgos Laborales"]
    },
    "ELC": {
      "MatemÃ¡ticas":["AritmÃ©tica","Ãlgebra","GeometrÃ­a"],
      "FÃ­sica":["La materia","MecÃ¡nica","TermodinÃ¡mica","Ã“ptica","Movimiento ondulatorio y sonido"],
      "Fundamentos de electricidad":["TeorÃ­a de los electrones", "Electricidad estÃ¡tica y conducciÃ³n", "TerminologÃ­a elÃ©ctrica","GeneraciÃ³n de electricidad", "Fuentes de corriente continua","Circuitos de corriente continua","Resistencias y resistores","Potencia","Capacidad y condensadores","Magnetismo","Inductancia e inductores", "TeorÃ­a del motor/Generador DC","TeorÃ­a de corriente alterna","Circuitos RLC","Transformadores", "Filtros", "Generadores AC","Motores AC"],
      "Fundamentos de electrÃ³nica":["Semiconductores","Diodos","Transistores", "Circuitos integrados", "Placas de circuitos impresos","Servomecanismos"],
      "Estrucutras de las aeronaves":["CapÃ­tulo 0","Forma del fuselaje","Esfuerzos y deformaciÃ³n","Propiedades de los materiales","Modos de trabajo de la estructura del fuselaje", "Tipos de cargas generales que actÃºan en el aviÃ³n","Velocidades de influencia estructural","SecciÃ³n D","Cargas estructurales en el helicÃ³ptero","CertificaciÃ³n de las estructuras aeronÃ¡uticas","Pabrisas y ventanillas de cabina","Estructura del ala", "Estructurade las superficies de cola: estabilizadores"],
      "Factores humanos en mantenimiento aeromecÃ¡mico":["Generalidades","Rendimiento y limitaciones humanas","PsicologÃ­a social", "Factores que afectan al rendimiento","Entorno fÃ­sico","Tareas","ComunaciÃ³n","Error humano","Riesgos Laborales"]
    },
    "AYF": {},
    "PAO": {
      "TÃ©cnicas y Procesos de Infraestructuras y Telecomunicaciones":["Replanteo de infraestructuras de sistemas de telecomunicaciones"],
      "Sistemas de telefonÃ­a fija y mÃ³vil":["IntroducciÃ³n","IntroducciÃ³n a la telefonÃ­a","EvoluciÃ³n de la estructura de la red telefÃ³nica","La seÃ±al telefÃ³nica","TelefonÃ­a digital","MultiplexaciÃ³n de canales MIC","TecnologÃ­as de banda ancha. RDSI y ATM","Estructura de la red y trÃ¡fico telefÃ³nico", "ConmutaciÃ³n telefÃ³nica","Sistemas digitales de conmutaciÃ³n","Sistema privado de conmutaciÃ³n PBX"],
      "AuditorÃ­a Redes WIFI":["IntroducciÃ³n","Herramientas de auditorÃ­a de redes LAN inalÃ¡mbricas","CriptografÃ­a","Medidas de seguridad bÃ¡sicas","Herramientas de captura y analisis de trÃ¡fico TCP/IP"],
      "Elementos de Sistemas de Telecomunicaciones":["Magnitudes y unidades"]
    }
  }
};

/* ---------- Flujo paso a paso (wizard) y opciones de modelo ---------- */
function updateStartEnabled(){
  const okCurso = !!selCurso.value;
  const okEsp   = !!selEsp.value;
  const okAsig  = !!selAsig.value;
  const okTema  = !!selTema.value;

  const modoSel = document.getElementById("modo").value;
  let okModo = !!modoSel;

  const modelo  = selModelo.value;
  let okModelo  = !!modelo;

  // Validaciones especÃ­ficas de C/E
  if (modelo === "C"){
    var tipoCEl = document.getElementById("tipoC");
    const tipoC = (tipoCEl && tipoCEl.value) ? tipoCEl.value : "";
    okModelo = okModelo && !!tipoC;
  } else if (modelo === "E"){
    const grupos = Array.from(document.querySelectorAll('input[name="grupoE"]:checked'));
    const tipos  = Array.from(document.querySelectorAll('input[name="tipoE"]:checked'));
    const requiereTipos = (
      selAsig.value.toLowerCase().includes("matem") ||
      selTema.value.toLowerCase().includes("aritm")
    );
    okModelo = okModelo && grupos.length > 0 && (requiereTipos ? tipos.length > 0 : true);
  }

  // El botÃ³n siempre estÃ¡ visible, solo se activa/desactiva
  const ready = okCurso && okEsp && okAsig && okTema && okModo && okModelo;
  elStart.disabled = !ready;
}


function renderModelOptions(){
  const modelo = selModelo.value;
  divOpcModelo.innerHTML = "";
  divOpcModelo.classList.add("hide");

  if (!modelo){ updateStartEnabled(); return; }

  if (modelo === "C"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label for="tipoC">Modelo C â€” Â¿quÃ© quieres?</label>
          <select id="tipoC">
            <option value="">-- Selecciona --</option>
            <option value="teoria">TeorÃ­a</option>
            <option value="practica">PrÃ¡ctica</option>
            <option value="ambas">Ambas</option>
          </select>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    document.getElementById("tipoC").addEventListener("change", updateStartEnabled);
  } else if (modelo === "E"){
    divOpcModelo.innerHTML = `
      <div class="row row-2">
        <div>
          <label>Grupos (puedes marcar varios)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="A"> Grupo A (Daypo)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="B"> Grupo B (Libro)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="C"> Grupo C (Diario)</label><br>
          <label class="pill"><input type="checkbox" name="grupoE" value="D"> Grupo D (Todo)</label>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="row row-2">
        <div>
          <label>Tipos de ejercicio (si aplica)</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="suma_basica"> Sumas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="resta_basica"> Restas</label><br>
          <label class="pill"><input type="checkbox" name="tipoE" value="multiplicacion_basica"> Multiplicaciones</label>
        </div>
      </div>
    `;
    divOpcModelo.classList.remove("hide");
    Array.from(divOpcModelo.querySelectorAll('input[name="grupoE"], input[name="tipoE"]')).forEach(ch => {
      ch.addEventListener("change", updateStartEnabled);
    });
  }
  updateStartEnabled();

  }


function setupWizard(){
  // Referencias a bloques (no usar getRow con E/A/T porque comparten la misma fila)
  var rowEsp    = document.getElementById("bloque-esp");
  var rowAsig   = document.getElementById("bloque-asig");
  var rowTema   = document.getElementById("bloque-tema");
  var rowModo   = getRow(document.getElementById("modo"));
  var rowModelo = getRow(selModelo);
  var rowStart  = getRow(elStart);
  var filaEAT  = document.getElementById("fila-eat");

  // Estado inicial â€” solo visible "Curso"
  show(rowEsp,    false);
  show(rowAsig,   false);
  show(rowTema,   false);
  show(rowModo,   false);
  show(rowModelo, false);
  // âŒ no ocultamos rowStart, el botÃ³n siempre se ve

  selAsig.disabled = true;
  selTema.disabled = true;
  divOpcModelo.classList.add('hide');
  divOpcModelo.innerHTML = "";

  // PASO 1 â†’ Curso
  function handleCursoChange(){
  try {
    selEsp.value = "";
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";
    const hasCurso = !!selCurso.value;
    selEsp.disabled = !hasCurso;
    if (filaEAT) show(filaEAT, hasCurso);
    show(rowEsp, hasCurso);
    show(rowAsig, false);
    show(rowTema, false);
    show(rowModo, false);
    show(rowModelo, false);
    updateStartEnabled();
    console.log('[wizard] curso change:', selCurso.value);
  } catch(e){ console.error('[wizard] handleCursoChange error', e); }
}
selCurso.addEventListener('change', handleCursoChange);
selCurso.addEventListener('input', handleCursoChange);


    if (selCurso && selCurso.value) { handleCursoChange(); }

// PASO 2 â†’ Especialidad
  selEsp.addEventListener("change", function(){
    selAsig.innerHTML = '<option value="">-- Selecciona asignatura --</option>';
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selAsig.disabled = true;
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    if (!cursoSel){
      alert("âš ï¸ Selecciona primero el curso acadÃ©mico.");
      selEsp.value = "";
      return;
    }
    var esp = selEsp.value;
    var data = ESPECIALIDADES_BY_CURSO[cursoSel] && ESPECIALIDADES_BY_CURSO[cursoSel][esp];

    if (data){
      Object.keys(data).forEach(function(a){
        var opt = document.createElement("option");
        opt.value = a; opt.textContent = a;
        selAsig.appendChild(opt);
      });
      selAsig.disabled = Object.keys(data).length === 0;
    } else {
      selAsig.innerHTML = '<option value="">â€” Sin datos para esta especialidad â€”</option>';
      selAsig.disabled = true;
    }

    show(rowAsig,   true);
    show(rowTema,   false);
    show(rowModo,   false);
    show(rowModelo, false);

    updateStartEnabled();
  });

  // PASO 3 â†’ Asignatura
  selAsig.addEventListener("change", function(){
    selTema.innerHTML = '<option value="">-- Selecciona tema --</option>';
    selTema.disabled = true;

    var cursoSel = selCurso.value;
    var esp = selEsp.value;
    var asig = selAsig.value;
    var temas = ESPECIALIDADES_BY_CURSO[cursoSel] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp] &&
                ESPECIALIDADES_BY_CURSO[cursoSel][esp][asig];

    if (Array.isArray(temas)){
      temas.forEach(function(t){
        var opt = document.createElement("option");
        opt.value = t; opt.textContent = t;
        selTema.appendChild(opt);
      });
      selTema.disabled = temas.length === 0;
    }

    show(rowTema,   true);
    show(rowModo,   false);
    show(rowModelo, false);

    // Reset de modo/modelo
    document.getElementById("modo").value = "";
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 4 â†’ Tema
  selTema.addEventListener("change", function(){
    show(rowModo,   !!selTema.value);
    show(rowModelo, false);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 5 â†’ Modo
  document.getElementById("modo").addEventListener("change", function(){
    show(rowModelo, !!this.value);

    // Reset modelo/opciones
    selModelo.value = "";
    divOpcModelo.classList.add('hide');
    divOpcModelo.innerHTML = "";

    updateStartEnabled();
  });

  // PASO 6 â†’ Modelo
  selModelo.addEventListener("change", function(){
    renderModelOptions();
    updateStartEnabled();
  });

  // Recalcular si cambia el modo (vidas/tiempo)
  var modoSel = document.getElementById("modo");
  if (modoSel) modoSel.addEventListener("change", updateStartEnabled);

  updateStartEnabled();
}






// Ejecutar setup inmediatamente (el script estÃ¡ al final del body)





onReady(function(){
  setupWizard();
});


const ELEMENTOS = {
  1: { nombre: "HidrÃ³geno", config: "1sÂ¹" },
  2: { nombre: "Helio", config: "1sÂ²" },
  3: { nombre: "Litio", config: "1sÂ² 2sÂ¹" },
  4: { nombre: "Berilio", config: "1sÂ² 2sÂ²" },
  5: { nombre: "Boro", config: "1sÂ² 2sÂ² 2pÂ¹" },
  6: { nombre: "Carbono", config: "1sÂ² 2sÂ² 2pÂ²" },
  7: { nombre: "NitrÃ³geno", config: "1sÂ² 2sÂ² 2pÂ³" },
  8: { nombre: "OxÃ­geno", config: "1sÂ² 2sÂ² 2pâ´" },
  9: { nombre: "FlÃºor", config: "1sÂ² 2sÂ² 2pâµ" },
  10: { nombre: "NeÃ³n", config: "1sÂ² 2sÂ² 2pâ¶" },
  11: { nombre: "Sodio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ¹" },
  12: { nombre: "Magnesio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ²" },
  13: { nombre: "Aluminio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pÂ¹" },
  14: { nombre: "Silicio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pÂ²" },
  15: { nombre: "FÃ³sforo", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pÂ³" },
  16: { nombre: "Azufre", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ´" },
  17: { nombre: "Cloro", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâµ" },
  18: { nombre: "ArgÃ³n", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶" },
  19: { nombre: "Potasio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 4sÂ¹" },
  20: { nombre: "Calcio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 4sÂ²" },
  21: { nombre: "Escandio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹ 4sÂ²" },
  22: { nombre: "Titanio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ² 4sÂ²" },
  23: { nombre: "Vanadio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ³ 4sÂ²" },
  24: { nombre: "Cromo", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dâµ 4sÂ¹" },
  25: { nombre: "Manganeso", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dâµ 4sÂ²" },
  26: { nombre: "Hierro", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dâ¶ 4sÂ²" },
  27: { nombre: "Cobalto", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dâ· 4sÂ²" },
  28: { nombre: "NÃ­quel", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dâ¸ 4sÂ²" },
  29: { nombre: "Cobre", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ¹" },
  30: { nombre: "Zinc", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ²" },
  31: { nombre: "Galio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pÂ¹" },
  32: { nombre: "Germanio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pÂ²" },
  33: { nombre: "ArsÃ©nico", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pÂ³" },
  34: { nombre: "Selenio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ´" },
  35: { nombre: "Bromo", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâµ" },
  36: { nombre: "KriptÃ³n", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶" },
  37: { nombre: "Rubidio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 5sÂ¹" },
  38: { nombre: "Estroncio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 5sÂ²" },
  39: { nombre: "Itrio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dÂ¹ 5sÂ²" },
  40: { nombre: "Circonio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dÂ² 5sÂ²" },
  41: { nombre: "Niobio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dâ´ 5sÂ¹" },
  42: { nombre: "Molibdeno", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dâµ 5sÂ¹" },
  43: { nombre: "Tecnecio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dâµ 5sÂ²" },
  44: { nombre: "Rutenio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dâ· 5sÂ¹" },
  45: { nombre: "Rodio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dâ¸ 5sÂ¹" },
  46: { nombre: "Paladio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dÂ¹â°" },
  47: { nombre: "Plata", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dÂ¹â° 5sÂ¹" },
  48: { nombre: "Cadmio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dÂ¹â° 5sÂ²" },
  49: { nombre: "Indio", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dÂ¹â° 5sÂ² 5pÂ¹" },
  50: { nombre: "EstaÃ±o", config: "1sÂ² 2sÂ² 2pâ¶ 3sÂ² 3pâ¶ 3dÂ¹â° 4sÂ² 4pâ¶ 4dÂ¹â° 5sÂ² 5pÂ²" },

  
};


const EQUIVALENCIAS = {
  distancia: {
    km: { m: {num: 1000, den: 1} },
    m: {
      km: {num: 1, den: 1000},
      cm: {num: 100, den: 1},
      mm: {num: 1000, den: 1},
      in: {num: 39.37, den: 1},
      ft: {num: 3.281, den: 1},
      yd: {num: 1.094, den: 1},
      mi: {num: 1/1609, den: 1}
    },
    cm: { m: {num: 1, den: 100}, mm: {num: 10, den: 1} },
    mm: { m: {num: 1, den: 1000}, cm: {num: 1, den: 10} },
    in: { m: {num: 1, den: 39.37}, ft: {num: 1, den: 12} },
    ft: { m: {num: 1, den: 3.281}, in: {num: 12, den: 1}, yd: {num: 1, den: 3} },
    yd: { m: {num: 1, den: 1.094}, ft: {num: 3, den: 1} },
    mi: { m: {num: 1609, den: 1}, yd: {num: 1760, den: 1} }
  },

  tiempo: {
    h: { min: {num: 60, den: 1}, s: {num: 3600, den: 1}, d: {num: 1/24, den: 1} },
    min: { h: {num: 1, den: 60}, s: {num: 60, den: 1} },
    s: { min: {num: 1, den: 60}, h: {num: 1, den: 3600}, ms: {num: 1000, den: 1} },
    ms: { s: {num: 1, den: 1000} },
    d: { h: {num: 24, den: 1}, aÃ±o: {num: 1, den: 365} },
    aÃ±o: { d: {num: 365, den: 1} }
  },


  datos: {
    bit: {
      byte: {num: 1, den: 8}
    },
    byte: {
      bit: {num: 8, den: 1},
      KB: {num: 1, den: 1024}
    },
    KB: {
      byte: {num: 1024, den: 1},
      MB: {num: 1, den: 1024}
    },
    MB: {
      KB: {num: 1024, den: 1},
      GB: {num: 1, den: 1024}
    },
    GB: {
      MB: {num: 1024, den: 1}
    }
  },

  temperatura: {
    C: {
      K: { type: "affine", scale: 1, offset: 273.15, display: "K = Â°C + 273.15" },
      F: { type: "affine", scale: 9/5, offset: 32, display: "Â°F = Â°C * 1.8 + 32" }
    },
    K: {
      C: { type: "affine", scale: 1, offset: -273.15, display: "Â°C = K - 273.15" },
      F: { type: "affine", scale: 9/5, offset: -459.67, display: "Â°F = K * 1.8 - 459.67" }
    },
    F: {
      C: { type: "affine", scale: 5/9, offset: -(32 * 5/9), display: "Â°C = (Â°F - 32) * 5/9" },
      K: { type: "affine", scale: 5/9, offset: 273.15 - (32 * 5/9), display: "K = (Â°F - 32) * 5/9 + 273.15" }
    }
  }
};

const UNIT_LABELS = {
  C: "Â°C",
  F: "Â°F",
  K: "K"
};

function formatUnitLabel(unit) {
  return UNIT_LABELS[unit] || unit;
}

function formatNumber(num) {
// Formateo robusto con notaciÃ³n cientÃ­fica cuando el redondeo darÃ­a 0
  if (!Number.isFinite(num)) {
    return String(num);
  }
  if (Number.isInteger(num)) {
    return String(num);
  }
  const abs = Math.abs(num);
  const fixed = num.toFixed(3);
  const trimmed = fixed.replace(/\.?0+$/, '');
  if (parseFloat(trimmed) === 0 && abs > 0) {
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mant.toFixed(3).replace(/\.?0+$/, '') + '\u00d7' + '10' + expStr;
  }
  return trimmed === '-0' ? '0' : trimmed;
}




function applyConversion(value, rule) {
  if (!rule) {
    throw new Error("Regla de conversiÃ³n ausente");
  }
  if (typeof rule.convert === "function") {
    return rule.convert(value);
  }
  if (rule.type === "affine") {
    return value * rule.scale + rule.offset;
  }
  if (typeof rule.num !== "undefined" && typeof rule.den !== "undefined") {
    return value * (rule.num / rule.den);
  }
  throw new Error("Tipo de conversiÃ³n no soportado");
}

function describeConversion(from, to, rule) {
const fromLabel = formatUnitLabel(from);
  const toLabel = formatUnitLabel(to);

  if (rule && rule.display) {
    return rule.display;
  }

  const hasNumDen = rule && typeof rule.num !== 'undefined' && typeof rule.den !== 'undefined';
  const isComposite = String(from).includes('/') || String(to).includes('/');

  // Si tenemos factor numÃ©rico, siempre lo mostramos, tambiÃ©n para compuestas
  if (hasNumDen) {
    const factor = rule.num / rule.den;
    const factorStr = formatNumber(factor);
    if (isComposite) {
      const splitFrom = String(from).split('/');
      const splitTo = String(to).split('/');
      const fNum = splitFrom[0] || from;
      const fDen = splitFrom[1] || '';
      const tNum = splitTo[0] || to;
      const tDen = splitTo[1] || '';
      const hints = [];
      if (fNum && tNum && fNum !== tNum) {
        hints.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
      }
      if (fDen || tDen) {
        if (fDen && tDen && fDen !== tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
        } else if (fDen && !tDen) {
          hints.push(`/ (${formatUnitLabel(fDen)})`);
        } else if (!fDen && tDen) {
          hints.push(`/ (${formatUnitLabel(tDen)})`);
        }
      }
      const hintStr = hints.length ? ` ${hints.join(' ')}` : '';
      return `1 ${fromLabel} = ${factorStr} ${toLabel}${hintStr}`;
    }
    return `1 ${fromLabel} = ${factorStr} ${toLabel}`;
  }

  if (rule && rule.type === 'affine') {
    const scale = formatNumber(rule.scale);
    const offset = rule.offset || 0;
    if (!offset) {
      return `${toLabel} = ${scale} * ${fromLabel}`;
    }
    const signo = offset >= 0 ? '+' : '-';
    return `${toLabel} = ${scale} * ${fromLabel} ${signo} ${formatNumber(Math.abs(offset))}`;
  }

  // Fallback composito solo con etiquetas si no hay num/den
  if (isComposite) {
    const splitFrom = String(from).split('/');
    const splitTo = String(to).split('/');
    const fNum = splitFrom[0] || from;
    const fDen = splitFrom[1] || '';
    const tNum = splitTo[0] || to;
    const tDen = splitTo[1] || '';
    const parts = [];
    if (fNum && tNum) parts.push(`(${formatUnitLabel(fNum)} \u2192 ${formatUnitLabel(tNum)})`);
    if (fDen || tDen) {
      if (fDen && tDen) parts.push(`/ (${formatUnitLabel(fDen)} \u2192 ${formatUnitLabel(tDen)})`);
      else if (fDen) parts.push(`/ (${formatUnitLabel(fDen)})`);
      else if (tDen) parts.push(`/ (${formatUnitLabel(tDen)})`);
    }
    return `${fromLabel} = ${parts.join(' ')}`;
  }

  return `${fromLabel} \u2192 ${toLabel}`;
}






function conversion_unidades() {  function sci(num){
    if (!Number.isFinite(num)) return String(num);
    if (num === 0) return '0';
    const abs = Math.abs(num);
    const exp = Math.floor(Math.log10(abs));
    const mant = num / Math.pow(10, exp);
    const mantStr = mant.toFixed(3).replace(/\.?0+$/, '');
    const supers = { '0':'\u2070','1':'\u00b9','2':'\u00b2','3':'\u00b3','4':'\u2074','5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207b' };
    const expStr = String(exp).split('').map(c=>supers[c]||c).join('');
    return mantStr + '\u00d7' + '10' + expStr;
  }

  function generarDistractores(valor) {
    const candidatos = new Set();
    const addCandidate = (num) => {
      if (!Number.isFinite(num)) return;
      if (num === valor) return;
      candidatos.add(num);
    };
    addCandidate(valor * 10);
    addCandidate(valor / 10);
    const absValor = Math.abs(valor) || 1;
    const order = Math.floor(Math.log10(absValor));
    let step;
    if (order >= 2) step = Math.pow(10, order - 1);
    else if (order === 1) step = 10;
    else if (order === 0) step = 1;
    else step = Math.pow(10, order);
    if (!Number.isFinite(step) || step === 0) step = absValor * 0.1 || 0.1;
    [Math.floor(valor / step) * step, Math.ceil(valor / step) * step].forEach(addCandidate);
    addCandidate(valor + step);
    addCandidate(valor - step);
    [0.9, 1.1, 0.95, 1.05].forEach((f)=>addCandidate(valor * f));
    let i = 1;
    while (candidatos.size < 3 && i <= 12){ addCandidate(valor + i*step*0.1); addCandidate(valor - i*step*0.1); addCandidate(valor*(1+i*0.02)); i++; }
    if (!candidatos.size){ addCandidate(valor + absValor); addCandidate(valor - absValor); addCandidate(valor + absValor*0.5); }
    return shuffle(Array.from(candidatos));
  }

  function buscarCaminoSimple(grafo, pasos) {
    const unidades = shuffle(Object.keys(grafo));
    for (const origen of unidades) {
      const visitados = new Set([origen]);
      const camino = [origen];
      const res = explorar(origen, pasos, grafo, visitados, camino);
      if (res) return res;
    }
    return null;
  }

  function explorar(actual, restantes, grafo, visitados, camino) {
    if (restantes === 0) return [...camino];
    const vecinos = shuffle(Object.keys(grafo[actual] || {}).filter(u=>!visitados.has(u)));
    for (const v of vecinos){
      visitados.add(v); camino.push(v);
      const r = explorar(v, restantes-1, grafo, visitados, camino);
      if (r) return r;
      camino.pop(); visitados.delete(v);
    }
    return null;
  }

  let intentos = 0;
  const allMagnitudes = Object.keys(EQUIVALENCIAS).filter(k => k !== 'temperatura');

  while (intentos < 10){
    intentos++;
    console.log(`\uD83D\uDD04 Intento ${intentos}`);

    // Elegir cuÃ¡ntas magnitudes combinar (2 a 4)
    const k = Math.min(4, Math.max(2, rndInt(2, Math.min(4, allMagnitudes.length))));
    const mags = shuffle(allMagnitudes).slice(0, k);

    // ParticiÃ³n en numerador/denominador (al menos 1 arriba)
    const numCount = rndInt(1, mags.length);
    const numeradores = mags.slice(0, numCount);
    const denominadores = mags.slice(numCount);

    console.log('[conv] CombinaciÃ³n:', {numeradores, denominadores});

    // Construir caminos por magnitud
    let valido = true;
    const piezas = [];
    for (const [rol, lista] of [['num', numeradores], ['den', denominadores]]){
      for (const mag of lista){
        const grafo = EQUIVALENCIAS[mag];
        const pasos = rndInt(1, 2);
        const camino = buscarCaminoSimple(grafo, pasos);
        if (!camino){ valido = false; break; }
        let factor = 1; const localSteps = [];
        for (let i=0;i<camino.length-1;i++){
          const a = camino[i], b = camino[i+1];
          const regla = (grafo[a]||{})[b];
          if (!regla){ valido = false; break; }
          localSteps.push({from:a, to:b, rule:regla});
          factor = applyConversion(factor, regla);
        }
        if (!valido) break;
        piezas.push({ rol, mag, path: localSteps, factor, from: camino[0], to: camino[camino.length-1], pasos: camino.length-1 });
      }
      if (!valido) break;
    }
    if (!valido || piezas.length === 0) continue;

    // Construir unidades compuestas origen/destino con punto medio
    const dot = '\u00b7';
    const numFrom = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.from));
    const denFrom = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.from));
    const numTo   = piezas.filter(p=>p.rol==='num').map(p=>formatUnitLabel(p.to));
    const denTo   = piezas.filter(p=>p.rol==='den').map(p=>formatUnitLabel(p.to));
    const unitFrom = numFrom.join(dot) + (denFrom.length? '/' + denFrom.join(dot) : '');
    const unitTo   = numTo.join(dot)   + (denTo.length?   '/' + denTo.join(dot)   : '');

    console.log('âœ… Camino compuesto:', unitFrom, 'â†’', unitTo);

    // Cantidad
    const cantidad = rndInt(1, 20);
    console.log(`\uD83D\uDCE6 Cantidad inicial: ${sci(cantidad)} ${unitFrom}`);

    // Factor combinado
    let factorTotal = 1; const factores = [];
    for (const pieza of piezas){
      for (const st of pieza.path){
        factores.push(describeConversion(st.from, st.to, st.rule));
      }
      if (pieza.rol === 'num') factorTotal *= pieza.factor; else factorTotal /= pieza.factor;
    }

    let valor = cantidad * factorTotal;
    if (!Number.isFinite(valor)){ console.error('ðŸ’¥ Valor no finito:', valor); continue; }

    const correctoStr = sci(valor);
    console.log(`ðŸŽ¯ Resultado correcto: ${correctoStr} ${unitTo}`);
    console.log('ðŸ§® Factores aplicados:', factores);

    const distractoresNum = generarDistractores(valor);
    if (distractoresNum.length < 3){
      const set = new Set(distractoresNum); const base = Math.max(Math.abs(valor), 1);
      let extra=1; while (set.size<3){ set.add(valor + base*extra); extra++; }
      distractoresNum.splice(0, distractoresNum.length, ...Array.from(set));
    }
    const opcionesFmt = shuffle([valor, ...distractoresNum.slice(0,3)]).map(sci);
    console.log('ðŸ§  Opciones generadas:', opcionesFmt);

    return {
      tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
      prompt: `Convierte ${sci(cantidad)} ${unitFrom} a ${unitTo}.`,
      equivalencias: factores,
      options: opcionesFmt,
      correct: [opcionesFmt.indexOf(correctoStr)]
    };
  }

  console.error('âŒ No se pudo generar pregunta vÃ¡lida, devolviendo fallback...');
  return { tema: 'Magnitudes y Unidades', modelos: ['C','D'], repeatable: true, mode: 'single',
    prompt: 'Convierte 1 km a m. (Equivalencia: 1 km = 1000 m)', options: ['1000','100','10','2000'], correct: [0] };
}










REGISTRY.types["magnitudes_y_unidades"] = {
  name: "Magnitudes y Unidades",
  templates: [conversion_unidades]
};











function configuracion_electronica(){
  const Z = Math.floor(Math.random() * 50) + 1;
  const elem = ELEMENTOS[Z];
  const pregunta = `Â¿CuÃ¡l es la configuraciÃ³n electrÃ³nica del ${elem.nombre} (Z=${Z})?`;
  const correcta = elem.config;

  const distractores = new Set();

  function generarIncorrecta(){
    const modo = rndInt(1,4);
    let propuesta = "";

    if (modo === 1){
      const partes = correcta.split(" ");
      if (partes.length > 1) propuesta = [...partes].reverse().join(" ");
    } else if (modo === 2){
      let offset = Z + (Math.random() < 0.5 ? -9 : 9);
      if (ELEMENTOS[offset]) propuesta = ELEMENTOS[offset].config;
    } else if (modo === 3){
      propuesta = correcta.replace(/s/g,"p").replace(/p/g,"s");
    } else {
      propuesta = correcta.replace(/p6/,"p7").replace(/d10/,"d11");
    }

    return propuesta;
  }

  while (distractores.size < 3){
    const cand = generarIncorrecta();
    if (cand && cand !== correcta && !distractores.has(cand)){
      distractores.add(cand);
    }
  }

  const opciones = shuffle([correcta, ...distractores]);

  return {
    tema: "TeorÃ­a de los electrones",
    modelos: ["C","D"],
    repeatable: true,
    mode: "single",
    prompt: pregunta,
    options: opciones,
    correct: [opciones.indexOf(correcta)]
  };
}

function pregunta_teoria_de_los_electrones_1() {
  let correcta = "Protones y neutrones";
  let incorrectas = [
    "Electrones y protones",
    "Electrones y neutrones",
    "Electrones, protones y neutrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© partÃ­culas forman el nÃºcleo atÃ³mico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_2() {
  let correcta = "Ligeramente menor que la del neutrÃ³n";
  let incorrectas = [
    "Exactamente igual a la del neutrÃ³n",
    "Mayor que la del neutrÃ³n",
    "La mitad de la del neutrÃ³n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del protÃ³n es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_3() {
  let correcta = "Igual en magnitud y de signo contrario";
  let incorrectas = [
    "Mayor en magnitud y del mismo signo",
    "Menor en magnitud y de signo contrario",
    "Igual en magnitud y del mismo signo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La carga del protÃ³n, en comparaciÃ³n con la del electrÃ³n, es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_4() {
  let correcta = "Aproximadamente 1/1836 de la masa del protÃ³n";
  let incorrectas = [
    "Igual a la masa del protÃ³n",
    "El doble de la masa del protÃ³n",
    "Aproximadamente 1/100 de la masa del protÃ³n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "La masa del electrÃ³n es...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_5() {
  let correcta = "Que el nÃºmero de protones es igual al nÃºmero de electrones";
  let incorrectas = [
    "Que el nÃºmero de protones es igual al nÃºmero de neutrones",
    "Que el nÃºmero de electrones es igual al nÃºmero de neutrones",
    "Que el nÃºmero de protones, electrones y neutrones es siempre el mismo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© significa que un Ã¡tomo estÃ© en equilibrio?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_6() {
  let correcta = "El nÃºmero cuÃ¡ntico azimutal (l)";
  let incorrectas = [
    "El nÃºmero cuÃ¡ntico principal (n)",
    "El nÃºmero cuÃ¡ntico magnÃ©tico (m)",
    "El nÃºmero cuÃ¡ntico de espÃ­n (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© nÃºmero cuÃ¡ntico determina la forma del orbital atÃ³mico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_7() {
  let correcta = "El nÃºmero cuÃ¡ntico magnÃ©tico (m)";
  let incorrectas = [
    "El nÃºmero cuÃ¡ntico principal (n)",
    "El nÃºmero cuÃ¡ntico azimutal (l)",
    "El nÃºmero cuÃ¡ntico de espÃ­n (s)"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© nÃºmero cuÃ¡ntico determina la orientaciÃ³n del orbital atÃ³mico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_8() {
  let correcta = "El nivel de energÃ­a y tamaÃ±o del orbital";
  let incorrectas = [
    "La forma del orbital",
    "La orientaciÃ³n espacial del orbital",
    "El espÃ­n del electrÃ³n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© describe el nÃºmero cuÃ¡ntico principal (n)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_9() {
  let correcta = "La orientaciÃ³n del giro intrÃ­nseco del electrÃ³n";
  let incorrectas = [
    "La energÃ­a del orbital",
    "La forma del orbital",
    "La orientaciÃ³n espacial del orbital"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© indica el nÃºmero cuÃ¡ntico de espÃ­n (s)?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_10() {
  let correcta = "2 electrones";
  let incorrectas = [
    "1 electrÃ³n",
    "4 electrones",
    "Hasta 8 electrones"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿CuÃ¡ntos electrones pueden alojarse como mÃ¡ximo en un suborbital?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_11() {
  let correcta = "CatiÃ³n";
  let incorrectas = [
    "AniÃ³n",
    "MolÃ©cula",
    "ProtÃ³n"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Cuando un Ã¡tomo pierde un electrÃ³n se forma un...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_12() {
  let correcta = "La comparticiÃ³n de electrones entre Ã¡tomos";
  let incorrectas = [
    "La transferencia completa de electrones", 
    "La atracciÃ³n electrostÃ¡tica entre iones", 
    "La presencia de un mar de electrones libres"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© caracteriza al enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_13() {
  let correcta = "Entre no metales";
  let incorrectas = [
    "Entre metales y no metales",
    "Entre metales",
    "Entre gases nobles"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿Entre quÃ© tipos de elementos se da un enlace covalente?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_14() {
  let correcta = "La energÃ­a necesaria para introducir un electrÃ³n en un Ã¡tomo neutro";
  let incorrectas = [
    "La energÃ­a necesaria para arrancar un electrÃ³n de un Ã¡tomo neutro", 
    "La capacidad de un Ã¡tomo para atraer electrones en un enlace quÃ­mico", 
    "La energÃ­a necesaria para separar protones y neutrones en el nÃºcleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© es la afinidad electrÃ³nica?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_15() {
  let correcta = "Negativa, tienden a ceder electrones, son reductores y se oxidan";
  let incorrectas = [
    "Positiva, tienden a ganar electrones, son oxidantes y se reducen",
    "Negativa, tienden a ganar electrones, son oxidantes y se reducen",
    "Positiva, tienden a ceder electrones, son reductores y se oxidan"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los metales tienen una afinidad electrÃ³nica...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_16() {
  let correcta = "En la transferencia completa de electrones entre un metal y un no metal, formÃ¡ndose iones que se atraen por fuerzas electrostÃ¡ticas";
  let incorrectas = [
    "En la comparticiÃ³n de electrones entre Ã¡tomos no metÃ¡licos",  
    "En la existencia de un mar de electrones libres entre Ã¡tomos metÃ¡licos", 
    "En la atracciÃ³n de un nÃºcleo hacia los electrones de otro nÃºcleo"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿En quÃ© consiste un enlace iÃ³nico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_17() {
  let correcta = "Covalente";
  let incorrectas = [
    "IÃ³nico",
    "MetÃ¡lico",
    "De Van der Waals"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "El hidrÃ³geno molecular (Hâ‚‚) y el oxÃ­geno molecular (Oâ‚‚) son molÃ©culas con enlace...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_18() {
  let correcta = "Son sÃ³lidos cristalinos, con altos puntos de fusiÃ³n y conductores en disoluciÃ³n o fundidos";
  let incorrectas = [
    "Son blandos, con bajos puntos de fusiÃ³n y no conducen la electricidad", 
    "Son maleables, dÃºctiles y buenos conductores en estado sÃ³lido", 
    "Son gaseosos en condiciones normales y no forman redes cristalinas"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© caracterÃ­sticas fÃ­sicas presentan los compuestos iÃ³nicos?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_19() {
  let correcta = "Cationes metÃ¡licos";
  let incorrectas = [
    "Aniones metÃ¡licos",
    "Protones libres",
    "Electrones deslocalizados"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿CÃ³mo se denominan los pseudoiones positivos en el enlace metÃ¡lico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_20() {
  let correcta = "El equilibrio entre los cationes metÃ¡licos y los electrones deslocalizados";
  let incorrectas = [
    "La repulsiÃ³n entre los electrones deslocalizados", 
    "La atracciÃ³n entre protones y neutrones",
    "La alternancia de iones positivos y negativos en una red cristalina"
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© mantiene la neutralidad electrostÃ¡tica en el enlace metÃ¡lico?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_21() {
  let correcta = "1, 8"; 
  let incorrectas = [
    "2, 6", // âŒ Incorrecta
    "3, 7", // âŒ Incorrecta
    "4, 2"  // âŒ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Los elementos conductores serÃ¡n aquellos que tienen ... de valencia. Los aislantes serÃ¡n los que tienen ... electrones en su capa de valencia.",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_22() {
  let correcta = "La plata (Ag)";
  let incorrectas = [
    "El cobre (Cu)",   // âŒ Incorrecta
    "El oro (Au)",     // âŒ Incorrecta
    "El aluminio (Al)" // âŒ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© material es el mejor conductor de la electricidad?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_23() {
  let correcta = "Un material puro cuya conductividad depende de la temperatura y no de impurezas aÃ±adidas";
  let incorrectas = [
    "Un material puro cuya conductividad depende Ãºnicamente de impurezas aÃ±adidas", // âŒ ExtrÃ­nseco
    "Un metal con baja resistividad elÃ©ctrica",                                    // âŒ Incorrecta
    "Un aislante que nunca puede conducir electricidad"                            // âŒ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Â¿QuÃ© es un semiconductor intrÃ­nseco?",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_24() {
  let correcta = "Tipo P";
  let incorrectas = [
    "Tipo N",   // âŒ Incorrecta
    "Tipo NP",  // âŒ Incorrecta
    "IntrÃ­nseco" // âŒ Incorrecta
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Si se aÃ±ade galio (Ga) a un cristal de silicio (Si), se formarÃ¡ un semiconductor...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}


function pregunta_teoria_de_los_electrones_25() {
  let correcta = "N"; 
  let incorrectas = [
    "P",            // âŒ Aceptoras, grupo III
    "NP",           // âŒ
    "IntrÃ­nsecas"   // âŒ
  ];

  let opciones = [correcta, ...incorrectas];
  opciones = shuffle(opciones);

  return {
    mode: "single",
    prompt: "Un semiconductor donante estÃ¡ dopado con impurezas de tipo...",
    options: opciones,
    correct: [opciones.indexOf(correcta)],
    modelos: ["B","D"],
    repeatable: false
  };
}

















</script>


</script>
</body>
</html>









